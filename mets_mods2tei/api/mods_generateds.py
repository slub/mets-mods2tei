#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Thu Nov 28 14:12:00 2019 by generateDS.py version 2.35.7.
# Python 3.6.7 (default, Oct 22 2018, 11:32:17)  [GCC 8.2.0]
#
# Command line options:
#   ('-f', '')
#   ('--root-element', 'mods')
#   ('-o', 'mets_mods2tei/api/mods_generateds.py')
#
# Command line arguments:
#   mods.xsd
#
# Command line:
#   /home/kmw/Documents/Work/SLUB/src/mets-mods2teiHeader/env/bin/generateDS -f --root-element="mods" -o "mets_mods2tei/api/mods_generateds.py" mods.xsd
#
# Current working directory (os.getcwd()):
#   mets-mods2teiHeader
#

from six.moves import zip_longest
import os
import sys
import re as re_
import base64
import datetime as datetime_
import decimal as decimal_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
SaveElementTreeNode = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    try:
        if isinstance(infile, os.PathLike):
            infile = os.path.join(infile)
    except AttributeError:
        pass
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for an example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#
# Additionally, the generatedsnamespaces module can contain a python
# dictionary named GenerateDSNamespaceTypePrefixes that associates element
# types with the namespace prefixes that are to be added to the
# "xsi:type" attribute value.  See the exportAttributes method of
# any generated element type and the generation of "xsi:type" for an
# example of the use of this table.
# An example table:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceTypePrefixes = {
#         "ElementtypeC": "aaa:",
#         "ElementtypeD": "bbb:",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}
try:
    from generatedsnamespaces import GenerateDSNamespaceTypePrefixes as GenerateDSNamespaceTypePrefixes_
except ImportError:
    GenerateDSNamespaceTypePrefixes_ = {}

#
# You can replace the following class definition by defining an
# importable module named "generatedscollector" containing a class
# named "GdsCollector".  See the default class definition below for
# clues about the possible content of that class.
#
try:
    from generatedscollector import GdsCollector as GdsCollector_
except ImportError:

    class GdsCollector_(object):

        def __init__(self, messages=None):
            if messages is None:
                self.messages = []
            else:
                self.messages = messages

        def add_message(self, msg):
            self.messages.append(msg)

        def get_messages(self):
            return self.messages

        def clear_messages(self):
            self.messages = []

        def print_messages(self):
            for msg in self.messages:
                print("Warning: {}".format(msg))

        def write_messages(self, outstream):
            for msg in self.messages:
                outstream.write("Warning: {}\n".format(msg))


#
# The super-class for enum types
#

try:
    from enum import Enum
except ImportError:
    Enum = object

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:
    
    class GeneratedsSuper(object):
        __hash__ = object.__hash__
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_parse_string(self, input_data, node=None, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_parse_integer(self, input_data, node=None, input_name=''):
            try:
                ival = int(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires integer value: %s' % exp)
            return ival
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            try:
                value = int(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires integer value')
            return value
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integer valuess')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_parse_float(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires float or double value: %s' % exp)
            return fval_
        def gds_validate_float(self, input_data, node=None, input_name=''):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires float value')
            return value
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of float values')
            return values
        def gds_format_decimal(self, input_data, input_name=''):
            return ('%0.10f' % input_data).rstrip('0')
        def gds_parse_decimal(self, input_data, node=None, input_name=''):
            try:
                decimal_value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return decimal_value
        def gds_validate_decimal(self, input_data, node=None, input_name=''):
            try:
                value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return value
        def gds_format_decimal_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_decimal_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    decimal_.Decimal(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of decimal values')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_parse_double(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires double or float value: %s' % exp)
            return fval_
        def gds_validate_double(self, input_data, node=None, input_name=''):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires double or float value')
            return value
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(
                        node, 'Requires sequence of double or float values')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_parse_boolean(self, input_data, node=None, input_name=''):
            if input_data in ('true', '1'):
                bval = True
            elif input_data in ('false', '0'):
                bval = False
            else:
                raise_parse_error(node, 'Requires boolean value')
            return bval
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            if input_data not in (True, 1, False, 0, ):
                raise_parse_error(
                    node,
                    'Requires boolean value '
                    '(one of True, 1, False, 0)')
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in (True, 1, False, 0, ):
                    raise_parse_error(
                        node,
                        'Requires sequence of boolean values '
                        '(one of True, 1, False, 0)')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (
                    time_parts[0], "{}".format(micro_seconds).rjust(6, "0"), )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.
            # The target value must match at least one of the patterns
            # in order for the test to succeed.
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    mo = re_.search(patterns2, target)
                    if mo is not None and len(mo.group(0)) == len(target):
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_check_cardinality_(
                self, value, input_name,
                min_occurs=0, max_occurs=1, required=None):
            if value is None:
                length = 0
            elif isinstance(value, list):
                length = len(value)
            else:
                length = 1
            if required is not None :
                if required and length < 1:
                    self.gds_collector_.add_message(
                        "Required value {}{} is missing".format(
                            input_name, self.gds_get_node_lineno_()))
            if length < min_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is below "
                    "the minimum allowed, "
                    "expected at least {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(),
                        min_occurs, length))
            elif length > max_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is above "
                    "the maximum allowed, "
                    "expected at most {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(),
                        max_occurs, length))
        def gds_validate_builtin_ST_(
                self, validator, value, input_name,
                min_occurs=None, max_occurs=None, required=None):
            if value is not None:
                try:
                    validator(value, input_name=input_name)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))
        def gds_validate_defined_ST_(
                self, validator, value, input_name,
                min_occurs=None, max_occurs=None, required=None):
            if value is not None:
                try:
                    validator(value)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            # provide default value in case option --disable-xml is used.
            content = ""
            content = etree_.tostring(node, encoding="unicode")
            return content
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.items()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                if ExternalEncoding:
                    encoding = ExternalEncoding
                else:
                    encoding = 'utf-8'
                return instring.encode(encoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            def excl_select_objs_(obj):
                return (obj[0] != 'parent_object_' and
                        obj[0] != 'gds_collector_')
            if type(self) != type(other):
                return False
            return all(x == y for x, y in zip_longest(
                filter(excl_select_objs_, self.__dict__.items()),
                filter(excl_select_objs_, other.__dict__.items())))
        def __ne__(self, other):
            return not self.__eq__(other)
        # Django ETL transform hooks.
        def gds_djo_etl_transform(self):
            pass
        def gds_djo_etl_transform_db_obj(self, dbobj):
            pass
        # SQLAlchemy ETL transform hooks.
        def gds_sqa_etl_transform(self):
            return 0, None
        def gds_sqa_etl_transform_db_obj(self, dbobj):
            pass
        def gds_get_node_lineno_(self):
            if (hasattr(self, "gds_elementtree_node_") and
                    self.gds_elementtree_node_ is not None):
                return ' near line {}'.format(
                    self.gds_elementtree_node_.sourceline)
            else:
                return ""
    
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = ''
# Set this to false in order to deactivate during export, the use of
# name space prefixes captured from the input document.
UseCapturedNS_ = True
CapturedNsmap_ = {}
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


def encode_str_2_3(instr):
    return instr


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if node is not None:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name_=name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class codeOrText(Enum):
    CODE='code'
    TEXT='text'


class digitalOriginDefinition(Enum):
    BORNDIGITAL='born digital'
    REFORMATTEDDIGITAL='reformatted digital'
    DIGITIZEDMICROFILM='digitized microfilm'
    DIGITIZEDOTHERANALOG='digitized other analog'


class issuanceDefinition(Enum):
    CONTINUING='continuing'
    MONOGRAPHIC='monographic'
    SINGLEUNIT='single unit'
    MULTIPARTMONOGRAPH='multipart monograph'
    SERIAL='serial'
    INTEGRATINGRESOURCE='integrating resource'


class reformattingQualityDefinition(Enum):
    ACCESS='access'
    PRESERVATION='preservation'
    REPLACEMENT='replacement'


class modsDefinition(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, version=None, abstract=None, accessCondition=None, classification=None, extension=None, genre=None, identifier=None, language=None, location=None, name=None, note=None, originInfo=None, part=None, physicalDescription=None, recordInfo=None, relatedItem=None, subject=None, tableOfContents=None, targetAudience=None, titleInfo=None, typeOfResource=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.version = _cast(None, version)
        self.version_nsprefix_ = None
        if abstract is None:
            self.abstract = []
        else:
            self.abstract = abstract
        self.abstract_nsprefix_ = None
        if accessCondition is None:
            self.accessCondition = []
        else:
            self.accessCondition = accessCondition
        self.accessCondition_nsprefix_ = None
        if classification is None:
            self.classification = []
        else:
            self.classification = classification
        self.classification_nsprefix_ = None
        if extension is None:
            self.extension = []
        else:
            self.extension = extension
        self.extension_nsprefix_ = None
        if genre is None:
            self.genre = []
        else:
            self.genre = genre
        self.genre_nsprefix_ = None
        if identifier is None:
            self.identifier = []
        else:
            self.identifier = identifier
        self.identifier_nsprefix_ = None
        if language is None:
            self.language = []
        else:
            self.language = language
        self.language_nsprefix_ = None
        if location is None:
            self.location = []
        else:
            self.location = location
        self.location_nsprefix_ = None
        if name is None:
            self.name = []
        else:
            self.name = name
        self.name_nsprefix_ = None
        if note is None:
            self.note = []
        else:
            self.note = note
        self.note_nsprefix_ = None
        if originInfo is None:
            self.originInfo = []
        else:
            self.originInfo = originInfo
        self.originInfo_nsprefix_ = None
        if part is None:
            self.part = []
        else:
            self.part = part
        self.part_nsprefix_ = None
        if physicalDescription is None:
            self.physicalDescription = []
        else:
            self.physicalDescription = physicalDescription
        self.physicalDescription_nsprefix_ = None
        if recordInfo is None:
            self.recordInfo = []
        else:
            self.recordInfo = recordInfo
        self.recordInfo_nsprefix_ = None
        if relatedItem is None:
            self.relatedItem = []
        else:
            self.relatedItem = relatedItem
        self.relatedItem_nsprefix_ = None
        if subject is None:
            self.subject = []
        else:
            self.subject = subject
        self.subject_nsprefix_ = None
        if tableOfContents is None:
            self.tableOfContents = []
        else:
            self.tableOfContents = tableOfContents
        self.tableOfContents_nsprefix_ = None
        if targetAudience is None:
            self.targetAudience = []
        else:
            self.targetAudience = targetAudience
        self.targetAudience_nsprefix_ = None
        if titleInfo is None:
            self.titleInfo = []
        else:
            self.titleInfo = titleInfo
        self.titleInfo_nsprefix_ = None
        if typeOfResource is None:
            self.typeOfResource = []
        else:
            self.typeOfResource = typeOfResource
        self.typeOfResource_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, modsDefinition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if modsDefinition.subclass:
            return modsDefinition.subclass(*args_, **kwargs_)
        else:
            return modsDefinition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_abstract(self):
        return self.abstract
    def set_abstract(self, abstract):
        self.abstract = abstract
    def add_abstract(self, value):
        self.abstract.append(value)
    def insert_abstract_at(self, index, value):
        self.abstract.insert(index, value)
    def replace_abstract_at(self, index, value):
        self.abstract[index] = value
    def get_accessCondition(self):
        return self.accessCondition
    def set_accessCondition(self, accessCondition):
        self.accessCondition = accessCondition
    def add_accessCondition(self, value):
        self.accessCondition.append(value)
    def insert_accessCondition_at(self, index, value):
        self.accessCondition.insert(index, value)
    def replace_accessCondition_at(self, index, value):
        self.accessCondition[index] = value
    def get_classification(self):
        return self.classification
    def set_classification(self, classification):
        self.classification = classification
    def add_classification(self, value):
        self.classification.append(value)
    def insert_classification_at(self, index, value):
        self.classification.insert(index, value)
    def replace_classification_at(self, index, value):
        self.classification[index] = value
    def get_extension(self):
        return self.extension
    def set_extension(self, extension):
        self.extension = extension
    def add_extension(self, value):
        self.extension.append(value)
    def insert_extension_at(self, index, value):
        self.extension.insert(index, value)
    def replace_extension_at(self, index, value):
        self.extension[index] = value
    def get_genre(self):
        return self.genre
    def set_genre(self, genre):
        self.genre = genre
    def add_genre(self, value):
        self.genre.append(value)
    def insert_genre_at(self, index, value):
        self.genre.insert(index, value)
    def replace_genre_at(self, index, value):
        self.genre[index] = value
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def add_identifier(self, value):
        self.identifier.append(value)
    def insert_identifier_at(self, index, value):
        self.identifier.insert(index, value)
    def replace_identifier_at(self, index, value):
        self.identifier[index] = value
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def add_language(self, value):
        self.language.append(value)
    def insert_language_at(self, index, value):
        self.language.insert(index, value)
    def replace_language_at(self, index, value):
        self.language[index] = value
    def get_location(self):
        return self.location
    def set_location(self, location):
        self.location = location
    def add_location(self, value):
        self.location.append(value)
    def insert_location_at(self, index, value):
        self.location.insert(index, value)
    def replace_location_at(self, index, value):
        self.location[index] = value
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def add_name(self, value):
        self.name.append(value)
    def insert_name_at(self, index, value):
        self.name.insert(index, value)
    def replace_name_at(self, index, value):
        self.name[index] = value
    def get_note(self):
        return self.note
    def set_note(self, note):
        self.note = note
    def add_note(self, value):
        self.note.append(value)
    def insert_note_at(self, index, value):
        self.note.insert(index, value)
    def replace_note_at(self, index, value):
        self.note[index] = value
    def get_originInfo(self):
        return self.originInfo
    def set_originInfo(self, originInfo):
        self.originInfo = originInfo
    def add_originInfo(self, value):
        self.originInfo.append(value)
    def insert_originInfo_at(self, index, value):
        self.originInfo.insert(index, value)
    def replace_originInfo_at(self, index, value):
        self.originInfo[index] = value
    def get_part(self):
        return self.part
    def set_part(self, part):
        self.part = part
    def add_part(self, value):
        self.part.append(value)
    def insert_part_at(self, index, value):
        self.part.insert(index, value)
    def replace_part_at(self, index, value):
        self.part[index] = value
    def get_physicalDescription(self):
        return self.physicalDescription
    def set_physicalDescription(self, physicalDescription):
        self.physicalDescription = physicalDescription
    def add_physicalDescription(self, value):
        self.physicalDescription.append(value)
    def insert_physicalDescription_at(self, index, value):
        self.physicalDescription.insert(index, value)
    def replace_physicalDescription_at(self, index, value):
        self.physicalDescription[index] = value
    def get_recordInfo(self):
        return self.recordInfo
    def set_recordInfo(self, recordInfo):
        self.recordInfo = recordInfo
    def add_recordInfo(self, value):
        self.recordInfo.append(value)
    def insert_recordInfo_at(self, index, value):
        self.recordInfo.insert(index, value)
    def replace_recordInfo_at(self, index, value):
        self.recordInfo[index] = value
    def get_relatedItem(self):
        return self.relatedItem
    def set_relatedItem(self, relatedItem):
        self.relatedItem = relatedItem
    def add_relatedItem(self, value):
        self.relatedItem.append(value)
    def insert_relatedItem_at(self, index, value):
        self.relatedItem.insert(index, value)
    def replace_relatedItem_at(self, index, value):
        self.relatedItem[index] = value
    def get_subject(self):
        return self.subject
    def set_subject(self, subject):
        self.subject = subject
    def add_subject(self, value):
        self.subject.append(value)
    def insert_subject_at(self, index, value):
        self.subject.insert(index, value)
    def replace_subject_at(self, index, value):
        self.subject[index] = value
    def get_tableOfContents(self):
        return self.tableOfContents
    def set_tableOfContents(self, tableOfContents):
        self.tableOfContents = tableOfContents
    def add_tableOfContents(self, value):
        self.tableOfContents.append(value)
    def insert_tableOfContents_at(self, index, value):
        self.tableOfContents.insert(index, value)
    def replace_tableOfContents_at(self, index, value):
        self.tableOfContents[index] = value
    def get_targetAudience(self):
        return self.targetAudience
    def set_targetAudience(self, targetAudience):
        self.targetAudience = targetAudience
    def add_targetAudience(self, value):
        self.targetAudience.append(value)
    def insert_targetAudience_at(self, index, value):
        self.targetAudience.insert(index, value)
    def replace_targetAudience_at(self, index, value):
        self.targetAudience[index] = value
    def get_titleInfo(self):
        return self.titleInfo
    def set_titleInfo(self, titleInfo):
        self.titleInfo = titleInfo
    def add_titleInfo(self, value):
        self.titleInfo.append(value)
    def insert_titleInfo_at(self, index, value):
        self.titleInfo.insert(index, value)
    def replace_titleInfo_at(self, index, value):
        self.titleInfo[index] = value
    def get_typeOfResource(self):
        return self.typeOfResource
    def set_typeOfResource(self, typeOfResource):
        self.typeOfResource = typeOfResource
    def add_typeOfResource(self, value):
        self.typeOfResource.append(value)
    def insert_typeOfResource_at(self, index, value):
        self.typeOfResource.insert(index, value)
    def replace_typeOfResource_at(self, index, value):
        self.typeOfResource[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_version(self):
        return self.version
    def set_version(self, version):
        self.version = version
    def hasContent_(self):
        if (
            self.abstract or
            self.accessCondition or
            self.classification or
            self.extension or
            self.genre or
            self.identifier or
            self.language or
            self.location or
            self.name or
            self.note or
            self.originInfo or
            self.part or
            self.physicalDescription or
            self.recordInfo or
            self.relatedItem or
            self.subject or
            self.tableOfContents or
            self.targetAudience or
            self.titleInfo or
            self.typeOfResource
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='modsDefinition', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('modsDefinition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='modsDefinition')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='modsDefinition', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='modsDefinition'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.version), input_name='version')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='modsDefinition', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for abstract_ in self.abstract:
            namespaceprefix_ = self.abstract_nsprefix_ + ':' if (UseCapturedNS_ and self.abstract_nsprefix_) else ''
            abstract_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='abstract', pretty_print=pretty_print)
        for accessCondition_ in self.accessCondition:
            namespaceprefix_ = self.accessCondition_nsprefix_ + ':' if (UseCapturedNS_ and self.accessCondition_nsprefix_) else ''
            accessCondition_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='accessCondition', pretty_print=pretty_print)
        for classification_ in self.classification:
            namespaceprefix_ = self.classification_nsprefix_ + ':' if (UseCapturedNS_ and self.classification_nsprefix_) else ''
            classification_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='classification', pretty_print=pretty_print)
        for extension_ in self.extension:
            namespaceprefix_ = self.extension_nsprefix_ + ':' if (UseCapturedNS_ and self.extension_nsprefix_) else ''
            extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='extension', pretty_print=pretty_print)
        for genre_ in self.genre:
            namespaceprefix_ = self.genre_nsprefix_ + ':' if (UseCapturedNS_ and self.genre_nsprefix_) else ''
            genre_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='genre', pretty_print=pretty_print)
        for identifier_ in self.identifier:
            namespaceprefix_ = self.identifier_nsprefix_ + ':' if (UseCapturedNS_ and self.identifier_nsprefix_) else ''
            identifier_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='identifier', pretty_print=pretty_print)
        for language_ in self.language:
            namespaceprefix_ = self.language_nsprefix_ + ':' if (UseCapturedNS_ and self.language_nsprefix_) else ''
            language_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='language', pretty_print=pretty_print)
        for location_ in self.location:
            namespaceprefix_ = self.location_nsprefix_ + ':' if (UseCapturedNS_ and self.location_nsprefix_) else ''
            location_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='location', pretty_print=pretty_print)
        for name_ in self.name:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            name_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='name', pretty_print=pretty_print)
        for note_ in self.note:
            namespaceprefix_ = self.note_nsprefix_ + ':' if (UseCapturedNS_ and self.note_nsprefix_) else ''
            note_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='note', pretty_print=pretty_print)
        for originInfo_ in self.originInfo:
            namespaceprefix_ = self.originInfo_nsprefix_ + ':' if (UseCapturedNS_ and self.originInfo_nsprefix_) else ''
            originInfo_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='originInfo', pretty_print=pretty_print)
        for part_ in self.part:
            namespaceprefix_ = self.part_nsprefix_ + ':' if (UseCapturedNS_ and self.part_nsprefix_) else ''
            part_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='part', pretty_print=pretty_print)
        for physicalDescription_ in self.physicalDescription:
            namespaceprefix_ = self.physicalDescription_nsprefix_ + ':' if (UseCapturedNS_ and self.physicalDescription_nsprefix_) else ''
            physicalDescription_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='physicalDescription', pretty_print=pretty_print)
        for recordInfo_ in self.recordInfo:
            namespaceprefix_ = self.recordInfo_nsprefix_ + ':' if (UseCapturedNS_ and self.recordInfo_nsprefix_) else ''
            recordInfo_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='recordInfo', pretty_print=pretty_print)
        for relatedItem_ in self.relatedItem:
            namespaceprefix_ = self.relatedItem_nsprefix_ + ':' if (UseCapturedNS_ and self.relatedItem_nsprefix_) else ''
            relatedItem_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='relatedItem', pretty_print=pretty_print)
        for subject_ in self.subject:
            namespaceprefix_ = self.subject_nsprefix_ + ':' if (UseCapturedNS_ and self.subject_nsprefix_) else ''
            subject_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subject', pretty_print=pretty_print)
        for tableOfContents_ in self.tableOfContents:
            namespaceprefix_ = self.tableOfContents_nsprefix_ + ':' if (UseCapturedNS_ and self.tableOfContents_nsprefix_) else ''
            tableOfContents_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='tableOfContents', pretty_print=pretty_print)
        for targetAudience_ in self.targetAudience:
            namespaceprefix_ = self.targetAudience_nsprefix_ + ':' if (UseCapturedNS_ and self.targetAudience_nsprefix_) else ''
            targetAudience_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='targetAudience', pretty_print=pretty_print)
        for titleInfo_ in self.titleInfo:
            namespaceprefix_ = self.titleInfo_nsprefix_ + ':' if (UseCapturedNS_ and self.titleInfo_nsprefix_) else ''
            titleInfo_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='titleInfo', pretty_print=pretty_print)
        for typeOfResource_ in self.typeOfResource:
            namespaceprefix_ = self.typeOfResource_nsprefix_ + ':' if (UseCapturedNS_ and self.typeOfResource_nsprefix_) else ''
            typeOfResource_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeOfResource', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'abstract':
            obj_ = abstractDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.abstract.append(obj_)
            obj_.original_tagname_ = 'abstract'
        elif nodeName_ == 'accessCondition':
            obj_ = accessConditionDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.accessCondition.append(obj_)
            obj_.original_tagname_ = 'accessCondition'
        elif nodeName_ == 'classification':
            obj_ = classificationDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.classification.append(obj_)
            obj_.original_tagname_ = 'classification'
        elif nodeName_ == 'extension':
            class_obj_ = self.get_class_obj_(child_, extensionDefinition)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.extension.append(obj_)
            obj_.original_tagname_ = 'extension'
        elif nodeName_ == 'genre':
            obj_ = genreDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.genre.append(obj_)
            obj_.original_tagname_ = 'genre'
        elif nodeName_ == 'identifier':
            obj_ = identifierDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier.append(obj_)
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'language':
            obj_ = languageDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.language.append(obj_)
            obj_.original_tagname_ = 'language'
        elif nodeName_ == 'location':
            obj_ = locationDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.location.append(obj_)
            obj_.original_tagname_ = 'location'
        elif nodeName_ == 'name':
            obj_ = nameDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.name.append(obj_)
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'note':
            obj_ = noteDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.note.append(obj_)
            obj_.original_tagname_ = 'note'
        elif nodeName_ == 'originInfo':
            obj_ = originInfoDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.originInfo.append(obj_)
            obj_.original_tagname_ = 'originInfo'
        elif nodeName_ == 'part':
            obj_ = partDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.part.append(obj_)
            obj_.original_tagname_ = 'part'
        elif nodeName_ == 'physicalDescription':
            obj_ = physicalDescriptionDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.physicalDescription.append(obj_)
            obj_.original_tagname_ = 'physicalDescription'
        elif nodeName_ == 'recordInfo':
            obj_ = recordInfoDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.recordInfo.append(obj_)
            obj_.original_tagname_ = 'recordInfo'
        elif nodeName_ == 'relatedItem':
            obj_ = relatedItemDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.relatedItem.append(obj_)
            obj_.original_tagname_ = 'relatedItem'
        elif nodeName_ == 'subject':
            obj_ = subjectDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subject.append(obj_)
            obj_.original_tagname_ = 'subject'
        elif nodeName_ == 'tableOfContents':
            obj_ = tableOfContentsDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.tableOfContents.append(obj_)
            obj_.original_tagname_ = 'tableOfContents'
        elif nodeName_ == 'targetAudience':
            obj_ = targetAudienceDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.targetAudience.append(obj_)
            obj_.original_tagname_ = 'targetAudience'
        elif nodeName_ == 'titleInfo':
            obj_ = titleInfoDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.titleInfo.append(obj_)
            obj_.original_tagname_ = 'titleInfo'
        elif nodeName_ == 'typeOfResource':
            obj_ = typeOfResourceDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeOfResource.append(obj_)
            obj_.original_tagname_ = 'typeOfResource'
# end class modsDefinition


class modsCollectionDefinition(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, mods=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if mods is None:
            self.mods = []
        else:
            self.mods = mods
        self.mods_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, modsCollectionDefinition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if modsCollectionDefinition.subclass:
            return modsCollectionDefinition.subclass(*args_, **kwargs_)
        else:
            return modsCollectionDefinition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_mods(self):
        return self.mods
    def set_mods(self, mods):
        self.mods = mods
    def add_mods(self, value):
        self.mods.append(value)
    def insert_mods_at(self, index, value):
        self.mods.insert(index, value)
    def replace_mods_at(self, index, value):
        self.mods[index] = value
    def hasContent_(self):
        if (
            self.mods
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='modsCollectionDefinition', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('modsCollectionDefinition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='modsCollectionDefinition')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='modsCollectionDefinition', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='modsCollectionDefinition'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='modsCollectionDefinition', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for mods_ in self.mods:
            namespaceprefix_ = self.mods_nsprefix_ + ':' if (UseCapturedNS_ and self.mods_nsprefix_) else ''
            mods_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='mods', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'mods':
            obj_ = modsDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.mods.append(obj_)
            obj_.original_tagname_ = 'mods'
# end class modsCollectionDefinition


class extensionDefinition(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, displayLabel=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.displayLabel = _cast(None, displayLabel)
        self.displayLabel_nsprefix_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, extensionDefinition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if extensionDefinition.subclass:
            return extensionDefinition.subclass(*args_, **kwargs_)
        else:
            return extensionDefinition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_displayLabel(self):
        return self.displayLabel
    def set_displayLabel(self, displayLabel):
        self.displayLabel = displayLabel
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.anytypeobjs_ or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='extensionDefinition', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('extensionDefinition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='extensionDefinition')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='extensionDefinition', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='extensionDefinition'):
        if self.displayLabel is not None and 'displayLabel' not in already_processed:
            already_processed.add('displayLabel')
            outfile.write(' displayLabel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.displayLabel), input_name='displayLabel')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='extensionDefinition', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespaceprefix_, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('displayLabel', node)
        if value is not None and 'displayLabel' not in already_processed:
            already_processed.add('displayLabel')
            self.displayLabel = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == '':
            obj_ = __ANY__.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class extensionDefinition


class languageDefinition(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, objectPart=None, displayLabel=None, altRepGroup=None, usage='primary', lang=None, script=None, transliteration=None, languageTerm=None, scriptTerm=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.objectPart = _cast(None, objectPart)
        self.objectPart_nsprefix_ = None
        self.displayLabel = _cast(None, displayLabel)
        self.displayLabel_nsprefix_ = None
        self.altRepGroup = _cast(None, altRepGroup)
        self.altRepGroup_nsprefix_ = None
        self.usage = _cast(None, usage)
        self.usage_nsprefix_ = None
        self.lang = _cast(None, lang)
        self.lang_nsprefix_ = None
        self.lang = _cast(None, lang)
        self.lang_nsprefix_ = None
        self.script = _cast(None, script)
        self.script_nsprefix_ = None
        self.transliteration = _cast(None, transliteration)
        self.transliteration_nsprefix_ = None
        if languageTerm is None:
            self.languageTerm = []
        else:
            self.languageTerm = languageTerm
        self.languageTerm_nsprefix_ = None
        if scriptTerm is None:
            self.scriptTerm = []
        else:
            self.scriptTerm = scriptTerm
        self.scriptTerm_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, languageDefinition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if languageDefinition.subclass:
            return languageDefinition.subclass(*args_, **kwargs_)
        else:
            return languageDefinition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_languageTerm(self):
        return self.languageTerm
    def set_languageTerm(self, languageTerm):
        self.languageTerm = languageTerm
    def add_languageTerm(self, value):
        self.languageTerm.append(value)
    def insert_languageTerm_at(self, index, value):
        self.languageTerm.insert(index, value)
    def replace_languageTerm_at(self, index, value):
        self.languageTerm[index] = value
    def get_scriptTerm(self):
        return self.scriptTerm
    def set_scriptTerm(self, scriptTerm):
        self.scriptTerm = scriptTerm
    def add_scriptTerm(self, value):
        self.scriptTerm.append(value)
    def insert_scriptTerm_at(self, index, value):
        self.scriptTerm.insert(index, value)
    def replace_scriptTerm_at(self, index, value):
        self.scriptTerm[index] = value
    def get_objectPart(self):
        return self.objectPart
    def set_objectPart(self, objectPart):
        self.objectPart = objectPart
    def get_displayLabel(self):
        return self.displayLabel
    def set_displayLabel(self, displayLabel):
        self.displayLabel = displayLabel
    def get_altRepGroup(self):
        return self.altRepGroup
    def set_altRepGroup(self, altRepGroup):
        self.altRepGroup = altRepGroup
    def get_usage(self):
        return self.usage
    def set_usage(self, usage):
        self.usage = usage
    def get_lang(self):
        return self.lang
    def set_lang(self, lang):
        self.lang = lang
    def get_lang(self):
        return self.lang
    def set_lang(self, lang):
        self.lang = lang
    def get_script(self):
        return self.script
    def set_script(self, script):
        self.script = script
    def get_transliteration(self):
        return self.transliteration
    def set_transliteration(self, transliteration):
        self.transliteration = transliteration
    def hasContent_(self):
        if (
            self.languageTerm or
            self.scriptTerm
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='languageDefinition', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('languageDefinition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='languageDefinition')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='languageDefinition', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='languageDefinition'):
        if self.objectPart is not None and 'objectPart' not in already_processed:
            already_processed.add('objectPart')
            outfile.write(' objectPart=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.objectPart), input_name='objectPart')), ))
        if self.displayLabel is not None and 'displayLabel' not in already_processed:
            already_processed.add('displayLabel')
            outfile.write(' displayLabel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.displayLabel), input_name='displayLabel')), ))
        if self.altRepGroup is not None and 'altRepGroup' not in already_processed:
            already_processed.add('altRepGroup')
            outfile.write(' altRepGroup=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.altRepGroup), input_name='altRepGroup')), ))
        if self.usage != "primary" and 'usage' not in already_processed:
            already_processed.add('usage')
            outfile.write(' usage=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.usage), input_name='usage')), ))
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lang), input_name='lang')), ))
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lang), input_name='lang')), ))
        if self.script is not None and 'script' not in already_processed:
            already_processed.add('script')
            outfile.write(' script=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.script), input_name='script')), ))
        if self.transliteration is not None and 'transliteration' not in already_processed:
            already_processed.add('transliteration')
            outfile.write(' transliteration=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.transliteration), input_name='transliteration')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='languageDefinition', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for languageTerm_ in self.languageTerm:
            namespaceprefix_ = self.languageTerm_nsprefix_ + ':' if (UseCapturedNS_ and self.languageTerm_nsprefix_) else ''
            languageTerm_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='languageTerm', pretty_print=pretty_print)
        for scriptTerm_ in self.scriptTerm:
            namespaceprefix_ = self.scriptTerm_nsprefix_ + ':' if (UseCapturedNS_ and self.scriptTerm_nsprefix_) else ''
            scriptTerm_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='scriptTerm', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('objectPart', node)
        if value is not None and 'objectPart' not in already_processed:
            already_processed.add('objectPart')
            self.objectPart = value
        value = find_attr_value_('displayLabel', node)
        if value is not None and 'displayLabel' not in already_processed:
            already_processed.add('displayLabel')
            self.displayLabel = value
        value = find_attr_value_('altRepGroup', node)
        if value is not None and 'altRepGroup' not in already_processed:
            already_processed.add('altRepGroup')
            self.altRepGroup = value
        value = find_attr_value_('usage', node)
        if value is not None and 'usage' not in already_processed:
            already_processed.add('usage')
            self.usage = value
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        value = find_attr_value_('script', node)
        if value is not None and 'script' not in already_processed:
            already_processed.add('script')
            self.script = value
        value = find_attr_value_('transliteration', node)
        if value is not None and 'transliteration' not in already_processed:
            already_processed.add('transliteration')
            self.transliteration = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'languageTerm':
            obj_ = languageTermDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.languageTerm.append(obj_)
            obj_.original_tagname_ = 'languageTerm'
        elif nodeName_ == 'scriptTerm':
            obj_ = scriptTermDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.scriptTerm.append(obj_)
            obj_.original_tagname_ = 'scriptTerm'
# end class languageDefinition


class locationDefinition(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, displayLabel=None, altRepGroup=None, lang=None, script=None, transliteration=None, physicalLocation=None, shelfLocator=None, url=None, holdingSimple=None, holdingExternal=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.displayLabel = _cast(None, displayLabel)
        self.displayLabel_nsprefix_ = None
        self.altRepGroup = _cast(None, altRepGroup)
        self.altRepGroup_nsprefix_ = None
        self.lang = _cast(None, lang)
        self.lang_nsprefix_ = None
        self.lang = _cast(None, lang)
        self.lang_nsprefix_ = None
        self.script = _cast(None, script)
        self.script_nsprefix_ = None
        self.transliteration = _cast(None, transliteration)
        self.transliteration_nsprefix_ = None
        if physicalLocation is None:
            self.physicalLocation = []
        else:
            self.physicalLocation = physicalLocation
        self.physicalLocation_nsprefix_ = None
        if shelfLocator is None:
            self.shelfLocator = []
        else:
            self.shelfLocator = shelfLocator
        self.shelfLocator_nsprefix_ = None
        if url is None:
            self.url = []
        else:
            self.url = url
        self.url_nsprefix_ = None
        self.holdingSimple = holdingSimple
        self.holdingSimple_nsprefix_ = None
        self.holdingExternal = holdingExternal
        self.holdingExternal_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, locationDefinition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if locationDefinition.subclass:
            return locationDefinition.subclass(*args_, **kwargs_)
        else:
            return locationDefinition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_physicalLocation(self):
        return self.physicalLocation
    def set_physicalLocation(self, physicalLocation):
        self.physicalLocation = physicalLocation
    def add_physicalLocation(self, value):
        self.physicalLocation.append(value)
    def insert_physicalLocation_at(self, index, value):
        self.physicalLocation.insert(index, value)
    def replace_physicalLocation_at(self, index, value):
        self.physicalLocation[index] = value
    def get_shelfLocator(self):
        return self.shelfLocator
    def set_shelfLocator(self, shelfLocator):
        self.shelfLocator = shelfLocator
    def add_shelfLocator(self, value):
        self.shelfLocator.append(value)
    def insert_shelfLocator_at(self, index, value):
        self.shelfLocator.insert(index, value)
    def replace_shelfLocator_at(self, index, value):
        self.shelfLocator[index] = value
    def get_url(self):
        return self.url
    def set_url(self, url):
        self.url = url
    def add_url(self, value):
        self.url.append(value)
    def insert_url_at(self, index, value):
        self.url.insert(index, value)
    def replace_url_at(self, index, value):
        self.url[index] = value
    def get_holdingSimple(self):
        return self.holdingSimple
    def set_holdingSimple(self, holdingSimple):
        self.holdingSimple = holdingSimple
    def get_holdingExternal(self):
        return self.holdingExternal
    def set_holdingExternal(self, holdingExternal):
        self.holdingExternal = holdingExternal
    def get_displayLabel(self):
        return self.displayLabel
    def set_displayLabel(self, displayLabel):
        self.displayLabel = displayLabel
    def get_altRepGroup(self):
        return self.altRepGroup
    def set_altRepGroup(self, altRepGroup):
        self.altRepGroup = altRepGroup
    def get_lang(self):
        return self.lang
    def set_lang(self, lang):
        self.lang = lang
    def get_lang(self):
        return self.lang
    def set_lang(self, lang):
        self.lang = lang
    def get_script(self):
        return self.script
    def set_script(self, script):
        self.script = script
    def get_transliteration(self):
        return self.transliteration
    def set_transliteration(self, transliteration):
        self.transliteration = transliteration
    def hasContent_(self):
        if (
            self.physicalLocation or
            self.shelfLocator or
            self.url or
            self.holdingSimple is not None or
            self.holdingExternal is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='locationDefinition', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('locationDefinition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='locationDefinition')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='locationDefinition', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='locationDefinition'):
        if self.displayLabel is not None and 'displayLabel' not in already_processed:
            already_processed.add('displayLabel')
            outfile.write(' displayLabel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.displayLabel), input_name='displayLabel')), ))
        if self.altRepGroup is not None and 'altRepGroup' not in already_processed:
            already_processed.add('altRepGroup')
            outfile.write(' altRepGroup=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.altRepGroup), input_name='altRepGroup')), ))
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lang), input_name='lang')), ))
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lang), input_name='lang')), ))
        if self.script is not None and 'script' not in already_processed:
            already_processed.add('script')
            outfile.write(' script=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.script), input_name='script')), ))
        if self.transliteration is not None and 'transliteration' not in already_processed:
            already_processed.add('transliteration')
            outfile.write(' transliteration=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.transliteration), input_name='transliteration')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='locationDefinition', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for physicalLocation_ in self.physicalLocation:
            namespaceprefix_ = self.physicalLocation_nsprefix_ + ':' if (UseCapturedNS_ and self.physicalLocation_nsprefix_) else ''
            physicalLocation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='physicalLocation', pretty_print=pretty_print)
        for shelfLocator_ in self.shelfLocator:
            namespaceprefix_ = self.shelfLocator_nsprefix_ + ':' if (UseCapturedNS_ and self.shelfLocator_nsprefix_) else ''
            shelfLocator_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='shelfLocator', pretty_print=pretty_print)
        for url_ in self.url:
            namespaceprefix_ = self.url_nsprefix_ + ':' if (UseCapturedNS_ and self.url_nsprefix_) else ''
            url_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='url', pretty_print=pretty_print)
        if self.holdingSimple is not None:
            namespaceprefix_ = self.holdingSimple_nsprefix_ + ':' if (UseCapturedNS_ and self.holdingSimple_nsprefix_) else ''
            self.holdingSimple.export(outfile, level, namespaceprefix_, namespacedef_='', name_='holdingSimple', pretty_print=pretty_print)
        if self.holdingExternal is not None:
            namespaceprefix_ = self.holdingExternal_nsprefix_ + ':' if (UseCapturedNS_ and self.holdingExternal_nsprefix_) else ''
            self.holdingExternal.export(outfile, level, namespaceprefix_, namespacedef_='', name_='holdingExternal', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('displayLabel', node)
        if value is not None and 'displayLabel' not in already_processed:
            already_processed.add('displayLabel')
            self.displayLabel = value
        value = find_attr_value_('altRepGroup', node)
        if value is not None and 'altRepGroup' not in already_processed:
            already_processed.add('altRepGroup')
            self.altRepGroup = value
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        value = find_attr_value_('script', node)
        if value is not None and 'script' not in already_processed:
            already_processed.add('script')
            self.script = value
        value = find_attr_value_('transliteration', node)
        if value is not None and 'transliteration' not in already_processed:
            already_processed.add('transliteration')
            self.transliteration = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'physicalLocation':
            obj_ = physicalLocationDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.physicalLocation.append(obj_)
            obj_.original_tagname_ = 'physicalLocation'
        elif nodeName_ == 'shelfLocator':
            class_obj_ = self.get_class_obj_(child_, stringPlusLanguage)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.shelfLocator.append(obj_)
            obj_.original_tagname_ = 'shelfLocator'
        elif nodeName_ == 'url':
            obj_ = urlDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.url.append(obj_)
            obj_.original_tagname_ = 'url'
        elif nodeName_ == 'holdingSimple':
            obj_ = holdingSimpleDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.holdingSimple = obj_
            obj_.original_tagname_ = 'holdingSimple'
        elif nodeName_ == 'holdingExternal':
            class_obj_ = self.get_class_obj_(child_, extensionDefinition)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.holdingExternal = obj_
            obj_.original_tagname_ = 'holdingExternal'
# end class locationDefinition


class holdingSimpleDefinition(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, copyInformation=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if copyInformation is None:
            self.copyInformation = []
        else:
            self.copyInformation = copyInformation
        self.copyInformation_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, holdingSimpleDefinition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if holdingSimpleDefinition.subclass:
            return holdingSimpleDefinition.subclass(*args_, **kwargs_)
        else:
            return holdingSimpleDefinition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_copyInformation(self):
        return self.copyInformation
    def set_copyInformation(self, copyInformation):
        self.copyInformation = copyInformation
    def add_copyInformation(self, value):
        self.copyInformation.append(value)
    def insert_copyInformation_at(self, index, value):
        self.copyInformation.insert(index, value)
    def replace_copyInformation_at(self, index, value):
        self.copyInformation[index] = value
    def hasContent_(self):
        if (
            self.copyInformation
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='holdingSimpleDefinition', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('holdingSimpleDefinition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='holdingSimpleDefinition')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='holdingSimpleDefinition', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='holdingSimpleDefinition'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='holdingSimpleDefinition', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for copyInformation_ in self.copyInformation:
            namespaceprefix_ = self.copyInformation_nsprefix_ + ':' if (UseCapturedNS_ and self.copyInformation_nsprefix_) else ''
            copyInformation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='copyInformation', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'copyInformation':
            obj_ = copyInformationDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.copyInformation.append(obj_)
            obj_.original_tagname_ = 'copyInformation'
# end class holdingSimpleDefinition


class copyInformationDefinition(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, form=None, subLocation=None, shelfLocator=None, electronicLocator=None, note=None, enumerationAndChronology=None, itemIdentifier=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.form = form
        self.form_nsprefix_ = None
        if subLocation is None:
            self.subLocation = []
        else:
            self.subLocation = subLocation
        self.subLocation_nsprefix_ = None
        if shelfLocator is None:
            self.shelfLocator = []
        else:
            self.shelfLocator = shelfLocator
        self.shelfLocator_nsprefix_ = None
        if electronicLocator is None:
            self.electronicLocator = []
        else:
            self.electronicLocator = electronicLocator
        self.electronicLocator_nsprefix_ = None
        if note is None:
            self.note = []
        else:
            self.note = note
        self.note_nsprefix_ = None
        if enumerationAndChronology is None:
            self.enumerationAndChronology = []
        else:
            self.enumerationAndChronology = enumerationAndChronology
        self.enumerationAndChronology_nsprefix_ = None
        if itemIdentifier is None:
            self.itemIdentifier = []
        else:
            self.itemIdentifier = itemIdentifier
        self.itemIdentifier_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, copyInformationDefinition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if copyInformationDefinition.subclass:
            return copyInformationDefinition.subclass(*args_, **kwargs_)
        else:
            return copyInformationDefinition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_form(self):
        return self.form
    def set_form(self, form):
        self.form = form
    def get_subLocation(self):
        return self.subLocation
    def set_subLocation(self, subLocation):
        self.subLocation = subLocation
    def add_subLocation(self, value):
        self.subLocation.append(value)
    def insert_subLocation_at(self, index, value):
        self.subLocation.insert(index, value)
    def replace_subLocation_at(self, index, value):
        self.subLocation[index] = value
    def get_shelfLocator(self):
        return self.shelfLocator
    def set_shelfLocator(self, shelfLocator):
        self.shelfLocator = shelfLocator
    def add_shelfLocator(self, value):
        self.shelfLocator.append(value)
    def insert_shelfLocator_at(self, index, value):
        self.shelfLocator.insert(index, value)
    def replace_shelfLocator_at(self, index, value):
        self.shelfLocator[index] = value
    def get_electronicLocator(self):
        return self.electronicLocator
    def set_electronicLocator(self, electronicLocator):
        self.electronicLocator = electronicLocator
    def add_electronicLocator(self, value):
        self.electronicLocator.append(value)
    def insert_electronicLocator_at(self, index, value):
        self.electronicLocator.insert(index, value)
    def replace_electronicLocator_at(self, index, value):
        self.electronicLocator[index] = value
    def get_note(self):
        return self.note
    def set_note(self, note):
        self.note = note
    def add_note(self, value):
        self.note.append(value)
    def insert_note_at(self, index, value):
        self.note.insert(index, value)
    def replace_note_at(self, index, value):
        self.note[index] = value
    def get_enumerationAndChronology(self):
        return self.enumerationAndChronology
    def set_enumerationAndChronology(self, enumerationAndChronology):
        self.enumerationAndChronology = enumerationAndChronology
    def add_enumerationAndChronology(self, value):
        self.enumerationAndChronology.append(value)
    def insert_enumerationAndChronology_at(self, index, value):
        self.enumerationAndChronology.insert(index, value)
    def replace_enumerationAndChronology_at(self, index, value):
        self.enumerationAndChronology[index] = value
    def get_itemIdentifier(self):
        return self.itemIdentifier
    def set_itemIdentifier(self, itemIdentifier):
        self.itemIdentifier = itemIdentifier
    def add_itemIdentifier(self, value):
        self.itemIdentifier.append(value)
    def insert_itemIdentifier_at(self, index, value):
        self.itemIdentifier.insert(index, value)
    def replace_itemIdentifier_at(self, index, value):
        self.itemIdentifier[index] = value
    def hasContent_(self):
        if (
            self.form is not None or
            self.subLocation or
            self.shelfLocator or
            self.electronicLocator or
            self.note or
            self.enumerationAndChronology or
            self.itemIdentifier
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='copyInformationDefinition', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('copyInformationDefinition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='copyInformationDefinition')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='copyInformationDefinition', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='copyInformationDefinition'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='copyInformationDefinition', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.form is not None:
            namespaceprefix_ = self.form_nsprefix_ + ':' if (UseCapturedNS_ and self.form_nsprefix_) else ''
            self.form.export(outfile, level, namespaceprefix_, namespacedef_='', name_='form', pretty_print=pretty_print)
        for subLocation_ in self.subLocation:
            namespaceprefix_ = self.subLocation_nsprefix_ + ':' if (UseCapturedNS_ and self.subLocation_nsprefix_) else ''
            subLocation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subLocation', pretty_print=pretty_print)
        for shelfLocator_ in self.shelfLocator:
            namespaceprefix_ = self.shelfLocator_nsprefix_ + ':' if (UseCapturedNS_ and self.shelfLocator_nsprefix_) else ''
            shelfLocator_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='shelfLocator', pretty_print=pretty_print)
        for electronicLocator_ in self.electronicLocator:
            namespaceprefix_ = self.electronicLocator_nsprefix_ + ':' if (UseCapturedNS_ and self.electronicLocator_nsprefix_) else ''
            electronicLocator_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='electronicLocator', pretty_print=pretty_print)
        for note_ in self.note:
            namespaceprefix_ = self.note_nsprefix_ + ':' if (UseCapturedNS_ and self.note_nsprefix_) else ''
            note_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='note', pretty_print=pretty_print)
        for enumerationAndChronology_ in self.enumerationAndChronology:
            namespaceprefix_ = self.enumerationAndChronology_nsprefix_ + ':' if (UseCapturedNS_ and self.enumerationAndChronology_nsprefix_) else ''
            enumerationAndChronology_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='enumerationAndChronology', pretty_print=pretty_print)
        for itemIdentifier_ in self.itemIdentifier:
            namespaceprefix_ = self.itemIdentifier_nsprefix_ + ':' if (UseCapturedNS_ and self.itemIdentifier_nsprefix_) else ''
            itemIdentifier_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='itemIdentifier', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'form':
            obj_ = formDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.form = obj_
            obj_.original_tagname_ = 'form'
        elif nodeName_ == 'subLocation':
            class_obj_ = self.get_class_obj_(child_, stringPlusLanguage)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subLocation.append(obj_)
            obj_.original_tagname_ = 'subLocation'
        elif nodeName_ == 'shelfLocator':
            class_obj_ = self.get_class_obj_(child_, stringPlusLanguage)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.shelfLocator.append(obj_)
            obj_.original_tagname_ = 'shelfLocator'
        elif nodeName_ == 'electronicLocator':
            class_obj_ = self.get_class_obj_(child_, stringPlusLanguage)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.electronicLocator.append(obj_)
            obj_.original_tagname_ = 'electronicLocator'
        elif nodeName_ == 'note':
            obj_ = noteType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.note.append(obj_)
            obj_.original_tagname_ = 'note'
        elif nodeName_ == 'enumerationAndChronology':
            obj_ = enumerationAndChronologyDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.enumerationAndChronology.append(obj_)
            obj_.original_tagname_ = 'enumerationAndChronology'
        elif nodeName_ == 'itemIdentifier':
            obj_ = itemIdentifierDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.itemIdentifier.append(obj_)
            obj_.original_tagname_ = 'itemIdentifier'
# end class copyInformationDefinition


class urlDefinition(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, dateLastAccessed=None, displayLabel=None, note=None, access=None, usage=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.dateLastAccessed = _cast(None, dateLastAccessed)
        self.dateLastAccessed_nsprefix_ = None
        self.displayLabel = _cast(None, displayLabel)
        self.displayLabel_nsprefix_ = None
        self.note = _cast(None, note)
        self.note_nsprefix_ = None
        self.access = _cast(None, access)
        self.access_nsprefix_ = None
        self.usage = _cast(None, usage)
        self.usage_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, urlDefinition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if urlDefinition.subclass:
            return urlDefinition.subclass(*args_, **kwargs_)
        else:
            return urlDefinition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_dateLastAccessed(self):
        return self.dateLastAccessed
    def set_dateLastAccessed(self, dateLastAccessed):
        self.dateLastAccessed = dateLastAccessed
    def get_displayLabel(self):
        return self.displayLabel
    def set_displayLabel(self, displayLabel):
        self.displayLabel = displayLabel
    def get_note(self):
        return self.note
    def set_note(self, note):
        self.note = note
    def get_access(self):
        return self.access
    def set_access(self, access):
        self.access = access
    def get_usage(self):
        return self.usage
    def set_usage(self, usage):
        self.usage = usage
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='urlDefinition', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('urlDefinition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='urlDefinition')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='urlDefinition', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='urlDefinition'):
        if self.dateLastAccessed is not None and 'dateLastAccessed' not in already_processed:
            already_processed.add('dateLastAccessed')
            outfile.write(' dateLastAccessed=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.dateLastAccessed), input_name='dateLastAccessed')), ))
        if self.displayLabel is not None and 'displayLabel' not in already_processed:
            already_processed.add('displayLabel')
            outfile.write(' displayLabel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.displayLabel), input_name='displayLabel')), ))
        if self.note is not None and 'note' not in already_processed:
            already_processed.add('note')
            outfile.write(' note=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.note), input_name='note')), ))
        if self.access is not None and 'access' not in already_processed:
            already_processed.add('access')
            outfile.write(' access=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.access), input_name='access')), ))
        if self.usage is not None and 'usage' not in already_processed:
            already_processed.add('usage')
            outfile.write(' usage=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.usage), input_name='usage')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='urlDefinition', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('dateLastAccessed', node)
        if value is not None and 'dateLastAccessed' not in already_processed:
            already_processed.add('dateLastAccessed')
            self.dateLastAccessed = value
        value = find_attr_value_('displayLabel', node)
        if value is not None and 'displayLabel' not in already_processed:
            already_processed.add('displayLabel')
            self.displayLabel = value
        value = find_attr_value_('note', node)
        if value is not None and 'note' not in already_processed:
            already_processed.add('note')
            self.note = value
        value = find_attr_value_('access', node)
        if value is not None and 'access' not in already_processed:
            already_processed.add('access')
            self.access = value
        value = find_attr_value_('usage', node)
        if value is not None and 'usage' not in already_processed:
            already_processed.add('usage')
            self.usage = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class urlDefinition


class nameDefinition(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, displayLabel=None, altRepGroup=None, nameTitleGroup=None, usage='primary', type_='simple', authority=None, authorityURI=None, valueURI=None, href=None, role_attr=None, arcrole=None, title=None, show=None, actuate=None, lang=None, script=None, transliteration=None, namePart=None, displayForm=None, nameIdentifier=None, alternativeName=None, etal=None, affiliation=None, role=None, description=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.displayLabel = _cast(None, displayLabel)
        self.displayLabel_nsprefix_ = None
        self.altRepGroup = _cast(None, altRepGroup)
        self.altRepGroup_nsprefix_ = None
        self.nameTitleGroup = _cast(None, nameTitleGroup)
        self.nameTitleGroup_nsprefix_ = None
        self.usage = _cast(None, usage)
        self.usage_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.authority = _cast(None, authority)
        self.authority_nsprefix_ = None
        self.authorityURI = _cast(None, authorityURI)
        self.authorityURI_nsprefix_ = None
        self.valueURI = _cast(None, valueURI)
        self.valueURI_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.href = _cast(None, href)
        self.href_nsprefix_ = None
        self.role_attr = _cast(None, role_attr)
        self.role_attr_nsprefix_ = None
        self.arcrole = _cast(None, arcrole)
        self.arcrole_nsprefix_ = None
        self.title = _cast(None, title)
        self.title_nsprefix_ = None
        self.show = _cast(None, show)
        self.show_nsprefix_ = None
        self.actuate = _cast(None, actuate)
        self.actuate_nsprefix_ = None
        self.lang = _cast(None, lang)
        self.lang_nsprefix_ = None
        self.lang = _cast(None, lang)
        self.lang_nsprefix_ = None
        self.script = _cast(None, script)
        self.script_nsprefix_ = None
        self.transliteration = _cast(None, transliteration)
        self.transliteration_nsprefix_ = None
        if namePart is None:
            self.namePart = []
        else:
            self.namePart = namePart
        self.namePart_nsprefix_ = None
        if displayForm is None:
            self.displayForm = []
        else:
            self.displayForm = displayForm
        self.displayForm_nsprefix_ = None
        if nameIdentifier is None:
            self.nameIdentifier = []
        else:
            self.nameIdentifier = nameIdentifier
        self.nameIdentifier_nsprefix_ = None
        if alternativeName is None:
            self.alternativeName = []
        else:
            self.alternativeName = alternativeName
        self.alternativeName_nsprefix_ = None
        self.etal = etal
        self.etal_nsprefix_ = None
        if affiliation is None:
            self.affiliation = []
        else:
            self.affiliation = affiliation
        self.affiliation_nsprefix_ = None
        if role is None:
            self.role = []
        else:
            self.role = role
        self.role_nsprefix_ = None
        if description is None:
            self.description = []
        else:
            self.description = description
        self.description_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nameDefinition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nameDefinition.subclass:
            return nameDefinition.subclass(*args_, **kwargs_)
        else:
            return nameDefinition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_namePart(self):
        return self.namePart
    def set_namePart(self, namePart):
        self.namePart = namePart
    def add_namePart(self, value):
        self.namePart.append(value)
    def insert_namePart_at(self, index, value):
        self.namePart.insert(index, value)
    def replace_namePart_at(self, index, value):
        self.namePart[index] = value
    def get_displayForm(self):
        return self.displayForm
    def set_displayForm(self, displayForm):
        self.displayForm = displayForm
    def add_displayForm(self, value):
        self.displayForm.append(value)
    def insert_displayForm_at(self, index, value):
        self.displayForm.insert(index, value)
    def replace_displayForm_at(self, index, value):
        self.displayForm[index] = value
    def get_nameIdentifier(self):
        return self.nameIdentifier
    def set_nameIdentifier(self, nameIdentifier):
        self.nameIdentifier = nameIdentifier
    def add_nameIdentifier(self, value):
        self.nameIdentifier.append(value)
    def insert_nameIdentifier_at(self, index, value):
        self.nameIdentifier.insert(index, value)
    def replace_nameIdentifier_at(self, index, value):
        self.nameIdentifier[index] = value
    def get_alternativeName(self):
        return self.alternativeName
    def set_alternativeName(self, alternativeName):
        self.alternativeName = alternativeName
    def add_alternativeName(self, value):
        self.alternativeName.append(value)
    def insert_alternativeName_at(self, index, value):
        self.alternativeName.insert(index, value)
    def replace_alternativeName_at(self, index, value):
        self.alternativeName[index] = value
    def get_etal(self):
        return self.etal
    def set_etal(self, etal):
        self.etal = etal
    def get_affiliation(self):
        return self.affiliation
    def set_affiliation(self, affiliation):
        self.affiliation = affiliation
    def add_affiliation(self, value):
        self.affiliation.append(value)
    def insert_affiliation_at(self, index, value):
        self.affiliation.insert(index, value)
    def replace_affiliation_at(self, index, value):
        self.affiliation[index] = value
    def get_role(self):
        return self.role
    def set_role(self, role):
        self.role = role
    def add_role(self, value):
        self.role.append(value)
    def insert_role_at(self, index, value):
        self.role.insert(index, value)
    def replace_role_at(self, index, value):
        self.role[index] = value
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def add_description(self, value):
        self.description.append(value)
    def insert_description_at(self, index, value):
        self.description.insert(index, value)
    def replace_description_at(self, index, value):
        self.description[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_displayLabel(self):
        return self.displayLabel
    def set_displayLabel(self, displayLabel):
        self.displayLabel = displayLabel
    def get_altRepGroup(self):
        return self.altRepGroup
    def set_altRepGroup(self, altRepGroup):
        self.altRepGroup = altRepGroup
    def get_nameTitleGroup(self):
        return self.nameTitleGroup
    def set_nameTitleGroup(self, nameTitleGroup):
        self.nameTitleGroup = nameTitleGroup
    def get_usage(self):
        return self.usage
    def set_usage(self, usage):
        self.usage = usage
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_authority(self):
        return self.authority
    def set_authority(self, authority):
        self.authority = authority
    def get_authorityURI(self):
        return self.authorityURI
    def set_authorityURI(self, authorityURI):
        self.authorityURI = authorityURI
    def get_valueURI(self):
        return self.valueURI
    def set_valueURI(self, valueURI):
        self.valueURI = valueURI
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_href(self):
        return self.href
    def set_href(self, href):
        self.href = href
    def get_role_attr(self):
        return self.role_attr
    def set_role_attr(self, role_attr):
        self.role_attr = role_attr
    def get_arcrole(self):
        return self.arcrole
    def set_arcrole(self, arcrole):
        self.arcrole = arcrole
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def get_show(self):
        return self.show
    def set_show(self, show):
        self.show = show
    def get_actuate(self):
        return self.actuate
    def set_actuate(self, actuate):
        self.actuate = actuate
    def get_lang(self):
        return self.lang
    def set_lang(self, lang):
        self.lang = lang
    def get_lang(self):
        return self.lang
    def set_lang(self, lang):
        self.lang = lang
    def get_script(self):
        return self.script
    def set_script(self, script):
        self.script = script
    def get_transliteration(self):
        return self.transliteration
    def set_transliteration(self, transliteration):
        self.transliteration = transliteration
    def hasContent_(self):
        if (
            self.namePart or
            self.displayForm or
            self.nameIdentifier or
            self.alternativeName or
            self.etal is not None or
            self.affiliation or
            self.role or
            self.description
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='nameDefinition', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('nameDefinition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='nameDefinition')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='nameDefinition', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='nameDefinition'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.displayLabel is not None and 'displayLabel' not in already_processed:
            already_processed.add('displayLabel')
            outfile.write(' displayLabel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.displayLabel), input_name='displayLabel')), ))
        if self.altRepGroup is not None and 'altRepGroup' not in already_processed:
            already_processed.add('altRepGroup')
            outfile.write(' altRepGroup=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.altRepGroup), input_name='altRepGroup')), ))
        if self.nameTitleGroup is not None and 'nameTitleGroup' not in already_processed:
            already_processed.add('nameTitleGroup')
            outfile.write(' nameTitleGroup=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.nameTitleGroup), input_name='nameTitleGroup')), ))
        if self.usage != "primary" and 'usage' not in already_processed:
            already_processed.add('usage')
            outfile.write(' usage=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.usage), input_name='usage')), ))
        if self.type_ != "simple" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.authority is not None and 'authority' not in already_processed:
            already_processed.add('authority')
            outfile.write(' authority=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.authority), input_name='authority')), ))
        if self.authorityURI is not None and 'authorityURI' not in already_processed:
            already_processed.add('authorityURI')
            outfile.write(' authorityURI=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.authorityURI), input_name='authorityURI')), ))
        if self.valueURI is not None and 'valueURI' not in already_processed:
            already_processed.add('valueURI')
            outfile.write(' valueURI=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.valueURI), input_name='valueURI')), ))
        if self.type_ != "simple" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (quote_attrib(self.href), ))
        if self.role_attr is not None and 'role_attr' not in already_processed:
            already_processed.add('role_attr')
            outfile.write(' role=%s' % (quote_attrib(self.role_attr), ))
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            outfile.write(' arcrole=%s' % (quote_attrib(self.arcrole), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.add('title')
            outfile.write(' title=%s' % (quote_attrib(self.title), ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.add('show')
            outfile.write(' show=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.show), input_name='show')), ))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            outfile.write(' actuate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.actuate), input_name='actuate')), ))
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lang), input_name='lang')), ))
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lang), input_name='lang')), ))
        if self.script is not None and 'script' not in already_processed:
            already_processed.add('script')
            outfile.write(' script=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.script), input_name='script')), ))
        if self.transliteration is not None and 'transliteration' not in already_processed:
            already_processed.add('transliteration')
            outfile.write(' transliteration=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.transliteration), input_name='transliteration')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='nameDefinition', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for namePart_ in self.namePart:
            namespaceprefix_ = self.namePart_nsprefix_ + ':' if (UseCapturedNS_ and self.namePart_nsprefix_) else ''
            namePart_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='namePart', pretty_print=pretty_print)
        for displayForm_ in self.displayForm:
            namespaceprefix_ = self.displayForm_nsprefix_ + ':' if (UseCapturedNS_ and self.displayForm_nsprefix_) else ''
            displayForm_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='displayForm', pretty_print=pretty_print)
        for nameIdentifier_ in self.nameIdentifier:
            namespaceprefix_ = self.nameIdentifier_nsprefix_ + ':' if (UseCapturedNS_ and self.nameIdentifier_nsprefix_) else ''
            nameIdentifier_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='nameIdentifier', pretty_print=pretty_print)
        for alternativeName_ in self.alternativeName:
            namespaceprefix_ = self.alternativeName_nsprefix_ + ':' if (UseCapturedNS_ and self.alternativeName_nsprefix_) else ''
            alternativeName_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='alternativeName', pretty_print=pretty_print)
        if self.etal is not None:
            namespaceprefix_ = self.etal_nsprefix_ + ':' if (UseCapturedNS_ and self.etal_nsprefix_) else ''
            self.etal.export(outfile, level, namespaceprefix_, namespacedef_='', name_='etal', pretty_print=pretty_print)
        for affiliation_ in self.affiliation:
            namespaceprefix_ = self.affiliation_nsprefix_ + ':' if (UseCapturedNS_ and self.affiliation_nsprefix_) else ''
            affiliation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='affiliation', pretty_print=pretty_print)
        for role_ in self.role:
            namespaceprefix_ = self.role_nsprefix_ + ':' if (UseCapturedNS_ and self.role_nsprefix_) else ''
            role_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='role', pretty_print=pretty_print)
        for description_ in self.description:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            description_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='description', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('displayLabel', node)
        if value is not None and 'displayLabel' not in already_processed:
            already_processed.add('displayLabel')
            self.displayLabel = value
        value = find_attr_value_('altRepGroup', node)
        if value is not None and 'altRepGroup' not in already_processed:
            already_processed.add('altRepGroup')
            self.altRepGroup = value
        value = find_attr_value_('nameTitleGroup', node)
        if value is not None and 'nameTitleGroup' not in already_processed:
            already_processed.add('nameTitleGroup')
            self.nameTitleGroup = value
        value = find_attr_value_('usage', node)
        if value is not None and 'usage' not in already_processed:
            already_processed.add('usage')
            self.usage = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('authority', node)
        if value is not None and 'authority' not in already_processed:
            already_processed.add('authority')
            self.authority = value
        value = find_attr_value_('authorityURI', node)
        if value is not None and 'authorityURI' not in already_processed:
            already_processed.add('authorityURI')
            self.authorityURI = value
        value = find_attr_value_('valueURI', node)
        if value is not None and 'valueURI' not in already_processed:
            already_processed.add('valueURI')
            self.valueURI = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('role', node)
        if value is not None and 'role_attr' not in already_processed:
            already_processed.add('role_attr')
            self.role_attr = value
        value = find_attr_value_('arcrole', node)
        if value is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            self.arcrole = value
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.add('title')
            self.title = value
        value = find_attr_value_('show', node)
        if value is not None and 'show' not in already_processed:
            already_processed.add('show')
            self.show = value
        value = find_attr_value_('actuate', node)
        if value is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            self.actuate = value
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        value = find_attr_value_('script', node)
        if value is not None and 'script' not in already_processed:
            already_processed.add('script')
            self.script = value
        value = find_attr_value_('transliteration', node)
        if value is not None and 'transliteration' not in already_processed:
            already_processed.add('transliteration')
            self.transliteration = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'namePart':
            obj_ = namePartDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.namePart.append(obj_)
            obj_.original_tagname_ = 'namePart'
        elif nodeName_ == 'displayForm':
            class_obj_ = self.get_class_obj_(child_, stringPlusLanguage)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.displayForm.append(obj_)
            obj_.original_tagname_ = 'displayForm'
        elif nodeName_ == 'nameIdentifier':
            obj_ = identifierDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.nameIdentifier.append(obj_)
            obj_.original_tagname_ = 'nameIdentifier'
        elif nodeName_ == 'alternativeName':
            obj_ = alternativeNameDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.alternativeName.append(obj_)
            obj_.original_tagname_ = 'alternativeName'
        elif nodeName_ == 'etal':
            class_obj_ = self.get_class_obj_(child_, stringPlusLanguage)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.etal = obj_
            obj_.original_tagname_ = 'etal'
        elif nodeName_ == 'affiliation':
            class_obj_ = self.get_class_obj_(child_, stringPlusLanguage)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.affiliation.append(obj_)
            obj_.original_tagname_ = 'affiliation'
        elif nodeName_ == 'role':
            obj_ = roleDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.role.append(obj_)
            obj_.original_tagname_ = 'role'
        elif nodeName_ == 'description':
            class_obj_ = self.get_class_obj_(child_, stringPlusLanguage)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.description.append(obj_)
            obj_.original_tagname_ = 'description'
# end class nameDefinition


class roleDefinition(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, roleTerm=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if roleTerm is None:
            self.roleTerm = []
        else:
            self.roleTerm = roleTerm
        self.roleTerm_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, roleDefinition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if roleDefinition.subclass:
            return roleDefinition.subclass(*args_, **kwargs_)
        else:
            return roleDefinition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_roleTerm(self):
        return self.roleTerm
    def set_roleTerm(self, roleTerm):
        self.roleTerm = roleTerm
    def add_roleTerm(self, value):
        self.roleTerm.append(value)
    def insert_roleTerm_at(self, index, value):
        self.roleTerm.insert(index, value)
    def replace_roleTerm_at(self, index, value):
        self.roleTerm[index] = value
    def hasContent_(self):
        if (
            self.roleTerm
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='roleDefinition', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('roleDefinition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='roleDefinition')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='roleDefinition', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='roleDefinition'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='roleDefinition', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for roleTerm_ in self.roleTerm:
            namespaceprefix_ = self.roleTerm_nsprefix_ + ':' if (UseCapturedNS_ and self.roleTerm_nsprefix_) else ''
            roleTerm_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='roleTerm', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'roleTerm':
            obj_ = roleTermDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.roleTerm.append(obj_)
            obj_.original_tagname_ = 'roleTerm'
# end class roleDefinition


class alternativeNameDefinition(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, displayLabel=None, altType=None, type_='simple', href=None, role_attr=None, arcrole=None, title=None, show=None, actuate=None, lang=None, script=None, transliteration=None, namePart=None, displayForm=None, affiliation=None, role=None, description=None, nameIdentifier=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.displayLabel = _cast(None, displayLabel)
        self.displayLabel_nsprefix_ = None
        self.altType = _cast(None, altType)
        self.altType_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.href = _cast(None, href)
        self.href_nsprefix_ = None
        self.role_attr = _cast(None, role_attr)
        self.role_attr_nsprefix_ = None
        self.arcrole = _cast(None, arcrole)
        self.arcrole_nsprefix_ = None
        self.title = _cast(None, title)
        self.title_nsprefix_ = None
        self.show = _cast(None, show)
        self.show_nsprefix_ = None
        self.actuate = _cast(None, actuate)
        self.actuate_nsprefix_ = None
        self.lang = _cast(None, lang)
        self.lang_nsprefix_ = None
        self.lang = _cast(None, lang)
        self.lang_nsprefix_ = None
        self.script = _cast(None, script)
        self.script_nsprefix_ = None
        self.transliteration = _cast(None, transliteration)
        self.transliteration_nsprefix_ = None
        if namePart is None:
            self.namePart = []
        else:
            self.namePart = namePart
        self.namePart_nsprefix_ = None
        if displayForm is None:
            self.displayForm = []
        else:
            self.displayForm = displayForm
        self.displayForm_nsprefix_ = None
        if affiliation is None:
            self.affiliation = []
        else:
            self.affiliation = affiliation
        self.affiliation_nsprefix_ = None
        if role is None:
            self.role = []
        else:
            self.role = role
        self.role_nsprefix_ = None
        if description is None:
            self.description = []
        else:
            self.description = description
        self.description_nsprefix_ = None
        if nameIdentifier is None:
            self.nameIdentifier = []
        else:
            self.nameIdentifier = nameIdentifier
        self.nameIdentifier_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, alternativeNameDefinition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if alternativeNameDefinition.subclass:
            return alternativeNameDefinition.subclass(*args_, **kwargs_)
        else:
            return alternativeNameDefinition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_namePart(self):
        return self.namePart
    def set_namePart(self, namePart):
        self.namePart = namePart
    def add_namePart(self, value):
        self.namePart.append(value)
    def insert_namePart_at(self, index, value):
        self.namePart.insert(index, value)
    def replace_namePart_at(self, index, value):
        self.namePart[index] = value
    def get_displayForm(self):
        return self.displayForm
    def set_displayForm(self, displayForm):
        self.displayForm = displayForm
    def add_displayForm(self, value):
        self.displayForm.append(value)
    def insert_displayForm_at(self, index, value):
        self.displayForm.insert(index, value)
    def replace_displayForm_at(self, index, value):
        self.displayForm[index] = value
    def get_affiliation(self):
        return self.affiliation
    def set_affiliation(self, affiliation):
        self.affiliation = affiliation
    def add_affiliation(self, value):
        self.affiliation.append(value)
    def insert_affiliation_at(self, index, value):
        self.affiliation.insert(index, value)
    def replace_affiliation_at(self, index, value):
        self.affiliation[index] = value
    def get_role(self):
        return self.role
    def set_role(self, role):
        self.role = role
    def add_role(self, value):
        self.role.append(value)
    def insert_role_at(self, index, value):
        self.role.insert(index, value)
    def replace_role_at(self, index, value):
        self.role[index] = value
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def add_description(self, value):
        self.description.append(value)
    def insert_description_at(self, index, value):
        self.description.insert(index, value)
    def replace_description_at(self, index, value):
        self.description[index] = value
    def get_nameIdentifier(self):
        return self.nameIdentifier
    def set_nameIdentifier(self, nameIdentifier):
        self.nameIdentifier = nameIdentifier
    def add_nameIdentifier(self, value):
        self.nameIdentifier.append(value)
    def insert_nameIdentifier_at(self, index, value):
        self.nameIdentifier.insert(index, value)
    def replace_nameIdentifier_at(self, index, value):
        self.nameIdentifier[index] = value
    def get_displayLabel(self):
        return self.displayLabel
    def set_displayLabel(self, displayLabel):
        self.displayLabel = displayLabel
    def get_altType(self):
        return self.altType
    def set_altType(self, altType):
        self.altType = altType
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_href(self):
        return self.href
    def set_href(self, href):
        self.href = href
    def get_role_attr(self):
        return self.role_attr
    def set_role_attr(self, role_attr):
        self.role_attr = role_attr
    def get_arcrole(self):
        return self.arcrole
    def set_arcrole(self, arcrole):
        self.arcrole = arcrole
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def get_show(self):
        return self.show
    def set_show(self, show):
        self.show = show
    def get_actuate(self):
        return self.actuate
    def set_actuate(self, actuate):
        self.actuate = actuate
    def get_lang(self):
        return self.lang
    def set_lang(self, lang):
        self.lang = lang
    def get_lang(self):
        return self.lang
    def set_lang(self, lang):
        self.lang = lang
    def get_script(self):
        return self.script
    def set_script(self, script):
        self.script = script
    def get_transliteration(self):
        return self.transliteration
    def set_transliteration(self, transliteration):
        self.transliteration = transliteration
    def hasContent_(self):
        if (
            self.namePart or
            self.displayForm or
            self.affiliation or
            self.role or
            self.description or
            self.nameIdentifier
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='alternativeNameDefinition', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('alternativeNameDefinition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='alternativeNameDefinition')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='alternativeNameDefinition', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='alternativeNameDefinition'):
        if self.displayLabel is not None and 'displayLabel' not in already_processed:
            already_processed.add('displayLabel')
            outfile.write(' displayLabel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.displayLabel), input_name='displayLabel')), ))
        if self.altType is not None and 'altType' not in already_processed:
            already_processed.add('altType')
            outfile.write(' altType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.altType), input_name='altType')), ))
        if self.type_ != "simple" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (quote_attrib(self.href), ))
        if self.role_attr is not None and 'role_attr' not in already_processed:
            already_processed.add('role_attr')
            outfile.write(' role=%s' % (quote_attrib(self.role_attr), ))
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            outfile.write(' arcrole=%s' % (quote_attrib(self.arcrole), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.add('title')
            outfile.write(' title=%s' % (quote_attrib(self.title), ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.add('show')
            outfile.write(' show=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.show), input_name='show')), ))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            outfile.write(' actuate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.actuate), input_name='actuate')), ))
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lang), input_name='lang')), ))
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lang), input_name='lang')), ))
        if self.script is not None and 'script' not in already_processed:
            already_processed.add('script')
            outfile.write(' script=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.script), input_name='script')), ))
        if self.transliteration is not None and 'transliteration' not in already_processed:
            already_processed.add('transliteration')
            outfile.write(' transliteration=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.transliteration), input_name='transliteration')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='alternativeNameDefinition', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for namePart_ in self.namePart:
            namespaceprefix_ = self.namePart_nsprefix_ + ':' if (UseCapturedNS_ and self.namePart_nsprefix_) else ''
            namePart_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='namePart', pretty_print=pretty_print)
        for displayForm_ in self.displayForm:
            namespaceprefix_ = self.displayForm_nsprefix_ + ':' if (UseCapturedNS_ and self.displayForm_nsprefix_) else ''
            displayForm_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='displayForm', pretty_print=pretty_print)
        for affiliation_ in self.affiliation:
            namespaceprefix_ = self.affiliation_nsprefix_ + ':' if (UseCapturedNS_ and self.affiliation_nsprefix_) else ''
            affiliation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='affiliation', pretty_print=pretty_print)
        for role_ in self.role:
            namespaceprefix_ = self.role_nsprefix_ + ':' if (UseCapturedNS_ and self.role_nsprefix_) else ''
            role_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='role', pretty_print=pretty_print)
        for description_ in self.description:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            description_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='description', pretty_print=pretty_print)
        for nameIdentifier_ in self.nameIdentifier:
            namespaceprefix_ = self.nameIdentifier_nsprefix_ + ':' if (UseCapturedNS_ and self.nameIdentifier_nsprefix_) else ''
            nameIdentifier_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='nameIdentifier', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('displayLabel', node)
        if value is not None and 'displayLabel' not in already_processed:
            already_processed.add('displayLabel')
            self.displayLabel = value
        value = find_attr_value_('altType', node)
        if value is not None and 'altType' not in already_processed:
            already_processed.add('altType')
            self.altType = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('role', node)
        if value is not None and 'role_attr' not in already_processed:
            already_processed.add('role_attr')
            self.role_attr = value
        value = find_attr_value_('arcrole', node)
        if value is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            self.arcrole = value
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.add('title')
            self.title = value
        value = find_attr_value_('show', node)
        if value is not None and 'show' not in already_processed:
            already_processed.add('show')
            self.show = value
        value = find_attr_value_('actuate', node)
        if value is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            self.actuate = value
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        value = find_attr_value_('script', node)
        if value is not None and 'script' not in already_processed:
            already_processed.add('script')
            self.script = value
        value = find_attr_value_('transliteration', node)
        if value is not None and 'transliteration' not in already_processed:
            already_processed.add('transliteration')
            self.transliteration = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'namePart':
            obj_ = namePartDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.namePart.append(obj_)
            obj_.original_tagname_ = 'namePart'
        elif nodeName_ == 'displayForm':
            class_obj_ = self.get_class_obj_(child_, stringPlusLanguage)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.displayForm.append(obj_)
            obj_.original_tagname_ = 'displayForm'
        elif nodeName_ == 'affiliation':
            class_obj_ = self.get_class_obj_(child_, stringPlusLanguage)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.affiliation.append(obj_)
            obj_.original_tagname_ = 'affiliation'
        elif nodeName_ == 'role':
            obj_ = roleDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.role.append(obj_)
            obj_.original_tagname_ = 'role'
        elif nodeName_ == 'description':
            class_obj_ = self.get_class_obj_(child_, stringPlusLanguage)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.description.append(obj_)
            obj_.original_tagname_ = 'description'
        elif nodeName_ == 'nameIdentifier':
            obj_ = identifierDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.nameIdentifier.append(obj_)
            obj_.original_tagname_ = 'nameIdentifier'
# end class alternativeNameDefinition


class originInfoDefinition(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, displayLabel=None, altRepGroup=None, eventType=None, lang=None, script=None, transliteration=None, place=None, publisher=None, dateIssued=None, dateCreated=None, dateCaptured=None, dateValid=None, dateModified=None, copyrightDate=None, dateOther=None, edition=None, issuance=None, frequency=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.displayLabel = _cast(None, displayLabel)
        self.displayLabel_nsprefix_ = None
        self.altRepGroup = _cast(None, altRepGroup)
        self.altRepGroup_nsprefix_ = None
        self.eventType = _cast(None, eventType)
        self.eventType_nsprefix_ = None
        self.lang = _cast(None, lang)
        self.lang_nsprefix_ = None
        self.lang = _cast(None, lang)
        self.lang_nsprefix_ = None
        self.script = _cast(None, script)
        self.script_nsprefix_ = None
        self.transliteration = _cast(None, transliteration)
        self.transliteration_nsprefix_ = None
        if place is None:
            self.place = []
        else:
            self.place = place
        self.place_nsprefix_ = None
        if publisher is None:
            self.publisher = []
        else:
            self.publisher = publisher
        self.publisher_nsprefix_ = None
        if dateIssued is None:
            self.dateIssued = []
        else:
            self.dateIssued = dateIssued
        self.dateIssued_nsprefix_ = None
        if dateCreated is None:
            self.dateCreated = []
        else:
            self.dateCreated = dateCreated
        self.dateCreated_nsprefix_ = None
        if dateCaptured is None:
            self.dateCaptured = []
        else:
            self.dateCaptured = dateCaptured
        self.dateCaptured_nsprefix_ = None
        if dateValid is None:
            self.dateValid = []
        else:
            self.dateValid = dateValid
        self.dateValid_nsprefix_ = None
        if dateModified is None:
            self.dateModified = []
        else:
            self.dateModified = dateModified
        self.dateModified_nsprefix_ = None
        if copyrightDate is None:
            self.copyrightDate = []
        else:
            self.copyrightDate = copyrightDate
        self.copyrightDate_nsprefix_ = None
        if dateOther is None:
            self.dateOther = []
        else:
            self.dateOther = dateOther
        self.dateOther_nsprefix_ = None
        if edition is None:
            self.edition = []
        else:
            self.edition = edition
        self.edition_nsprefix_ = None
        if issuance is None:
            self.issuance = []
        else:
            self.issuance = issuance
        self.issuance_nsprefix_ = None
        if frequency is None:
            self.frequency = []
        else:
            self.frequency = frequency
        self.frequency_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, originInfoDefinition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if originInfoDefinition.subclass:
            return originInfoDefinition.subclass(*args_, **kwargs_)
        else:
            return originInfoDefinition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_place(self):
        return self.place
    def set_place(self, place):
        self.place = place
    def add_place(self, value):
        self.place.append(value)
    def insert_place_at(self, index, value):
        self.place.insert(index, value)
    def replace_place_at(self, index, value):
        self.place[index] = value
    def get_publisher(self):
        return self.publisher
    def set_publisher(self, publisher):
        self.publisher = publisher
    def add_publisher(self, value):
        self.publisher.append(value)
    def insert_publisher_at(self, index, value):
        self.publisher.insert(index, value)
    def replace_publisher_at(self, index, value):
        self.publisher[index] = value
    def get_dateIssued(self):
        return self.dateIssued
    def set_dateIssued(self, dateIssued):
        self.dateIssued = dateIssued
    def add_dateIssued(self, value):
        self.dateIssued.append(value)
    def insert_dateIssued_at(self, index, value):
        self.dateIssued.insert(index, value)
    def replace_dateIssued_at(self, index, value):
        self.dateIssued[index] = value
    def get_dateCreated(self):
        return self.dateCreated
    def set_dateCreated(self, dateCreated):
        self.dateCreated = dateCreated
    def add_dateCreated(self, value):
        self.dateCreated.append(value)
    def insert_dateCreated_at(self, index, value):
        self.dateCreated.insert(index, value)
    def replace_dateCreated_at(self, index, value):
        self.dateCreated[index] = value
    def get_dateCaptured(self):
        return self.dateCaptured
    def set_dateCaptured(self, dateCaptured):
        self.dateCaptured = dateCaptured
    def add_dateCaptured(self, value):
        self.dateCaptured.append(value)
    def insert_dateCaptured_at(self, index, value):
        self.dateCaptured.insert(index, value)
    def replace_dateCaptured_at(self, index, value):
        self.dateCaptured[index] = value
    def get_dateValid(self):
        return self.dateValid
    def set_dateValid(self, dateValid):
        self.dateValid = dateValid
    def add_dateValid(self, value):
        self.dateValid.append(value)
    def insert_dateValid_at(self, index, value):
        self.dateValid.insert(index, value)
    def replace_dateValid_at(self, index, value):
        self.dateValid[index] = value
    def get_dateModified(self):
        return self.dateModified
    def set_dateModified(self, dateModified):
        self.dateModified = dateModified
    def add_dateModified(self, value):
        self.dateModified.append(value)
    def insert_dateModified_at(self, index, value):
        self.dateModified.insert(index, value)
    def replace_dateModified_at(self, index, value):
        self.dateModified[index] = value
    def get_copyrightDate(self):
        return self.copyrightDate
    def set_copyrightDate(self, copyrightDate):
        self.copyrightDate = copyrightDate
    def add_copyrightDate(self, value):
        self.copyrightDate.append(value)
    def insert_copyrightDate_at(self, index, value):
        self.copyrightDate.insert(index, value)
    def replace_copyrightDate_at(self, index, value):
        self.copyrightDate[index] = value
    def get_dateOther(self):
        return self.dateOther
    def set_dateOther(self, dateOther):
        self.dateOther = dateOther
    def add_dateOther(self, value):
        self.dateOther.append(value)
    def insert_dateOther_at(self, index, value):
        self.dateOther.insert(index, value)
    def replace_dateOther_at(self, index, value):
        self.dateOther[index] = value
    def get_edition(self):
        return self.edition
    def set_edition(self, edition):
        self.edition = edition
    def add_edition(self, value):
        self.edition.append(value)
    def insert_edition_at(self, index, value):
        self.edition.insert(index, value)
    def replace_edition_at(self, index, value):
        self.edition[index] = value
    def get_issuance(self):
        return self.issuance
    def set_issuance(self, issuance):
        self.issuance = issuance
    def add_issuance(self, value):
        self.issuance.append(value)
    def insert_issuance_at(self, index, value):
        self.issuance.insert(index, value)
    def replace_issuance_at(self, index, value):
        self.issuance[index] = value
    def get_frequency(self):
        return self.frequency
    def set_frequency(self, frequency):
        self.frequency = frequency
    def add_frequency(self, value):
        self.frequency.append(value)
    def insert_frequency_at(self, index, value):
        self.frequency.insert(index, value)
    def replace_frequency_at(self, index, value):
        self.frequency[index] = value
    def get_displayLabel(self):
        return self.displayLabel
    def set_displayLabel(self, displayLabel):
        self.displayLabel = displayLabel
    def get_altRepGroup(self):
        return self.altRepGroup
    def set_altRepGroup(self, altRepGroup):
        self.altRepGroup = altRepGroup
    def get_eventType(self):
        return self.eventType
    def set_eventType(self, eventType):
        self.eventType = eventType
    def get_lang(self):
        return self.lang
    def set_lang(self, lang):
        self.lang = lang
    def get_lang(self):
        return self.lang
    def set_lang(self, lang):
        self.lang = lang
    def get_script(self):
        return self.script
    def set_script(self, script):
        self.script = script
    def get_transliteration(self):
        return self.transliteration
    def set_transliteration(self, transliteration):
        self.transliteration = transliteration
    def hasContent_(self):
        if (
            self.place or
            self.publisher or
            self.dateIssued or
            self.dateCreated or
            self.dateCaptured or
            self.dateValid or
            self.dateModified or
            self.copyrightDate or
            self.dateOther or
            self.edition or
            self.issuance or
            self.frequency
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='originInfoDefinition', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('originInfoDefinition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='originInfoDefinition')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='originInfoDefinition', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='originInfoDefinition'):
        if self.displayLabel is not None and 'displayLabel' not in already_processed:
            already_processed.add('displayLabel')
            outfile.write(' displayLabel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.displayLabel), input_name='displayLabel')), ))
        if self.altRepGroup is not None and 'altRepGroup' not in already_processed:
            already_processed.add('altRepGroup')
            outfile.write(' altRepGroup=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.altRepGroup), input_name='altRepGroup')), ))
        if self.eventType is not None and 'eventType' not in already_processed:
            already_processed.add('eventType')
            outfile.write(' eventType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.eventType), input_name='eventType')), ))
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lang), input_name='lang')), ))
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lang), input_name='lang')), ))
        if self.script is not None and 'script' not in already_processed:
            already_processed.add('script')
            outfile.write(' script=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.script), input_name='script')), ))
        if self.transliteration is not None and 'transliteration' not in already_processed:
            already_processed.add('transliteration')
            outfile.write(' transliteration=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.transliteration), input_name='transliteration')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='originInfoDefinition', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for place_ in self.place:
            namespaceprefix_ = self.place_nsprefix_ + ':' if (UseCapturedNS_ and self.place_nsprefix_) else ''
            place_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='place', pretty_print=pretty_print)
        for publisher_ in self.publisher:
            namespaceprefix_ = self.publisher_nsprefix_ + ':' if (UseCapturedNS_ and self.publisher_nsprefix_) else ''
            publisher_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='publisher', pretty_print=pretty_print)
        for dateIssued_ in self.dateIssued:
            namespaceprefix_ = self.dateIssued_nsprefix_ + ':' if (UseCapturedNS_ and self.dateIssued_nsprefix_) else ''
            dateIssued_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dateIssued', pretty_print=pretty_print)
        for dateCreated_ in self.dateCreated:
            namespaceprefix_ = self.dateCreated_nsprefix_ + ':' if (UseCapturedNS_ and self.dateCreated_nsprefix_) else ''
            dateCreated_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dateCreated', pretty_print=pretty_print)
        for dateCaptured_ in self.dateCaptured:
            namespaceprefix_ = self.dateCaptured_nsprefix_ + ':' if (UseCapturedNS_ and self.dateCaptured_nsprefix_) else ''
            dateCaptured_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dateCaptured', pretty_print=pretty_print)
        for dateValid_ in self.dateValid:
            namespaceprefix_ = self.dateValid_nsprefix_ + ':' if (UseCapturedNS_ and self.dateValid_nsprefix_) else ''
            dateValid_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dateValid', pretty_print=pretty_print)
        for dateModified_ in self.dateModified:
            namespaceprefix_ = self.dateModified_nsprefix_ + ':' if (UseCapturedNS_ and self.dateModified_nsprefix_) else ''
            dateModified_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dateModified', pretty_print=pretty_print)
        for copyrightDate_ in self.copyrightDate:
            namespaceprefix_ = self.copyrightDate_nsprefix_ + ':' if (UseCapturedNS_ and self.copyrightDate_nsprefix_) else ''
            copyrightDate_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='copyrightDate', pretty_print=pretty_print)
        for dateOther_ in self.dateOther:
            namespaceprefix_ = self.dateOther_nsprefix_ + ':' if (UseCapturedNS_ and self.dateOther_nsprefix_) else ''
            dateOther_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dateOther', pretty_print=pretty_print)
        for edition_ in self.edition:
            namespaceprefix_ = self.edition_nsprefix_ + ':' if (UseCapturedNS_ and self.edition_nsprefix_) else ''
            edition_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='edition', pretty_print=pretty_print)
        for issuance_ in self.issuance:
            namespaceprefix_ = self.issuance_nsprefix_ + ':' if (UseCapturedNS_ and self.issuance_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sissuance>%s</%sissuance>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(issuance_), input_name='issuance')), namespaceprefix_ , eol_))
        for frequency_ in self.frequency:
            namespaceprefix_ = self.frequency_nsprefix_ + ':' if (UseCapturedNS_ and self.frequency_nsprefix_) else ''
            frequency_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='frequency', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('displayLabel', node)
        if value is not None and 'displayLabel' not in already_processed:
            already_processed.add('displayLabel')
            self.displayLabel = value
        value = find_attr_value_('altRepGroup', node)
        if value is not None and 'altRepGroup' not in already_processed:
            already_processed.add('altRepGroup')
            self.altRepGroup = value
        value = find_attr_value_('eventType', node)
        if value is not None and 'eventType' not in already_processed:
            already_processed.add('eventType')
            self.eventType = value
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        value = find_attr_value_('script', node)
        if value is not None and 'script' not in already_processed:
            already_processed.add('script')
            self.script = value
        value = find_attr_value_('transliteration', node)
        if value is not None and 'transliteration' not in already_processed:
            already_processed.add('transliteration')
            self.transliteration = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'place':
            obj_ = placeDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.place.append(obj_)
            obj_.original_tagname_ = 'place'
        elif nodeName_ == 'publisher':
            obj_ = publisherDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.publisher.append(obj_)
            obj_.original_tagname_ = 'publisher'
        elif nodeName_ == 'dateIssued':
            class_obj_ = self.get_class_obj_(child_, dateDefinition)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dateIssued.append(obj_)
            obj_.original_tagname_ = 'dateIssued'
        elif nodeName_ == 'dateCreated':
            class_obj_ = self.get_class_obj_(child_, dateDefinition)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dateCreated.append(obj_)
            obj_.original_tagname_ = 'dateCreated'
        elif nodeName_ == 'dateCaptured':
            class_obj_ = self.get_class_obj_(child_, dateDefinition)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dateCaptured.append(obj_)
            obj_.original_tagname_ = 'dateCaptured'
        elif nodeName_ == 'dateValid':
            class_obj_ = self.get_class_obj_(child_, dateDefinition)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dateValid.append(obj_)
            obj_.original_tagname_ = 'dateValid'
        elif nodeName_ == 'dateModified':
            class_obj_ = self.get_class_obj_(child_, dateDefinition)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dateModified.append(obj_)
            obj_.original_tagname_ = 'dateModified'
        elif nodeName_ == 'copyrightDate':
            class_obj_ = self.get_class_obj_(child_, dateDefinition)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.copyrightDate.append(obj_)
            obj_.original_tagname_ = 'copyrightDate'
        elif nodeName_ == 'dateOther':
            obj_ = dateOtherDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dateOther.append(obj_)
            obj_.original_tagname_ = 'dateOther'
        elif nodeName_ == 'edition':
            class_obj_ = self.get_class_obj_(child_, stringPlusLanguagePlusSupplied)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.edition.append(obj_)
            obj_.original_tagname_ = 'edition'
        elif nodeName_ == 'issuance':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'issuance')
            value_ = self.gds_validate_string(value_, node, 'issuance')
            self.issuance.append(value_)
            self.issuance_nsprefix_ = child_.prefix
        elif nodeName_ == 'frequency':
            class_obj_ = self.get_class_obj_(child_, stringPlusLanguagePlusAuthority)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.frequency.append(obj_)
            obj_.original_tagname_ = 'frequency'
# end class originInfoDefinition


class placeDefinition(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, supplied='yes', placeTerm=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.supplied = _cast(None, supplied)
        self.supplied_nsprefix_ = None
        if placeTerm is None:
            self.placeTerm = []
        else:
            self.placeTerm = placeTerm
        self.placeTerm_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, placeDefinition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if placeDefinition.subclass:
            return placeDefinition.subclass(*args_, **kwargs_)
        else:
            return placeDefinition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_placeTerm(self):
        return self.placeTerm
    def set_placeTerm(self, placeTerm):
        self.placeTerm = placeTerm
    def add_placeTerm(self, value):
        self.placeTerm.append(value)
    def insert_placeTerm_at(self, index, value):
        self.placeTerm.insert(index, value)
    def replace_placeTerm_at(self, index, value):
        self.placeTerm[index] = value
    def get_supplied(self):
        return self.supplied
    def set_supplied(self, supplied):
        self.supplied = supplied
    def hasContent_(self):
        if (
            self.placeTerm
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='placeDefinition', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('placeDefinition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='placeDefinition')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='placeDefinition', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='placeDefinition'):
        if self.supplied != "yes" and 'supplied' not in already_processed:
            already_processed.add('supplied')
            outfile.write(' supplied=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.supplied), input_name='supplied')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='placeDefinition', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for placeTerm_ in self.placeTerm:
            namespaceprefix_ = self.placeTerm_nsprefix_ + ':' if (UseCapturedNS_ and self.placeTerm_nsprefix_) else ''
            placeTerm_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='placeTerm', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('supplied', node)
        if value is not None and 'supplied' not in already_processed:
            already_processed.add('supplied')
            self.supplied = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'placeTerm':
            obj_ = placeTermDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.placeTerm.append(obj_)
            obj_.original_tagname_ = 'placeTerm'
# end class placeDefinition


class partDefinition(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, type_=None, order=None, displayLabel=None, altRepGroup=None, lang=None, script=None, transliteration=None, detail=None, extent=None, date=None, text=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.order = _cast(int, order)
        self.order_nsprefix_ = None
        self.displayLabel = _cast(None, displayLabel)
        self.displayLabel_nsprefix_ = None
        self.altRepGroup = _cast(None, altRepGroup)
        self.altRepGroup_nsprefix_ = None
        self.lang = _cast(None, lang)
        self.lang_nsprefix_ = None
        self.lang = _cast(None, lang)
        self.lang_nsprefix_ = None
        self.script = _cast(None, script)
        self.script_nsprefix_ = None
        self.transliteration = _cast(None, transliteration)
        self.transliteration_nsprefix_ = None
        if detail is None:
            self.detail = []
        else:
            self.detail = detail
        self.detail_nsprefix_ = None
        if extent is None:
            self.extent = []
        else:
            self.extent = extent
        self.extent_nsprefix_ = None
        if date is None:
            self.date = []
        else:
            self.date = date
        self.date_nsprefix_ = None
        if text is None:
            self.text = []
        else:
            self.text = text
        self.text_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, partDefinition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if partDefinition.subclass:
            return partDefinition.subclass(*args_, **kwargs_)
        else:
            return partDefinition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_detail(self):
        return self.detail
    def set_detail(self, detail):
        self.detail = detail
    def add_detail(self, value):
        self.detail.append(value)
    def insert_detail_at(self, index, value):
        self.detail.insert(index, value)
    def replace_detail_at(self, index, value):
        self.detail[index] = value
    def get_extent(self):
        return self.extent
    def set_extent(self, extent):
        self.extent = extent
    def add_extent(self, value):
        self.extent.append(value)
    def insert_extent_at(self, index, value):
        self.extent.insert(index, value)
    def replace_extent_at(self, index, value):
        self.extent[index] = value
    def get_date(self):
        return self.date
    def set_date(self, date):
        self.date = date
    def add_date(self, value):
        self.date.append(value)
    def insert_date_at(self, index, value):
        self.date.insert(index, value)
    def replace_date_at(self, index, value):
        self.date[index] = value
    def get_text(self):
        return self.text
    def set_text(self, text):
        self.text = text
    def add_text(self, value):
        self.text.append(value)
    def insert_text_at(self, index, value):
        self.text.insert(index, value)
    def replace_text_at(self, index, value):
        self.text[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_order(self):
        return self.order
    def set_order(self, order):
        self.order = order
    def get_displayLabel(self):
        return self.displayLabel
    def set_displayLabel(self, displayLabel):
        self.displayLabel = displayLabel
    def get_altRepGroup(self):
        return self.altRepGroup
    def set_altRepGroup(self, altRepGroup):
        self.altRepGroup = altRepGroup
    def get_lang(self):
        return self.lang
    def set_lang(self, lang):
        self.lang = lang
    def get_lang(self):
        return self.lang
    def set_lang(self, lang):
        self.lang = lang
    def get_script(self):
        return self.script
    def set_script(self, script):
        self.script = script
    def get_transliteration(self):
        return self.transliteration
    def set_transliteration(self, transliteration):
        self.transliteration = transliteration
    def hasContent_(self):
        if (
            self.detail or
            self.extent or
            self.date or
            self.text
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='partDefinition', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('partDefinition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='partDefinition')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='partDefinition', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='partDefinition'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.order is not None and 'order' not in already_processed:
            already_processed.add('order')
            outfile.write(' order="%s"' % self.gds_format_integer(self.order, input_name='order'))
        if self.displayLabel is not None and 'displayLabel' not in already_processed:
            already_processed.add('displayLabel')
            outfile.write(' displayLabel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.displayLabel), input_name='displayLabel')), ))
        if self.altRepGroup is not None and 'altRepGroup' not in already_processed:
            already_processed.add('altRepGroup')
            outfile.write(' altRepGroup=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.altRepGroup), input_name='altRepGroup')), ))
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lang), input_name='lang')), ))
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lang), input_name='lang')), ))
        if self.script is not None and 'script' not in already_processed:
            already_processed.add('script')
            outfile.write(' script=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.script), input_name='script')), ))
        if self.transliteration is not None and 'transliteration' not in already_processed:
            already_processed.add('transliteration')
            outfile.write(' transliteration=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.transliteration), input_name='transliteration')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='partDefinition', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for detail_ in self.detail:
            namespaceprefix_ = self.detail_nsprefix_ + ':' if (UseCapturedNS_ and self.detail_nsprefix_) else ''
            detail_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='detail', pretty_print=pretty_print)
        for extent_ in self.extent:
            namespaceprefix_ = self.extent_nsprefix_ + ':' if (UseCapturedNS_ and self.extent_nsprefix_) else ''
            extent_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='extent', pretty_print=pretty_print)
        for date_ in self.date:
            namespaceprefix_ = self.date_nsprefix_ + ':' if (UseCapturedNS_ and self.date_nsprefix_) else ''
            date_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='date', pretty_print=pretty_print)
        for text_ in self.text:
            namespaceprefix_ = self.text_nsprefix_ + ':' if (UseCapturedNS_ and self.text_nsprefix_) else ''
            text_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='text', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('order', node)
        if value is not None and 'order' not in already_processed:
            already_processed.add('order')
            self.order = self.gds_parse_integer(value, node, 'order')
        value = find_attr_value_('displayLabel', node)
        if value is not None and 'displayLabel' not in already_processed:
            already_processed.add('displayLabel')
            self.displayLabel = value
        value = find_attr_value_('altRepGroup', node)
        if value is not None and 'altRepGroup' not in already_processed:
            already_processed.add('altRepGroup')
            self.altRepGroup = value
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        value = find_attr_value_('script', node)
        if value is not None and 'script' not in already_processed:
            already_processed.add('script')
            self.script = value
        value = find_attr_value_('transliteration', node)
        if value is not None and 'transliteration' not in already_processed:
            already_processed.add('transliteration')
            self.transliteration = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'detail':
            obj_ = detailDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.detail.append(obj_)
            obj_.original_tagname_ = 'detail'
        elif nodeName_ == 'extent':
            obj_ = extentDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.extent.append(obj_)
            obj_.original_tagname_ = 'extent'
        elif nodeName_ == 'date':
            class_obj_ = self.get_class_obj_(child_, dateDefinition)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.date.append(obj_)
            obj_.original_tagname_ = 'date'
        elif nodeName_ == 'text':
            obj_ = text.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.text.append(obj_)
            obj_.original_tagname_ = 'text'
# end class partDefinition


class detailDefinition(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, level=None, number=None, caption=None, title=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.level = _cast(int, level)
        self.level_nsprefix_ = None
        if number is None:
            self.number = []
        else:
            self.number = number
        self.number_nsprefix_ = None
        if caption is None:
            self.caption = []
        else:
            self.caption = caption
        self.caption_nsprefix_ = None
        if title is None:
            self.title = []
        else:
            self.title = title
        self.title_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, detailDefinition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if detailDefinition.subclass:
            return detailDefinition.subclass(*args_, **kwargs_)
        else:
            return detailDefinition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_number(self):
        return self.number
    def set_number(self, number):
        self.number = number
    def add_number(self, value):
        self.number.append(value)
    def insert_number_at(self, index, value):
        self.number.insert(index, value)
    def replace_number_at(self, index, value):
        self.number[index] = value
    def get_caption(self):
        return self.caption
    def set_caption(self, caption):
        self.caption = caption
    def add_caption(self, value):
        self.caption.append(value)
    def insert_caption_at(self, index, value):
        self.caption.insert(index, value)
    def replace_caption_at(self, index, value):
        self.caption[index] = value
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def add_title(self, value):
        self.title.append(value)
    def insert_title_at(self, index, value):
        self.title.insert(index, value)
    def replace_title_at(self, index, value):
        self.title[index] = value
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_level(self):
        return self.level
    def set_level(self, level):
        self.level = level
    def hasContent_(self):
        if (
            self.number or
            self.caption or
            self.title
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='detailDefinition', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('detailDefinition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='detailDefinition')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='detailDefinition', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='detailDefinition'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.level is not None and 'level' not in already_processed:
            already_processed.add('level')
            outfile.write(' level="%s"' % self.gds_format_integer(self.level, input_name='level'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='detailDefinition', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for number_ in self.number:
            namespaceprefix_ = self.number_nsprefix_ + ':' if (UseCapturedNS_ and self.number_nsprefix_) else ''
            number_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='number', pretty_print=pretty_print)
        for caption_ in self.caption:
            namespaceprefix_ = self.caption_nsprefix_ + ':' if (UseCapturedNS_ and self.caption_nsprefix_) else ''
            caption_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='caption', pretty_print=pretty_print)
        for title_ in self.title:
            namespaceprefix_ = self.title_nsprefix_ + ':' if (UseCapturedNS_ and self.title_nsprefix_) else ''
            title_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='title', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('level', node)
        if value is not None and 'level' not in already_processed:
            already_processed.add('level')
            self.level = self.gds_parse_integer(value, node, 'level')
            if self.level <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'number':
            class_obj_ = self.get_class_obj_(child_, stringPlusLanguage)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.number.append(obj_)
            obj_.original_tagname_ = 'number'
        elif nodeName_ == 'caption':
            class_obj_ = self.get_class_obj_(child_, stringPlusLanguage)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.caption.append(obj_)
            obj_.original_tagname_ = 'caption'
        elif nodeName_ == 'title':
            class_obj_ = self.get_class_obj_(child_, stringPlusLanguage)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.title.append(obj_)
            obj_.original_tagname_ = 'title'
# end class detailDefinition


class extentDefinition(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, unit=None, start=None, end=None, total=None, list=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.unit = _cast(None, unit)
        self.unit_nsprefix_ = None
        self.start = start
        self.start_nsprefix_ = None
        self.end = end
        self.end_nsprefix_ = None
        self.total = total
        self.total_nsprefix_ = None
        self.list = list
        self.list_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, extentDefinition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if extentDefinition.subclass:
            return extentDefinition.subclass(*args_, **kwargs_)
        else:
            return extentDefinition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_start(self):
        return self.start
    def set_start(self, start):
        self.start = start
    def get_end(self):
        return self.end
    def set_end(self, end):
        self.end = end
    def get_total(self):
        return self.total
    def set_total(self, total):
        self.total = total
    def get_list(self):
        return self.list
    def set_list(self, list):
        self.list = list
    def get_unit(self):
        return self.unit
    def set_unit(self, unit):
        self.unit = unit
    def hasContent_(self):
        if (
            self.start is not None or
            self.end is not None or
            self.total is not None or
            self.list is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='extentDefinition', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('extentDefinition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='extentDefinition')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='extentDefinition', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='extentDefinition'):
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            outfile.write(' unit=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.unit), input_name='unit')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='extentDefinition', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.start is not None:
            namespaceprefix_ = self.start_nsprefix_ + ':' if (UseCapturedNS_ and self.start_nsprefix_) else ''
            self.start.export(outfile, level, namespaceprefix_, namespacedef_='', name_='start', pretty_print=pretty_print)
        if self.end is not None:
            namespaceprefix_ = self.end_nsprefix_ + ':' if (UseCapturedNS_ and self.end_nsprefix_) else ''
            self.end.export(outfile, level, namespaceprefix_, namespacedef_='', name_='end', pretty_print=pretty_print)
        if self.total is not None:
            namespaceprefix_ = self.total_nsprefix_ + ':' if (UseCapturedNS_ and self.total_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stotal>%s</%stotal>%s' % (namespaceprefix_ , self.gds_format_integer(self.total, input_name='total'), namespaceprefix_ , eol_))
        if self.list is not None:
            namespaceprefix_ = self.list_nsprefix_ + ':' if (UseCapturedNS_ and self.list_nsprefix_) else ''
            self.list.export(outfile, level, namespaceprefix_, namespacedef_='', name_='list', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            self.unit = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'start':
            class_obj_ = self.get_class_obj_(child_, stringPlusLanguage)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.start = obj_
            obj_.original_tagname_ = 'start'
        elif nodeName_ == 'end':
            class_obj_ = self.get_class_obj_(child_, stringPlusLanguage)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.end = obj_
            obj_.original_tagname_ = 'end'
        elif nodeName_ == 'total' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'total')
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'total')
            self.total = ival_
            self.total_nsprefix_ = child_.prefix
        elif nodeName_ == 'list':
            class_obj_ = self.get_class_obj_(child_, stringPlusLanguage)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.list = obj_
            obj_.original_tagname_ = 'list'
# end class extentDefinition


class physicalDescriptionDefinition(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, displayLabel=None, altRepGroup=None, lang=None, script=None, transliteration=None, form=None, reformattingQuality=None, internetMediaType=None, extent=None, digitalOrigin=None, note=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.displayLabel = _cast(None, displayLabel)
        self.displayLabel_nsprefix_ = None
        self.altRepGroup = _cast(None, altRepGroup)
        self.altRepGroup_nsprefix_ = None
        self.lang = _cast(None, lang)
        self.lang_nsprefix_ = None
        self.lang = _cast(None, lang)
        self.lang_nsprefix_ = None
        self.script = _cast(None, script)
        self.script_nsprefix_ = None
        self.transliteration = _cast(None, transliteration)
        self.transliteration_nsprefix_ = None
        if form is None:
            self.form = []
        else:
            self.form = form
        self.form_nsprefix_ = None
        if reformattingQuality is None:
            self.reformattingQuality = []
        else:
            self.reformattingQuality = reformattingQuality
        self.reformattingQuality_nsprefix_ = None
        if internetMediaType is None:
            self.internetMediaType = []
        else:
            self.internetMediaType = internetMediaType
        self.internetMediaType_nsprefix_ = None
        if extent is None:
            self.extent = []
        else:
            self.extent = extent
        self.extent_nsprefix_ = None
        if digitalOrigin is None:
            self.digitalOrigin = []
        else:
            self.digitalOrigin = digitalOrigin
        self.digitalOrigin_nsprefix_ = None
        if note is None:
            self.note = []
        else:
            self.note = note
        self.note_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, physicalDescriptionDefinition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if physicalDescriptionDefinition.subclass:
            return physicalDescriptionDefinition.subclass(*args_, **kwargs_)
        else:
            return physicalDescriptionDefinition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_form(self):
        return self.form
    def set_form(self, form):
        self.form = form
    def add_form(self, value):
        self.form.append(value)
    def insert_form_at(self, index, value):
        self.form.insert(index, value)
    def replace_form_at(self, index, value):
        self.form[index] = value
    def get_reformattingQuality(self):
        return self.reformattingQuality
    def set_reformattingQuality(self, reformattingQuality):
        self.reformattingQuality = reformattingQuality
    def add_reformattingQuality(self, value):
        self.reformattingQuality.append(value)
    def insert_reformattingQuality_at(self, index, value):
        self.reformattingQuality.insert(index, value)
    def replace_reformattingQuality_at(self, index, value):
        self.reformattingQuality[index] = value
    def get_internetMediaType(self):
        return self.internetMediaType
    def set_internetMediaType(self, internetMediaType):
        self.internetMediaType = internetMediaType
    def add_internetMediaType(self, value):
        self.internetMediaType.append(value)
    def insert_internetMediaType_at(self, index, value):
        self.internetMediaType.insert(index, value)
    def replace_internetMediaType_at(self, index, value):
        self.internetMediaType[index] = value
    def get_extent(self):
        return self.extent
    def set_extent(self, extent):
        self.extent = extent
    def add_extent(self, value):
        self.extent.append(value)
    def insert_extent_at(self, index, value):
        self.extent.insert(index, value)
    def replace_extent_at(self, index, value):
        self.extent[index] = value
    def get_digitalOrigin(self):
        return self.digitalOrigin
    def set_digitalOrigin(self, digitalOrigin):
        self.digitalOrigin = digitalOrigin
    def add_digitalOrigin(self, value):
        self.digitalOrigin.append(value)
    def insert_digitalOrigin_at(self, index, value):
        self.digitalOrigin.insert(index, value)
    def replace_digitalOrigin_at(self, index, value):
        self.digitalOrigin[index] = value
    def get_note(self):
        return self.note
    def set_note(self, note):
        self.note = note
    def add_note(self, value):
        self.note.append(value)
    def insert_note_at(self, index, value):
        self.note.insert(index, value)
    def replace_note_at(self, index, value):
        self.note[index] = value
    def get_displayLabel(self):
        return self.displayLabel
    def set_displayLabel(self, displayLabel):
        self.displayLabel = displayLabel
    def get_altRepGroup(self):
        return self.altRepGroup
    def set_altRepGroup(self, altRepGroup):
        self.altRepGroup = altRepGroup
    def get_lang(self):
        return self.lang
    def set_lang(self, lang):
        self.lang = lang
    def get_lang(self):
        return self.lang
    def set_lang(self, lang):
        self.lang = lang
    def get_script(self):
        return self.script
    def set_script(self, script):
        self.script = script
    def get_transliteration(self):
        return self.transliteration
    def set_transliteration(self, transliteration):
        self.transliteration = transliteration
    def hasContent_(self):
        if (
            self.form or
            self.reformattingQuality or
            self.internetMediaType or
            self.extent or
            self.digitalOrigin or
            self.note
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='physicalDescriptionDefinition', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('physicalDescriptionDefinition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='physicalDescriptionDefinition')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='physicalDescriptionDefinition', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='physicalDescriptionDefinition'):
        if self.displayLabel is not None and 'displayLabel' not in already_processed:
            already_processed.add('displayLabel')
            outfile.write(' displayLabel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.displayLabel), input_name='displayLabel')), ))
        if self.altRepGroup is not None and 'altRepGroup' not in already_processed:
            already_processed.add('altRepGroup')
            outfile.write(' altRepGroup=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.altRepGroup), input_name='altRepGroup')), ))
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lang), input_name='lang')), ))
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lang), input_name='lang')), ))
        if self.script is not None and 'script' not in already_processed:
            already_processed.add('script')
            outfile.write(' script=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.script), input_name='script')), ))
        if self.transliteration is not None and 'transliteration' not in already_processed:
            already_processed.add('transliteration')
            outfile.write(' transliteration=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.transliteration), input_name='transliteration')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='physicalDescriptionDefinition', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for form_ in self.form:
            namespaceprefix_ = self.form_nsprefix_ + ':' if (UseCapturedNS_ and self.form_nsprefix_) else ''
            form_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='form', pretty_print=pretty_print)
        for reformattingQuality_ in self.reformattingQuality:
            namespaceprefix_ = self.reformattingQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.reformattingQuality_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sreformattingQuality>%s</%sreformattingQuality>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(reformattingQuality_), input_name='reformattingQuality')), namespaceprefix_ , eol_))
        for internetMediaType_ in self.internetMediaType:
            namespaceprefix_ = self.internetMediaType_nsprefix_ + ':' if (UseCapturedNS_ and self.internetMediaType_nsprefix_) else ''
            internetMediaType_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='internetMediaType', pretty_print=pretty_print)
        for extent_ in self.extent:
            namespaceprefix_ = self.extent_nsprefix_ + ':' if (UseCapturedNS_ and self.extent_nsprefix_) else ''
            extent_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='extent', pretty_print=pretty_print)
        for digitalOrigin_ in self.digitalOrigin:
            namespaceprefix_ = self.digitalOrigin_nsprefix_ + ':' if (UseCapturedNS_ and self.digitalOrigin_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdigitalOrigin>%s</%sdigitalOrigin>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(digitalOrigin_), input_name='digitalOrigin')), namespaceprefix_ , eol_))
        for note_ in self.note:
            namespaceprefix_ = self.note_nsprefix_ + ':' if (UseCapturedNS_ and self.note_nsprefix_) else ''
            note_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='note', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('displayLabel', node)
        if value is not None and 'displayLabel' not in already_processed:
            already_processed.add('displayLabel')
            self.displayLabel = value
        value = find_attr_value_('altRepGroup', node)
        if value is not None and 'altRepGroup' not in already_processed:
            already_processed.add('altRepGroup')
            self.altRepGroup = value
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        value = find_attr_value_('script', node)
        if value is not None and 'script' not in already_processed:
            already_processed.add('script')
            self.script = value
        value = find_attr_value_('transliteration', node)
        if value is not None and 'transliteration' not in already_processed:
            already_processed.add('transliteration')
            self.transliteration = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'form':
            obj_ = formDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.form.append(obj_)
            obj_.original_tagname_ = 'form'
        elif nodeName_ == 'reformattingQuality':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'reformattingQuality')
            value_ = self.gds_validate_string(value_, node, 'reformattingQuality')
            self.reformattingQuality.append(value_)
            self.reformattingQuality_nsprefix_ = child_.prefix
        elif nodeName_ == 'internetMediaType':
            class_obj_ = self.get_class_obj_(child_, stringPlusLanguage)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.internetMediaType.append(obj_)
            obj_.original_tagname_ = 'internetMediaType'
        elif nodeName_ == 'extent':
            obj_ = extent.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.extent.append(obj_)
            obj_.original_tagname_ = 'extent'
        elif nodeName_ == 'digitalOrigin':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'digitalOrigin')
            value_ = self.gds_validate_string(value_, node, 'digitalOrigin')
            self.digitalOrigin.append(value_)
            self.digitalOrigin_nsprefix_ = child_.prefix
        elif nodeName_ == 'note':
            obj_ = physicalDescriptionNote.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.note.append(obj_)
            obj_.original_tagname_ = 'note'
# end class physicalDescriptionDefinition


class recordInfoDefinition(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, displayLabel=None, altRepGroup=None, lang=None, script=None, transliteration=None, recordContentSource=None, recordCreationDate=None, recordChangeDate=None, recordIdentifier=None, languageOfCataloging=None, recordOrigin=None, descriptionStandard=None, recordInfoNote=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.displayLabel = _cast(None, displayLabel)
        self.displayLabel_nsprefix_ = None
        self.altRepGroup = _cast(None, altRepGroup)
        self.altRepGroup_nsprefix_ = None
        self.lang = _cast(None, lang)
        self.lang_nsprefix_ = None
        self.lang = _cast(None, lang)
        self.lang_nsprefix_ = None
        self.script = _cast(None, script)
        self.script_nsprefix_ = None
        self.transliteration = _cast(None, transliteration)
        self.transliteration_nsprefix_ = None
        if recordContentSource is None:
            self.recordContentSource = []
        else:
            self.recordContentSource = recordContentSource
        self.recordContentSource_nsprefix_ = None
        if recordCreationDate is None:
            self.recordCreationDate = []
        else:
            self.recordCreationDate = recordCreationDate
        self.recordCreationDate_nsprefix_ = None
        if recordChangeDate is None:
            self.recordChangeDate = []
        else:
            self.recordChangeDate = recordChangeDate
        self.recordChangeDate_nsprefix_ = None
        if recordIdentifier is None:
            self.recordIdentifier = []
        else:
            self.recordIdentifier = recordIdentifier
        self.recordIdentifier_nsprefix_ = None
        if languageOfCataloging is None:
            self.languageOfCataloging = []
        else:
            self.languageOfCataloging = languageOfCataloging
        self.languageOfCataloging_nsprefix_ = None
        if recordOrigin is None:
            self.recordOrigin = []
        else:
            self.recordOrigin = recordOrigin
        self.recordOrigin_nsprefix_ = None
        if descriptionStandard is None:
            self.descriptionStandard = []
        else:
            self.descriptionStandard = descriptionStandard
        self.descriptionStandard_nsprefix_ = None
        if recordInfoNote is None:
            self.recordInfoNote = []
        else:
            self.recordInfoNote = recordInfoNote
        self.recordInfoNote_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, recordInfoDefinition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if recordInfoDefinition.subclass:
            return recordInfoDefinition.subclass(*args_, **kwargs_)
        else:
            return recordInfoDefinition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_recordContentSource(self):
        return self.recordContentSource
    def set_recordContentSource(self, recordContentSource):
        self.recordContentSource = recordContentSource
    def add_recordContentSource(self, value):
        self.recordContentSource.append(value)
    def insert_recordContentSource_at(self, index, value):
        self.recordContentSource.insert(index, value)
    def replace_recordContentSource_at(self, index, value):
        self.recordContentSource[index] = value
    def get_recordCreationDate(self):
        return self.recordCreationDate
    def set_recordCreationDate(self, recordCreationDate):
        self.recordCreationDate = recordCreationDate
    def add_recordCreationDate(self, value):
        self.recordCreationDate.append(value)
    def insert_recordCreationDate_at(self, index, value):
        self.recordCreationDate.insert(index, value)
    def replace_recordCreationDate_at(self, index, value):
        self.recordCreationDate[index] = value
    def get_recordChangeDate(self):
        return self.recordChangeDate
    def set_recordChangeDate(self, recordChangeDate):
        self.recordChangeDate = recordChangeDate
    def add_recordChangeDate(self, value):
        self.recordChangeDate.append(value)
    def insert_recordChangeDate_at(self, index, value):
        self.recordChangeDate.insert(index, value)
    def replace_recordChangeDate_at(self, index, value):
        self.recordChangeDate[index] = value
    def get_recordIdentifier(self):
        return self.recordIdentifier
    def set_recordIdentifier(self, recordIdentifier):
        self.recordIdentifier = recordIdentifier
    def add_recordIdentifier(self, value):
        self.recordIdentifier.append(value)
    def insert_recordIdentifier_at(self, index, value):
        self.recordIdentifier.insert(index, value)
    def replace_recordIdentifier_at(self, index, value):
        self.recordIdentifier[index] = value
    def get_languageOfCataloging(self):
        return self.languageOfCataloging
    def set_languageOfCataloging(self, languageOfCataloging):
        self.languageOfCataloging = languageOfCataloging
    def add_languageOfCataloging(self, value):
        self.languageOfCataloging.append(value)
    def insert_languageOfCataloging_at(self, index, value):
        self.languageOfCataloging.insert(index, value)
    def replace_languageOfCataloging_at(self, index, value):
        self.languageOfCataloging[index] = value
    def get_recordOrigin(self):
        return self.recordOrigin
    def set_recordOrigin(self, recordOrigin):
        self.recordOrigin = recordOrigin
    def add_recordOrigin(self, value):
        self.recordOrigin.append(value)
    def insert_recordOrigin_at(self, index, value):
        self.recordOrigin.insert(index, value)
    def replace_recordOrigin_at(self, index, value):
        self.recordOrigin[index] = value
    def get_descriptionStandard(self):
        return self.descriptionStandard
    def set_descriptionStandard(self, descriptionStandard):
        self.descriptionStandard = descriptionStandard
    def add_descriptionStandard(self, value):
        self.descriptionStandard.append(value)
    def insert_descriptionStandard_at(self, index, value):
        self.descriptionStandard.insert(index, value)
    def replace_descriptionStandard_at(self, index, value):
        self.descriptionStandard[index] = value
    def get_recordInfoNote(self):
        return self.recordInfoNote
    def set_recordInfoNote(self, recordInfoNote):
        self.recordInfoNote = recordInfoNote
    def add_recordInfoNote(self, value):
        self.recordInfoNote.append(value)
    def insert_recordInfoNote_at(self, index, value):
        self.recordInfoNote.insert(index, value)
    def replace_recordInfoNote_at(self, index, value):
        self.recordInfoNote[index] = value
    def get_displayLabel(self):
        return self.displayLabel
    def set_displayLabel(self, displayLabel):
        self.displayLabel = displayLabel
    def get_altRepGroup(self):
        return self.altRepGroup
    def set_altRepGroup(self, altRepGroup):
        self.altRepGroup = altRepGroup
    def get_lang(self):
        return self.lang
    def set_lang(self, lang):
        self.lang = lang
    def get_lang(self):
        return self.lang
    def set_lang(self, lang):
        self.lang = lang
    def get_script(self):
        return self.script
    def set_script(self, script):
        self.script = script
    def get_transliteration(self):
        return self.transliteration
    def set_transliteration(self, transliteration):
        self.transliteration = transliteration
    def hasContent_(self):
        if (
            self.recordContentSource or
            self.recordCreationDate or
            self.recordChangeDate or
            self.recordIdentifier or
            self.languageOfCataloging or
            self.recordOrigin or
            self.descriptionStandard or
            self.recordInfoNote
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='recordInfoDefinition', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('recordInfoDefinition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='recordInfoDefinition')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='recordInfoDefinition', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='recordInfoDefinition'):
        if self.displayLabel is not None and 'displayLabel' not in already_processed:
            already_processed.add('displayLabel')
            outfile.write(' displayLabel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.displayLabel), input_name='displayLabel')), ))
        if self.altRepGroup is not None and 'altRepGroup' not in already_processed:
            already_processed.add('altRepGroup')
            outfile.write(' altRepGroup=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.altRepGroup), input_name='altRepGroup')), ))
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lang), input_name='lang')), ))
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lang), input_name='lang')), ))
        if self.script is not None and 'script' not in already_processed:
            already_processed.add('script')
            outfile.write(' script=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.script), input_name='script')), ))
        if self.transliteration is not None and 'transliteration' not in already_processed:
            already_processed.add('transliteration')
            outfile.write(' transliteration=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.transliteration), input_name='transliteration')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='recordInfoDefinition', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for recordContentSource_ in self.recordContentSource:
            namespaceprefix_ = self.recordContentSource_nsprefix_ + ':' if (UseCapturedNS_ and self.recordContentSource_nsprefix_) else ''
            recordContentSource_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='recordContentSource', pretty_print=pretty_print)
        for recordCreationDate_ in self.recordCreationDate:
            namespaceprefix_ = self.recordCreationDate_nsprefix_ + ':' if (UseCapturedNS_ and self.recordCreationDate_nsprefix_) else ''
            recordCreationDate_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='recordCreationDate', pretty_print=pretty_print)
        for recordChangeDate_ in self.recordChangeDate:
            namespaceprefix_ = self.recordChangeDate_nsprefix_ + ':' if (UseCapturedNS_ and self.recordChangeDate_nsprefix_) else ''
            recordChangeDate_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='recordChangeDate', pretty_print=pretty_print)
        for recordIdentifier_ in self.recordIdentifier:
            namespaceprefix_ = self.recordIdentifier_nsprefix_ + ':' if (UseCapturedNS_ and self.recordIdentifier_nsprefix_) else ''
            recordIdentifier_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='recordIdentifier', pretty_print=pretty_print)
        for languageOfCataloging_ in self.languageOfCataloging:
            namespaceprefix_ = self.languageOfCataloging_nsprefix_ + ':' if (UseCapturedNS_ and self.languageOfCataloging_nsprefix_) else ''
            languageOfCataloging_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='languageOfCataloging', pretty_print=pretty_print)
        for recordOrigin_ in self.recordOrigin:
            namespaceprefix_ = self.recordOrigin_nsprefix_ + ':' if (UseCapturedNS_ and self.recordOrigin_nsprefix_) else ''
            recordOrigin_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='recordOrigin', pretty_print=pretty_print)
        for descriptionStandard_ in self.descriptionStandard:
            namespaceprefix_ = self.descriptionStandard_nsprefix_ + ':' if (UseCapturedNS_ and self.descriptionStandard_nsprefix_) else ''
            descriptionStandard_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='descriptionStandard', pretty_print=pretty_print)
        for recordInfoNote_ in self.recordInfoNote:
            namespaceprefix_ = self.recordInfoNote_nsprefix_ + ':' if (UseCapturedNS_ and self.recordInfoNote_nsprefix_) else ''
            recordInfoNote_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='recordInfoNote', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('displayLabel', node)
        if value is not None and 'displayLabel' not in already_processed:
            already_processed.add('displayLabel')
            self.displayLabel = value
        value = find_attr_value_('altRepGroup', node)
        if value is not None and 'altRepGroup' not in already_processed:
            already_processed.add('altRepGroup')
            self.altRepGroup = value
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        value = find_attr_value_('script', node)
        if value is not None and 'script' not in already_processed:
            already_processed.add('script')
            self.script = value
        value = find_attr_value_('transliteration', node)
        if value is not None and 'transliteration' not in already_processed:
            already_processed.add('transliteration')
            self.transliteration = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'recordContentSource':
            class_obj_ = self.get_class_obj_(child_, stringPlusLanguagePlusAuthority)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.recordContentSource.append(obj_)
            obj_.original_tagname_ = 'recordContentSource'
        elif nodeName_ == 'recordCreationDate':
            class_obj_ = self.get_class_obj_(child_, dateDefinition)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.recordCreationDate.append(obj_)
            obj_.original_tagname_ = 'recordCreationDate'
        elif nodeName_ == 'recordChangeDate':
            class_obj_ = self.get_class_obj_(child_, dateDefinition)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.recordChangeDate.append(obj_)
            obj_.original_tagname_ = 'recordChangeDate'
        elif nodeName_ == 'recordIdentifier':
            obj_ = recordIdentifierDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.recordIdentifier.append(obj_)
            obj_.original_tagname_ = 'recordIdentifier'
        elif nodeName_ == 'languageOfCataloging':
            obj_ = languageDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.languageOfCataloging.append(obj_)
            obj_.original_tagname_ = 'languageOfCataloging'
        elif nodeName_ == 'recordOrigin':
            class_obj_ = self.get_class_obj_(child_, stringPlusLanguage)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.recordOrigin.append(obj_)
            obj_.original_tagname_ = 'recordOrigin'
        elif nodeName_ == 'descriptionStandard':
            class_obj_ = self.get_class_obj_(child_, stringPlusLanguagePlusAuthority)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.descriptionStandard.append(obj_)
            obj_.original_tagname_ = 'descriptionStandard'
        elif nodeName_ == 'recordInfoNote':
            obj_ = noteDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.recordInfoNote.append(obj_)
            obj_.original_tagname_ = 'recordInfoNote'
# end class recordInfoDefinition


class relatedItemDefinition(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_='simple', otherType=None, otherTypeAuth=None, otherTypeAuthURI=None, otherTypeURI=None, displayLabel=None, ID=None, href=None, role=None, arcrole=None, title=None, show=None, actuate=None, abstract=None, accessCondition=None, classification=None, extension=None, genre=None, identifier=None, language=None, location=None, name=None, note=None, originInfo=None, part=None, physicalDescription=None, recordInfo=None, relatedItem=None, subject=None, tableOfContents=None, targetAudience=None, titleInfo=None, typeOfResource=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.otherType = _cast(None, otherType)
        self.otherType_nsprefix_ = None
        self.otherTypeAuth = _cast(None, otherTypeAuth)
        self.otherTypeAuth_nsprefix_ = None
        self.otherTypeAuthURI = _cast(None, otherTypeAuthURI)
        self.otherTypeAuthURI_nsprefix_ = None
        self.otherTypeURI = _cast(None, otherTypeURI)
        self.otherTypeURI_nsprefix_ = None
        self.displayLabel = _cast(None, displayLabel)
        self.displayLabel_nsprefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.href = _cast(None, href)
        self.href_nsprefix_ = None
        self.role = _cast(None, role)
        self.role_nsprefix_ = None
        self.arcrole = _cast(None, arcrole)
        self.arcrole_nsprefix_ = None
        self.title = _cast(None, title)
        self.title_nsprefix_ = None
        self.show = _cast(None, show)
        self.show_nsprefix_ = None
        self.actuate = _cast(None, actuate)
        self.actuate_nsprefix_ = None
        if abstract is None:
            self.abstract = []
        else:
            self.abstract = abstract
        self.abstract_nsprefix_ = None
        if accessCondition is None:
            self.accessCondition = []
        else:
            self.accessCondition = accessCondition
        self.accessCondition_nsprefix_ = None
        if classification is None:
            self.classification = []
        else:
            self.classification = classification
        self.classification_nsprefix_ = None
        if extension is None:
            self.extension = []
        else:
            self.extension = extension
        self.extension_nsprefix_ = None
        if genre is None:
            self.genre = []
        else:
            self.genre = genre
        self.genre_nsprefix_ = None
        if identifier is None:
            self.identifier = []
        else:
            self.identifier = identifier
        self.identifier_nsprefix_ = None
        if language is None:
            self.language = []
        else:
            self.language = language
        self.language_nsprefix_ = None
        if location is None:
            self.location = []
        else:
            self.location = location
        self.location_nsprefix_ = None
        if name is None:
            self.name = []
        else:
            self.name = name
        self.name_nsprefix_ = None
        if note is None:
            self.note = []
        else:
            self.note = note
        self.note_nsprefix_ = None
        if originInfo is None:
            self.originInfo = []
        else:
            self.originInfo = originInfo
        self.originInfo_nsprefix_ = None
        if part is None:
            self.part = []
        else:
            self.part = part
        self.part_nsprefix_ = None
        if physicalDescription is None:
            self.physicalDescription = []
        else:
            self.physicalDescription = physicalDescription
        self.physicalDescription_nsprefix_ = None
        if recordInfo is None:
            self.recordInfo = []
        else:
            self.recordInfo = recordInfo
        self.recordInfo_nsprefix_ = None
        if relatedItem is None:
            self.relatedItem = []
        else:
            self.relatedItem = relatedItem
        self.relatedItem_nsprefix_ = None
        if subject is None:
            self.subject = []
        else:
            self.subject = subject
        self.subject_nsprefix_ = None
        if tableOfContents is None:
            self.tableOfContents = []
        else:
            self.tableOfContents = tableOfContents
        self.tableOfContents_nsprefix_ = None
        if targetAudience is None:
            self.targetAudience = []
        else:
            self.targetAudience = targetAudience
        self.targetAudience_nsprefix_ = None
        if titleInfo is None:
            self.titleInfo = []
        else:
            self.titleInfo = titleInfo
        self.titleInfo_nsprefix_ = None
        if typeOfResource is None:
            self.typeOfResource = []
        else:
            self.typeOfResource = typeOfResource
        self.typeOfResource_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, relatedItemDefinition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if relatedItemDefinition.subclass:
            return relatedItemDefinition.subclass(*args_, **kwargs_)
        else:
            return relatedItemDefinition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_abstract(self):
        return self.abstract
    def set_abstract(self, abstract):
        self.abstract = abstract
    def add_abstract(self, value):
        self.abstract.append(value)
    def insert_abstract_at(self, index, value):
        self.abstract.insert(index, value)
    def replace_abstract_at(self, index, value):
        self.abstract[index] = value
    def get_accessCondition(self):
        return self.accessCondition
    def set_accessCondition(self, accessCondition):
        self.accessCondition = accessCondition
    def add_accessCondition(self, value):
        self.accessCondition.append(value)
    def insert_accessCondition_at(self, index, value):
        self.accessCondition.insert(index, value)
    def replace_accessCondition_at(self, index, value):
        self.accessCondition[index] = value
    def get_classification(self):
        return self.classification
    def set_classification(self, classification):
        self.classification = classification
    def add_classification(self, value):
        self.classification.append(value)
    def insert_classification_at(self, index, value):
        self.classification.insert(index, value)
    def replace_classification_at(self, index, value):
        self.classification[index] = value
    def get_extension(self):
        return self.extension
    def set_extension(self, extension):
        self.extension = extension
    def add_extension(self, value):
        self.extension.append(value)
    def insert_extension_at(self, index, value):
        self.extension.insert(index, value)
    def replace_extension_at(self, index, value):
        self.extension[index] = value
    def get_genre(self):
        return self.genre
    def set_genre(self, genre):
        self.genre = genre
    def add_genre(self, value):
        self.genre.append(value)
    def insert_genre_at(self, index, value):
        self.genre.insert(index, value)
    def replace_genre_at(self, index, value):
        self.genre[index] = value
    def get_identifier(self):
        return self.identifier
    def set_identifier(self, identifier):
        self.identifier = identifier
    def add_identifier(self, value):
        self.identifier.append(value)
    def insert_identifier_at(self, index, value):
        self.identifier.insert(index, value)
    def replace_identifier_at(self, index, value):
        self.identifier[index] = value
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def add_language(self, value):
        self.language.append(value)
    def insert_language_at(self, index, value):
        self.language.insert(index, value)
    def replace_language_at(self, index, value):
        self.language[index] = value
    def get_location(self):
        return self.location
    def set_location(self, location):
        self.location = location
    def add_location(self, value):
        self.location.append(value)
    def insert_location_at(self, index, value):
        self.location.insert(index, value)
    def replace_location_at(self, index, value):
        self.location[index] = value
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def add_name(self, value):
        self.name.append(value)
    def insert_name_at(self, index, value):
        self.name.insert(index, value)
    def replace_name_at(self, index, value):
        self.name[index] = value
    def get_note(self):
        return self.note
    def set_note(self, note):
        self.note = note
    def add_note(self, value):
        self.note.append(value)
    def insert_note_at(self, index, value):
        self.note.insert(index, value)
    def replace_note_at(self, index, value):
        self.note[index] = value
    def get_originInfo(self):
        return self.originInfo
    def set_originInfo(self, originInfo):
        self.originInfo = originInfo
    def add_originInfo(self, value):
        self.originInfo.append(value)
    def insert_originInfo_at(self, index, value):
        self.originInfo.insert(index, value)
    def replace_originInfo_at(self, index, value):
        self.originInfo[index] = value
    def get_part(self):
        return self.part
    def set_part(self, part):
        self.part = part
    def add_part(self, value):
        self.part.append(value)
    def insert_part_at(self, index, value):
        self.part.insert(index, value)
    def replace_part_at(self, index, value):
        self.part[index] = value
    def get_physicalDescription(self):
        return self.physicalDescription
    def set_physicalDescription(self, physicalDescription):
        self.physicalDescription = physicalDescription
    def add_physicalDescription(self, value):
        self.physicalDescription.append(value)
    def insert_physicalDescription_at(self, index, value):
        self.physicalDescription.insert(index, value)
    def replace_physicalDescription_at(self, index, value):
        self.physicalDescription[index] = value
    def get_recordInfo(self):
        return self.recordInfo
    def set_recordInfo(self, recordInfo):
        self.recordInfo = recordInfo
    def add_recordInfo(self, value):
        self.recordInfo.append(value)
    def insert_recordInfo_at(self, index, value):
        self.recordInfo.insert(index, value)
    def replace_recordInfo_at(self, index, value):
        self.recordInfo[index] = value
    def get_relatedItem(self):
        return self.relatedItem
    def set_relatedItem(self, relatedItem):
        self.relatedItem = relatedItem
    def add_relatedItem(self, value):
        self.relatedItem.append(value)
    def insert_relatedItem_at(self, index, value):
        self.relatedItem.insert(index, value)
    def replace_relatedItem_at(self, index, value):
        self.relatedItem[index] = value
    def get_subject(self):
        return self.subject
    def set_subject(self, subject):
        self.subject = subject
    def add_subject(self, value):
        self.subject.append(value)
    def insert_subject_at(self, index, value):
        self.subject.insert(index, value)
    def replace_subject_at(self, index, value):
        self.subject[index] = value
    def get_tableOfContents(self):
        return self.tableOfContents
    def set_tableOfContents(self, tableOfContents):
        self.tableOfContents = tableOfContents
    def add_tableOfContents(self, value):
        self.tableOfContents.append(value)
    def insert_tableOfContents_at(self, index, value):
        self.tableOfContents.insert(index, value)
    def replace_tableOfContents_at(self, index, value):
        self.tableOfContents[index] = value
    def get_targetAudience(self):
        return self.targetAudience
    def set_targetAudience(self, targetAudience):
        self.targetAudience = targetAudience
    def add_targetAudience(self, value):
        self.targetAudience.append(value)
    def insert_targetAudience_at(self, index, value):
        self.targetAudience.insert(index, value)
    def replace_targetAudience_at(self, index, value):
        self.targetAudience[index] = value
    def get_titleInfo(self):
        return self.titleInfo
    def set_titleInfo(self, titleInfo):
        self.titleInfo = titleInfo
    def add_titleInfo(self, value):
        self.titleInfo.append(value)
    def insert_titleInfo_at(self, index, value):
        self.titleInfo.insert(index, value)
    def replace_titleInfo_at(self, index, value):
        self.titleInfo[index] = value
    def get_typeOfResource(self):
        return self.typeOfResource
    def set_typeOfResource(self, typeOfResource):
        self.typeOfResource = typeOfResource
    def add_typeOfResource(self, value):
        self.typeOfResource.append(value)
    def insert_typeOfResource_at(self, index, value):
        self.typeOfResource.insert(index, value)
    def replace_typeOfResource_at(self, index, value):
        self.typeOfResource[index] = value
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_otherType(self):
        return self.otherType
    def set_otherType(self, otherType):
        self.otherType = otherType
    def get_otherTypeAuth(self):
        return self.otherTypeAuth
    def set_otherTypeAuth(self, otherTypeAuth):
        self.otherTypeAuth = otherTypeAuth
    def get_otherTypeAuthURI(self):
        return self.otherTypeAuthURI
    def set_otherTypeAuthURI(self, otherTypeAuthURI):
        self.otherTypeAuthURI = otherTypeAuthURI
    def get_otherTypeURI(self):
        return self.otherTypeURI
    def set_otherTypeURI(self, otherTypeURI):
        self.otherTypeURI = otherTypeURI
    def get_displayLabel(self):
        return self.displayLabel
    def set_displayLabel(self, displayLabel):
        self.displayLabel = displayLabel
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_href(self):
        return self.href
    def set_href(self, href):
        self.href = href
    def get_role(self):
        return self.role
    def set_role(self, role):
        self.role = role
    def get_arcrole(self):
        return self.arcrole
    def set_arcrole(self, arcrole):
        self.arcrole = arcrole
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def get_show(self):
        return self.show
    def set_show(self, show):
        self.show = show
    def get_actuate(self):
        return self.actuate
    def set_actuate(self, actuate):
        self.actuate = actuate
    def hasContent_(self):
        if (
            self.abstract or
            self.accessCondition or
            self.classification or
            self.extension or
            self.genre or
            self.identifier or
            self.language or
            self.location or
            self.name or
            self.note or
            self.originInfo or
            self.part or
            self.physicalDescription or
            self.recordInfo or
            self.relatedItem or
            self.subject or
            self.tableOfContents or
            self.targetAudience or
            self.titleInfo or
            self.typeOfResource
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='relatedItemDefinition', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('relatedItemDefinition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='relatedItemDefinition')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='relatedItemDefinition', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='relatedItemDefinition'):
        if self.type_ != "simple" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.otherType is not None and 'otherType' not in already_processed:
            already_processed.add('otherType')
            outfile.write(' otherType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.otherType), input_name='otherType')), ))
        if self.otherTypeAuth is not None and 'otherTypeAuth' not in already_processed:
            already_processed.add('otherTypeAuth')
            outfile.write(' otherTypeAuth=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.otherTypeAuth), input_name='otherTypeAuth')), ))
        if self.otherTypeAuthURI is not None and 'otherTypeAuthURI' not in already_processed:
            already_processed.add('otherTypeAuthURI')
            outfile.write(' otherTypeAuthURI=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.otherTypeAuthURI), input_name='otherTypeAuthURI')), ))
        if self.otherTypeURI is not None and 'otherTypeURI' not in already_processed:
            already_processed.add('otherTypeURI')
            outfile.write(' otherTypeURI=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.otherTypeURI), input_name='otherTypeURI')), ))
        if self.displayLabel is not None and 'displayLabel' not in already_processed:
            already_processed.add('displayLabel')
            outfile.write(' displayLabel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.displayLabel), input_name='displayLabel')), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.type_ != "simple" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (quote_attrib(self.href), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.add('role')
            outfile.write(' role=%s' % (quote_attrib(self.role), ))
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            outfile.write(' arcrole=%s' % (quote_attrib(self.arcrole), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.add('title')
            outfile.write(' title=%s' % (quote_attrib(self.title), ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.add('show')
            outfile.write(' show=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.show), input_name='show')), ))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            outfile.write(' actuate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.actuate), input_name='actuate')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='relatedItemDefinition', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for abstract_ in self.abstract:
            namespaceprefix_ = self.abstract_nsprefix_ + ':' if (UseCapturedNS_ and self.abstract_nsprefix_) else ''
            abstract_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='abstract', pretty_print=pretty_print)
        for accessCondition_ in self.accessCondition:
            namespaceprefix_ = self.accessCondition_nsprefix_ + ':' if (UseCapturedNS_ and self.accessCondition_nsprefix_) else ''
            accessCondition_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='accessCondition', pretty_print=pretty_print)
        for classification_ in self.classification:
            namespaceprefix_ = self.classification_nsprefix_ + ':' if (UseCapturedNS_ and self.classification_nsprefix_) else ''
            classification_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='classification', pretty_print=pretty_print)
        for extension_ in self.extension:
            namespaceprefix_ = self.extension_nsprefix_ + ':' if (UseCapturedNS_ and self.extension_nsprefix_) else ''
            extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='extension', pretty_print=pretty_print)
        for genre_ in self.genre:
            namespaceprefix_ = self.genre_nsprefix_ + ':' if (UseCapturedNS_ and self.genre_nsprefix_) else ''
            genre_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='genre', pretty_print=pretty_print)
        for identifier_ in self.identifier:
            namespaceprefix_ = self.identifier_nsprefix_ + ':' if (UseCapturedNS_ and self.identifier_nsprefix_) else ''
            identifier_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='identifier', pretty_print=pretty_print)
        for language_ in self.language:
            namespaceprefix_ = self.language_nsprefix_ + ':' if (UseCapturedNS_ and self.language_nsprefix_) else ''
            language_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='language', pretty_print=pretty_print)
        for location_ in self.location:
            namespaceprefix_ = self.location_nsprefix_ + ':' if (UseCapturedNS_ and self.location_nsprefix_) else ''
            location_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='location', pretty_print=pretty_print)
        for name_ in self.name:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            name_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='name', pretty_print=pretty_print)
        for note_ in self.note:
            namespaceprefix_ = self.note_nsprefix_ + ':' if (UseCapturedNS_ and self.note_nsprefix_) else ''
            note_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='note', pretty_print=pretty_print)
        for originInfo_ in self.originInfo:
            namespaceprefix_ = self.originInfo_nsprefix_ + ':' if (UseCapturedNS_ and self.originInfo_nsprefix_) else ''
            originInfo_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='originInfo', pretty_print=pretty_print)
        for part_ in self.part:
            namespaceprefix_ = self.part_nsprefix_ + ':' if (UseCapturedNS_ and self.part_nsprefix_) else ''
            part_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='part', pretty_print=pretty_print)
        for physicalDescription_ in self.physicalDescription:
            namespaceprefix_ = self.physicalDescription_nsprefix_ + ':' if (UseCapturedNS_ and self.physicalDescription_nsprefix_) else ''
            physicalDescription_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='physicalDescription', pretty_print=pretty_print)
        for recordInfo_ in self.recordInfo:
            namespaceprefix_ = self.recordInfo_nsprefix_ + ':' if (UseCapturedNS_ and self.recordInfo_nsprefix_) else ''
            recordInfo_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='recordInfo', pretty_print=pretty_print)
        for relatedItem_ in self.relatedItem:
            namespaceprefix_ = self.relatedItem_nsprefix_ + ':' if (UseCapturedNS_ and self.relatedItem_nsprefix_) else ''
            relatedItem_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='relatedItem', pretty_print=pretty_print)
        for subject_ in self.subject:
            namespaceprefix_ = self.subject_nsprefix_ + ':' if (UseCapturedNS_ and self.subject_nsprefix_) else ''
            subject_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subject', pretty_print=pretty_print)
        for tableOfContents_ in self.tableOfContents:
            namespaceprefix_ = self.tableOfContents_nsprefix_ + ':' if (UseCapturedNS_ and self.tableOfContents_nsprefix_) else ''
            tableOfContents_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='tableOfContents', pretty_print=pretty_print)
        for targetAudience_ in self.targetAudience:
            namespaceprefix_ = self.targetAudience_nsprefix_ + ':' if (UseCapturedNS_ and self.targetAudience_nsprefix_) else ''
            targetAudience_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='targetAudience', pretty_print=pretty_print)
        for titleInfo_ in self.titleInfo:
            namespaceprefix_ = self.titleInfo_nsprefix_ + ':' if (UseCapturedNS_ and self.titleInfo_nsprefix_) else ''
            titleInfo_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='titleInfo', pretty_print=pretty_print)
        for typeOfResource_ in self.typeOfResource:
            namespaceprefix_ = self.typeOfResource_nsprefix_ + ':' if (UseCapturedNS_ and self.typeOfResource_nsprefix_) else ''
            typeOfResource_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeOfResource', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('otherType', node)
        if value is not None and 'otherType' not in already_processed:
            already_processed.add('otherType')
            self.otherType = value
        value = find_attr_value_('otherTypeAuth', node)
        if value is not None and 'otherTypeAuth' not in already_processed:
            already_processed.add('otherTypeAuth')
            self.otherTypeAuth = value
        value = find_attr_value_('otherTypeAuthURI', node)
        if value is not None and 'otherTypeAuthURI' not in already_processed:
            already_processed.add('otherTypeAuthURI')
            self.otherTypeAuthURI = value
        value = find_attr_value_('otherTypeURI', node)
        if value is not None and 'otherTypeURI' not in already_processed:
            already_processed.add('otherTypeURI')
            self.otherTypeURI = value
        value = find_attr_value_('displayLabel', node)
        if value is not None and 'displayLabel' not in already_processed:
            already_processed.add('displayLabel')
            self.displayLabel = value
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.add('role')
            self.role = value
        value = find_attr_value_('arcrole', node)
        if value is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            self.arcrole = value
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.add('title')
            self.title = value
        value = find_attr_value_('show', node)
        if value is not None and 'show' not in already_processed:
            already_processed.add('show')
            self.show = value
        value = find_attr_value_('actuate', node)
        if value is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            self.actuate = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'abstract':
            obj_ = abstractDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.abstract.append(obj_)
            obj_.original_tagname_ = 'abstract'
        elif nodeName_ == 'accessCondition':
            obj_ = accessConditionDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.accessCondition.append(obj_)
            obj_.original_tagname_ = 'accessCondition'
        elif nodeName_ == 'classification':
            obj_ = classificationDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.classification.append(obj_)
            obj_.original_tagname_ = 'classification'
        elif nodeName_ == 'extension':
            class_obj_ = self.get_class_obj_(child_, extensionDefinition)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.extension.append(obj_)
            obj_.original_tagname_ = 'extension'
        elif nodeName_ == 'genre':
            obj_ = genreDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.genre.append(obj_)
            obj_.original_tagname_ = 'genre'
        elif nodeName_ == 'identifier':
            obj_ = identifierDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identifier.append(obj_)
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'language':
            obj_ = languageDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.language.append(obj_)
            obj_.original_tagname_ = 'language'
        elif nodeName_ == 'location':
            obj_ = locationDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.location.append(obj_)
            obj_.original_tagname_ = 'location'
        elif nodeName_ == 'name':
            obj_ = nameDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.name.append(obj_)
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'note':
            obj_ = noteDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.note.append(obj_)
            obj_.original_tagname_ = 'note'
        elif nodeName_ == 'originInfo':
            obj_ = originInfoDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.originInfo.append(obj_)
            obj_.original_tagname_ = 'originInfo'
        elif nodeName_ == 'part':
            obj_ = partDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.part.append(obj_)
            obj_.original_tagname_ = 'part'
        elif nodeName_ == 'physicalDescription':
            obj_ = physicalDescriptionDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.physicalDescription.append(obj_)
            obj_.original_tagname_ = 'physicalDescription'
        elif nodeName_ == 'recordInfo':
            obj_ = recordInfoDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.recordInfo.append(obj_)
            obj_.original_tagname_ = 'recordInfo'
        elif nodeName_ == 'relatedItem':
            obj_ = relatedItemDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.relatedItem.append(obj_)
            obj_.original_tagname_ = 'relatedItem'
        elif nodeName_ == 'subject':
            obj_ = subjectDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subject.append(obj_)
            obj_.original_tagname_ = 'subject'
        elif nodeName_ == 'tableOfContents':
            obj_ = tableOfContentsDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.tableOfContents.append(obj_)
            obj_.original_tagname_ = 'tableOfContents'
        elif nodeName_ == 'targetAudience':
            obj_ = targetAudienceDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.targetAudience.append(obj_)
            obj_.original_tagname_ = 'targetAudience'
        elif nodeName_ == 'titleInfo':
            obj_ = titleInfoDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.titleInfo.append(obj_)
            obj_.original_tagname_ = 'titleInfo'
        elif nodeName_ == 'typeOfResource':
            obj_ = typeOfResourceDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeOfResource.append(obj_)
            obj_.original_tagname_ = 'typeOfResource'
# end class relatedItemDefinition


class subjectDefinition(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, displayLabel=None, altRepGroup=None, usage='primary', authority=None, authorityURI=None, valueURI=None, lang=None, script=None, transliteration=None, type_='simple', href=None, role=None, arcrole=None, title=None, show=None, actuate=None, topic=None, geographic=None, temporal=None, titleInfo=None, name=None, geographicCode=None, hierarchicalGeographic=None, cartographics=None, occupation=None, genre=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.displayLabel = _cast(None, displayLabel)
        self.displayLabel_nsprefix_ = None
        self.altRepGroup = _cast(None, altRepGroup)
        self.altRepGroup_nsprefix_ = None
        self.usage = _cast(None, usage)
        self.usage_nsprefix_ = None
        self.authority = _cast(None, authority)
        self.authority_nsprefix_ = None
        self.authorityURI = _cast(None, authorityURI)
        self.authorityURI_nsprefix_ = None
        self.valueURI = _cast(None, valueURI)
        self.valueURI_nsprefix_ = None
        self.lang = _cast(None, lang)
        self.lang_nsprefix_ = None
        self.lang = _cast(None, lang)
        self.lang_nsprefix_ = None
        self.script = _cast(None, script)
        self.script_nsprefix_ = None
        self.transliteration = _cast(None, transliteration)
        self.transliteration_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.href = _cast(None, href)
        self.href_nsprefix_ = None
        self.role = _cast(None, role)
        self.role_nsprefix_ = None
        self.arcrole = _cast(None, arcrole)
        self.arcrole_nsprefix_ = None
        self.title = _cast(None, title)
        self.title_nsprefix_ = None
        self.show = _cast(None, show)
        self.show_nsprefix_ = None
        self.actuate = _cast(None, actuate)
        self.actuate_nsprefix_ = None
        if topic is None:
            self.topic = []
        else:
            self.topic = topic
        self.topic_nsprefix_ = None
        if geographic is None:
            self.geographic = []
        else:
            self.geographic = geographic
        self.geographic_nsprefix_ = None
        if temporal is None:
            self.temporal = []
        else:
            self.temporal = temporal
        self.temporal_nsprefix_ = None
        if titleInfo is None:
            self.titleInfo = []
        else:
            self.titleInfo = titleInfo
        self.titleInfo_nsprefix_ = None
        if name is None:
            self.name = []
        else:
            self.name = name
        self.name_nsprefix_ = None
        if geographicCode is None:
            self.geographicCode = []
        else:
            self.geographicCode = geographicCode
        self.geographicCode_nsprefix_ = None
        if hierarchicalGeographic is None:
            self.hierarchicalGeographic = []
        else:
            self.hierarchicalGeographic = hierarchicalGeographic
        self.hierarchicalGeographic_nsprefix_ = None
        if cartographics is None:
            self.cartographics = []
        else:
            self.cartographics = cartographics
        self.cartographics_nsprefix_ = None
        if occupation is None:
            self.occupation = []
        else:
            self.occupation = occupation
        self.occupation_nsprefix_ = None
        if genre is None:
            self.genre = []
        else:
            self.genre = genre
        self.genre_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, subjectDefinition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if subjectDefinition.subclass:
            return subjectDefinition.subclass(*args_, **kwargs_)
        else:
            return subjectDefinition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_topic(self):
        return self.topic
    def set_topic(self, topic):
        self.topic = topic
    def add_topic(self, value):
        self.topic.append(value)
    def insert_topic_at(self, index, value):
        self.topic.insert(index, value)
    def replace_topic_at(self, index, value):
        self.topic[index] = value
    def get_geographic(self):
        return self.geographic
    def set_geographic(self, geographic):
        self.geographic = geographic
    def add_geographic(self, value):
        self.geographic.append(value)
    def insert_geographic_at(self, index, value):
        self.geographic.insert(index, value)
    def replace_geographic_at(self, index, value):
        self.geographic[index] = value
    def get_temporal(self):
        return self.temporal
    def set_temporal(self, temporal):
        self.temporal = temporal
    def add_temporal(self, value):
        self.temporal.append(value)
    def insert_temporal_at(self, index, value):
        self.temporal.insert(index, value)
    def replace_temporal_at(self, index, value):
        self.temporal[index] = value
    def get_titleInfo(self):
        return self.titleInfo
    def set_titleInfo(self, titleInfo):
        self.titleInfo = titleInfo
    def add_titleInfo(self, value):
        self.titleInfo.append(value)
    def insert_titleInfo_at(self, index, value):
        self.titleInfo.insert(index, value)
    def replace_titleInfo_at(self, index, value):
        self.titleInfo[index] = value
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def add_name(self, value):
        self.name.append(value)
    def insert_name_at(self, index, value):
        self.name.insert(index, value)
    def replace_name_at(self, index, value):
        self.name[index] = value
    def get_geographicCode(self):
        return self.geographicCode
    def set_geographicCode(self, geographicCode):
        self.geographicCode = geographicCode
    def add_geographicCode(self, value):
        self.geographicCode.append(value)
    def insert_geographicCode_at(self, index, value):
        self.geographicCode.insert(index, value)
    def replace_geographicCode_at(self, index, value):
        self.geographicCode[index] = value
    def get_hierarchicalGeographic(self):
        return self.hierarchicalGeographic
    def set_hierarchicalGeographic(self, hierarchicalGeographic):
        self.hierarchicalGeographic = hierarchicalGeographic
    def add_hierarchicalGeographic(self, value):
        self.hierarchicalGeographic.append(value)
    def insert_hierarchicalGeographic_at(self, index, value):
        self.hierarchicalGeographic.insert(index, value)
    def replace_hierarchicalGeographic_at(self, index, value):
        self.hierarchicalGeographic[index] = value
    def get_cartographics(self):
        return self.cartographics
    def set_cartographics(self, cartographics):
        self.cartographics = cartographics
    def add_cartographics(self, value):
        self.cartographics.append(value)
    def insert_cartographics_at(self, index, value):
        self.cartographics.insert(index, value)
    def replace_cartographics_at(self, index, value):
        self.cartographics[index] = value
    def get_occupation(self):
        return self.occupation
    def set_occupation(self, occupation):
        self.occupation = occupation
    def add_occupation(self, value):
        self.occupation.append(value)
    def insert_occupation_at(self, index, value):
        self.occupation.insert(index, value)
    def replace_occupation_at(self, index, value):
        self.occupation[index] = value
    def get_genre(self):
        return self.genre
    def set_genre(self, genre):
        self.genre = genre
    def add_genre(self, value):
        self.genre.append(value)
    def insert_genre_at(self, index, value):
        self.genre.insert(index, value)
    def replace_genre_at(self, index, value):
        self.genre[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_displayLabel(self):
        return self.displayLabel
    def set_displayLabel(self, displayLabel):
        self.displayLabel = displayLabel
    def get_altRepGroup(self):
        return self.altRepGroup
    def set_altRepGroup(self, altRepGroup):
        self.altRepGroup = altRepGroup
    def get_usage(self):
        return self.usage
    def set_usage(self, usage):
        self.usage = usage
    def get_authority(self):
        return self.authority
    def set_authority(self, authority):
        self.authority = authority
    def get_authorityURI(self):
        return self.authorityURI
    def set_authorityURI(self, authorityURI):
        self.authorityURI = authorityURI
    def get_valueURI(self):
        return self.valueURI
    def set_valueURI(self, valueURI):
        self.valueURI = valueURI
    def get_lang(self):
        return self.lang
    def set_lang(self, lang):
        self.lang = lang
    def get_lang(self):
        return self.lang
    def set_lang(self, lang):
        self.lang = lang
    def get_script(self):
        return self.script
    def set_script(self, script):
        self.script = script
    def get_transliteration(self):
        return self.transliteration
    def set_transliteration(self, transliteration):
        self.transliteration = transliteration
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_href(self):
        return self.href
    def set_href(self, href):
        self.href = href
    def get_role(self):
        return self.role
    def set_role(self, role):
        self.role = role
    def get_arcrole(self):
        return self.arcrole
    def set_arcrole(self, arcrole):
        self.arcrole = arcrole
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def get_show(self):
        return self.show
    def set_show(self, show):
        self.show = show
    def get_actuate(self):
        return self.actuate
    def set_actuate(self, actuate):
        self.actuate = actuate
    def hasContent_(self):
        if (
            self.topic or
            self.geographic or
            self.temporal or
            self.titleInfo or
            self.name or
            self.geographicCode or
            self.hierarchicalGeographic or
            self.cartographics or
            self.occupation or
            self.genre
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='subjectDefinition', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('subjectDefinition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='subjectDefinition')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='subjectDefinition', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='subjectDefinition'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.displayLabel is not None and 'displayLabel' not in already_processed:
            already_processed.add('displayLabel')
            outfile.write(' displayLabel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.displayLabel), input_name='displayLabel')), ))
        if self.altRepGroup is not None and 'altRepGroup' not in already_processed:
            already_processed.add('altRepGroup')
            outfile.write(' altRepGroup=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.altRepGroup), input_name='altRepGroup')), ))
        if self.usage != "primary" and 'usage' not in already_processed:
            already_processed.add('usage')
            outfile.write(' usage=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.usage), input_name='usage')), ))
        if self.authority is not None and 'authority' not in already_processed:
            already_processed.add('authority')
            outfile.write(' authority=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.authority), input_name='authority')), ))
        if self.authorityURI is not None and 'authorityURI' not in already_processed:
            already_processed.add('authorityURI')
            outfile.write(' authorityURI=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.authorityURI), input_name='authorityURI')), ))
        if self.valueURI is not None and 'valueURI' not in already_processed:
            already_processed.add('valueURI')
            outfile.write(' valueURI=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.valueURI), input_name='valueURI')), ))
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lang), input_name='lang')), ))
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lang), input_name='lang')), ))
        if self.script is not None and 'script' not in already_processed:
            already_processed.add('script')
            outfile.write(' script=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.script), input_name='script')), ))
        if self.transliteration is not None and 'transliteration' not in already_processed:
            already_processed.add('transliteration')
            outfile.write(' transliteration=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.transliteration), input_name='transliteration')), ))
        if self.type_ != "simple" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (quote_attrib(self.href), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.add('role')
            outfile.write(' role=%s' % (quote_attrib(self.role), ))
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            outfile.write(' arcrole=%s' % (quote_attrib(self.arcrole), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.add('title')
            outfile.write(' title=%s' % (quote_attrib(self.title), ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.add('show')
            outfile.write(' show=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.show), input_name='show')), ))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            outfile.write(' actuate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.actuate), input_name='actuate')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='subjectDefinition', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for topic_ in self.topic:
            namespaceprefix_ = self.topic_nsprefix_ + ':' if (UseCapturedNS_ and self.topic_nsprefix_) else ''
            topic_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='topic', pretty_print=pretty_print)
        for geographic_ in self.geographic:
            namespaceprefix_ = self.geographic_nsprefix_ + ':' if (UseCapturedNS_ and self.geographic_nsprefix_) else ''
            geographic_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='geographic', pretty_print=pretty_print)
        for temporal_ in self.temporal:
            namespaceprefix_ = self.temporal_nsprefix_ + ':' if (UseCapturedNS_ and self.temporal_nsprefix_) else ''
            temporal_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='temporal', pretty_print=pretty_print)
        for titleInfo_ in self.titleInfo:
            namespaceprefix_ = self.titleInfo_nsprefix_ + ':' if (UseCapturedNS_ and self.titleInfo_nsprefix_) else ''
            titleInfo_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='titleInfo', pretty_print=pretty_print)
        for name_ in self.name:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            name_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='name', pretty_print=pretty_print)
        for geographicCode_ in self.geographicCode:
            namespaceprefix_ = self.geographicCode_nsprefix_ + ':' if (UseCapturedNS_ and self.geographicCode_nsprefix_) else ''
            geographicCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='geographicCode', pretty_print=pretty_print)
        for hierarchicalGeographic_ in self.hierarchicalGeographic:
            namespaceprefix_ = self.hierarchicalGeographic_nsprefix_ + ':' if (UseCapturedNS_ and self.hierarchicalGeographic_nsprefix_) else ''
            hierarchicalGeographic_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='hierarchicalGeographic', pretty_print=pretty_print)
        for cartographics_ in self.cartographics:
            namespaceprefix_ = self.cartographics_nsprefix_ + ':' if (UseCapturedNS_ and self.cartographics_nsprefix_) else ''
            cartographics_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='cartographics', pretty_print=pretty_print)
        for occupation_ in self.occupation:
            namespaceprefix_ = self.occupation_nsprefix_ + ':' if (UseCapturedNS_ and self.occupation_nsprefix_) else ''
            occupation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='occupation', pretty_print=pretty_print)
        for genre_ in self.genre:
            namespaceprefix_ = self.genre_nsprefix_ + ':' if (UseCapturedNS_ and self.genre_nsprefix_) else ''
            genre_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='genre', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('displayLabel', node)
        if value is not None and 'displayLabel' not in already_processed:
            already_processed.add('displayLabel')
            self.displayLabel = value
        value = find_attr_value_('altRepGroup', node)
        if value is not None and 'altRepGroup' not in already_processed:
            already_processed.add('altRepGroup')
            self.altRepGroup = value
        value = find_attr_value_('usage', node)
        if value is not None and 'usage' not in already_processed:
            already_processed.add('usage')
            self.usage = value
        value = find_attr_value_('authority', node)
        if value is not None and 'authority' not in already_processed:
            already_processed.add('authority')
            self.authority = value
        value = find_attr_value_('authorityURI', node)
        if value is not None and 'authorityURI' not in already_processed:
            already_processed.add('authorityURI')
            self.authorityURI = value
        value = find_attr_value_('valueURI', node)
        if value is not None and 'valueURI' not in already_processed:
            already_processed.add('valueURI')
            self.valueURI = value
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        value = find_attr_value_('script', node)
        if value is not None and 'script' not in already_processed:
            already_processed.add('script')
            self.script = value
        value = find_attr_value_('transliteration', node)
        if value is not None and 'transliteration' not in already_processed:
            already_processed.add('transliteration')
            self.transliteration = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.add('role')
            self.role = value
        value = find_attr_value_('arcrole', node)
        if value is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            self.arcrole = value
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.add('title')
            self.title = value
        value = find_attr_value_('show', node)
        if value is not None and 'show' not in already_processed:
            already_processed.add('show')
            self.show = value
        value = find_attr_value_('actuate', node)
        if value is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            self.actuate = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'topic':
            class_obj_ = self.get_class_obj_(child_, stringPlusLanguagePlusAuthority)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.topic.append(obj_)
            obj_.original_tagname_ = 'topic'
        elif nodeName_ == 'geographic':
            class_obj_ = self.get_class_obj_(child_, stringPlusLanguagePlusAuthority)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.geographic.append(obj_)
            obj_.original_tagname_ = 'geographic'
        elif nodeName_ == 'temporal':
            obj_ = temporalDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.temporal.append(obj_)
            obj_.original_tagname_ = 'temporal'
        elif nodeName_ == 'titleInfo':
            obj_ = subjectTitleInfoDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.titleInfo.append(obj_)
            obj_.original_tagname_ = 'titleInfo'
        elif nodeName_ == 'name':
            obj_ = subjectNameDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.name.append(obj_)
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'geographicCode':
            obj_ = geographicCodeDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.geographicCode.append(obj_)
            obj_.original_tagname_ = 'geographicCode'
        elif nodeName_ == 'hierarchicalGeographic':
            obj_ = hierarchicalGeographicDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.hierarchicalGeographic.append(obj_)
            obj_.original_tagname_ = 'hierarchicalGeographic'
        elif nodeName_ == 'cartographics':
            obj_ = cartographicsDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.cartographics.append(obj_)
            obj_.original_tagname_ = 'cartographics'
        elif nodeName_ == 'occupation':
            class_obj_ = self.get_class_obj_(child_, stringPlusLanguagePlusAuthority)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.occupation.append(obj_)
            obj_.original_tagname_ = 'occupation'
        elif nodeName_ == 'genre':
            obj_ = genreDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.genre.append(obj_)
            obj_.original_tagname_ = 'genre'
# end class subjectDefinition


class subjectTitleInfoDefinition(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, displayLabel=None, type_='simple', authority=None, authorityURI=None, valueURI=None, href=None, role=None, arcrole=None, title_attr=None, show=None, actuate=None, lang=None, script=None, transliteration=None, title=None, subTitle=None, partNumber=None, partName=None, nonSort=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.displayLabel = _cast(None, displayLabel)
        self.displayLabel_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.authority = _cast(None, authority)
        self.authority_nsprefix_ = None
        self.authorityURI = _cast(None, authorityURI)
        self.authorityURI_nsprefix_ = None
        self.valueURI = _cast(None, valueURI)
        self.valueURI_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.href = _cast(None, href)
        self.href_nsprefix_ = None
        self.role = _cast(None, role)
        self.role_nsprefix_ = None
        self.arcrole = _cast(None, arcrole)
        self.arcrole_nsprefix_ = None
        self.title_attr = _cast(None, title_attr)
        self.title_attr_nsprefix_ = None
        self.show = _cast(None, show)
        self.show_nsprefix_ = None
        self.actuate = _cast(None, actuate)
        self.actuate_nsprefix_ = None
        self.lang = _cast(None, lang)
        self.lang_nsprefix_ = None
        self.lang = _cast(None, lang)
        self.lang_nsprefix_ = None
        self.script = _cast(None, script)
        self.script_nsprefix_ = None
        self.transliteration = _cast(None, transliteration)
        self.transliteration_nsprefix_ = None
        if title is None:
            self.title = []
        else:
            self.title = title
        self.title_nsprefix_ = None
        if subTitle is None:
            self.subTitle = []
        else:
            self.subTitle = subTitle
        self.subTitle_nsprefix_ = None
        if partNumber is None:
            self.partNumber = []
        else:
            self.partNumber = partNumber
        self.partNumber_nsprefix_ = None
        if partName is None:
            self.partName = []
        else:
            self.partName = partName
        self.partName_nsprefix_ = None
        if nonSort is None:
            self.nonSort = []
        else:
            self.nonSort = nonSort
        self.nonSort_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, subjectTitleInfoDefinition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if subjectTitleInfoDefinition.subclass:
            return subjectTitleInfoDefinition.subclass(*args_, **kwargs_)
        else:
            return subjectTitleInfoDefinition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def add_title(self, value):
        self.title.append(value)
    def insert_title_at(self, index, value):
        self.title.insert(index, value)
    def replace_title_at(self, index, value):
        self.title[index] = value
    def get_subTitle(self):
        return self.subTitle
    def set_subTitle(self, subTitle):
        self.subTitle = subTitle
    def add_subTitle(self, value):
        self.subTitle.append(value)
    def insert_subTitle_at(self, index, value):
        self.subTitle.insert(index, value)
    def replace_subTitle_at(self, index, value):
        self.subTitle[index] = value
    def get_partNumber(self):
        return self.partNumber
    def set_partNumber(self, partNumber):
        self.partNumber = partNumber
    def add_partNumber(self, value):
        self.partNumber.append(value)
    def insert_partNumber_at(self, index, value):
        self.partNumber.insert(index, value)
    def replace_partNumber_at(self, index, value):
        self.partNumber[index] = value
    def get_partName(self):
        return self.partName
    def set_partName(self, partName):
        self.partName = partName
    def add_partName(self, value):
        self.partName.append(value)
    def insert_partName_at(self, index, value):
        self.partName.insert(index, value)
    def replace_partName_at(self, index, value):
        self.partName[index] = value
    def get_nonSort(self):
        return self.nonSort
    def set_nonSort(self, nonSort):
        self.nonSort = nonSort
    def add_nonSort(self, value):
        self.nonSort.append(value)
    def insert_nonSort_at(self, index, value):
        self.nonSort.insert(index, value)
    def replace_nonSort_at(self, index, value):
        self.nonSort[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_displayLabel(self):
        return self.displayLabel
    def set_displayLabel(self, displayLabel):
        self.displayLabel = displayLabel
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_authority(self):
        return self.authority
    def set_authority(self, authority):
        self.authority = authority
    def get_authorityURI(self):
        return self.authorityURI
    def set_authorityURI(self, authorityURI):
        self.authorityURI = authorityURI
    def get_valueURI(self):
        return self.valueURI
    def set_valueURI(self, valueURI):
        self.valueURI = valueURI
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_href(self):
        return self.href
    def set_href(self, href):
        self.href = href
    def get_role(self):
        return self.role
    def set_role(self, role):
        self.role = role
    def get_arcrole(self):
        return self.arcrole
    def set_arcrole(self, arcrole):
        self.arcrole = arcrole
    def get_title_attr(self):
        return self.title_attr
    def set_title_attr(self, title_attr):
        self.title_attr = title_attr
    def get_show(self):
        return self.show
    def set_show(self, show):
        self.show = show
    def get_actuate(self):
        return self.actuate
    def set_actuate(self, actuate):
        self.actuate = actuate
    def get_lang(self):
        return self.lang
    def set_lang(self, lang):
        self.lang = lang
    def get_lang(self):
        return self.lang
    def set_lang(self, lang):
        self.lang = lang
    def get_script(self):
        return self.script
    def set_script(self, script):
        self.script = script
    def get_transliteration(self):
        return self.transliteration
    def set_transliteration(self, transliteration):
        self.transliteration = transliteration
    def hasContent_(self):
        if (
            self.title or
            self.subTitle or
            self.partNumber or
            self.partName or
            self.nonSort
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='subjectTitleInfoDefinition', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('subjectTitleInfoDefinition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='subjectTitleInfoDefinition')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='subjectTitleInfoDefinition', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='subjectTitleInfoDefinition'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.displayLabel is not None and 'displayLabel' not in already_processed:
            already_processed.add('displayLabel')
            outfile.write(' displayLabel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.displayLabel), input_name='displayLabel')), ))
        if self.type_ != "simple" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.authority is not None and 'authority' not in already_processed:
            already_processed.add('authority')
            outfile.write(' authority=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.authority), input_name='authority')), ))
        if self.authorityURI is not None and 'authorityURI' not in already_processed:
            already_processed.add('authorityURI')
            outfile.write(' authorityURI=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.authorityURI), input_name='authorityURI')), ))
        if self.valueURI is not None and 'valueURI' not in already_processed:
            already_processed.add('valueURI')
            outfile.write(' valueURI=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.valueURI), input_name='valueURI')), ))
        if self.type_ != "simple" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (quote_attrib(self.href), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.add('role')
            outfile.write(' role=%s' % (quote_attrib(self.role), ))
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            outfile.write(' arcrole=%s' % (quote_attrib(self.arcrole), ))
        if self.title_attr is not None and 'title_attr' not in already_processed:
            already_processed.add('title_attr')
            outfile.write(' title=%s' % (quote_attrib(self.title_attr), ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.add('show')
            outfile.write(' show=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.show), input_name='show')), ))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            outfile.write(' actuate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.actuate), input_name='actuate')), ))
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lang), input_name='lang')), ))
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lang), input_name='lang')), ))
        if self.script is not None and 'script' not in already_processed:
            already_processed.add('script')
            outfile.write(' script=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.script), input_name='script')), ))
        if self.transliteration is not None and 'transliteration' not in already_processed:
            already_processed.add('transliteration')
            outfile.write(' transliteration=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.transliteration), input_name='transliteration')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='subjectTitleInfoDefinition', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for title_ in self.title:
            namespaceprefix_ = self.title_nsprefix_ + ':' if (UseCapturedNS_ and self.title_nsprefix_) else ''
            title_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='title', pretty_print=pretty_print)
        for subTitle_ in self.subTitle:
            namespaceprefix_ = self.subTitle_nsprefix_ + ':' if (UseCapturedNS_ and self.subTitle_nsprefix_) else ''
            subTitle_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subTitle', pretty_print=pretty_print)
        for partNumber_ in self.partNumber:
            namespaceprefix_ = self.partNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.partNumber_nsprefix_) else ''
            partNumber_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='partNumber', pretty_print=pretty_print)
        for partName_ in self.partName:
            namespaceprefix_ = self.partName_nsprefix_ + ':' if (UseCapturedNS_ and self.partName_nsprefix_) else ''
            partName_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='partName', pretty_print=pretty_print)
        for nonSort_ in self.nonSort:
            namespaceprefix_ = self.nonSort_nsprefix_ + ':' if (UseCapturedNS_ and self.nonSort_nsprefix_) else ''
            nonSort_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='nonSort', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('displayLabel', node)
        if value is not None and 'displayLabel' not in already_processed:
            already_processed.add('displayLabel')
            self.displayLabel = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('authority', node)
        if value is not None and 'authority' not in already_processed:
            already_processed.add('authority')
            self.authority = value
        value = find_attr_value_('authorityURI', node)
        if value is not None and 'authorityURI' not in already_processed:
            already_processed.add('authorityURI')
            self.authorityURI = value
        value = find_attr_value_('valueURI', node)
        if value is not None and 'valueURI' not in already_processed:
            already_processed.add('valueURI')
            self.valueURI = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.add('role')
            self.role = value
        value = find_attr_value_('arcrole', node)
        if value is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            self.arcrole = value
        value = find_attr_value_('title', node)
        if value is not None and 'title_attr' not in already_processed:
            already_processed.add('title_attr')
            self.title_attr = value
        value = find_attr_value_('show', node)
        if value is not None and 'show' not in already_processed:
            already_processed.add('show')
            self.show = value
        value = find_attr_value_('actuate', node)
        if value is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            self.actuate = value
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        value = find_attr_value_('script', node)
        if value is not None and 'script' not in already_processed:
            already_processed.add('script')
            self.script = value
        value = find_attr_value_('transliteration', node)
        if value is not None and 'transliteration' not in already_processed:
            already_processed.add('transliteration')
            self.transliteration = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'title':
            class_obj_ = self.get_class_obj_(child_, stringPlusLanguage)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.title.append(obj_)
            obj_.original_tagname_ = 'title'
        elif nodeName_ == 'subTitle':
            class_obj_ = self.get_class_obj_(child_, stringPlusLanguage)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subTitle.append(obj_)
            obj_.original_tagname_ = 'subTitle'
        elif nodeName_ == 'partNumber':
            class_obj_ = self.get_class_obj_(child_, stringPlusLanguage)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.partNumber.append(obj_)
            obj_.original_tagname_ = 'partNumber'
        elif nodeName_ == 'partName':
            class_obj_ = self.get_class_obj_(child_, stringPlusLanguage)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.partName.append(obj_)
            obj_.original_tagname_ = 'partName'
        elif nodeName_ == 'nonSort':
            obj_ = nonSort.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.nonSort.append(obj_)
            obj_.original_tagname_ = 'nonSort'
# end class subjectTitleInfoDefinition


class subjectNameDefinition(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_='simple', ID=None, displayLabel=None, authority=None, authorityURI=None, valueURI=None, href=None, role_attr=None, arcrole=None, title=None, show=None, actuate=None, lang=None, script=None, transliteration=None, namePart=None, displayForm=None, affiliation=None, role=None, description=None, nameIdentifier=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.displayLabel = _cast(None, displayLabel)
        self.displayLabel_nsprefix_ = None
        self.authority = _cast(None, authority)
        self.authority_nsprefix_ = None
        self.authorityURI = _cast(None, authorityURI)
        self.authorityURI_nsprefix_ = None
        self.valueURI = _cast(None, valueURI)
        self.valueURI_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.href = _cast(None, href)
        self.href_nsprefix_ = None
        self.role_attr = _cast(None, role_attr)
        self.role_attr_nsprefix_ = None
        self.arcrole = _cast(None, arcrole)
        self.arcrole_nsprefix_ = None
        self.title = _cast(None, title)
        self.title_nsprefix_ = None
        self.show = _cast(None, show)
        self.show_nsprefix_ = None
        self.actuate = _cast(None, actuate)
        self.actuate_nsprefix_ = None
        self.lang = _cast(None, lang)
        self.lang_nsprefix_ = None
        self.lang = _cast(None, lang)
        self.lang_nsprefix_ = None
        self.script = _cast(None, script)
        self.script_nsprefix_ = None
        self.transliteration = _cast(None, transliteration)
        self.transliteration_nsprefix_ = None
        if namePart is None:
            self.namePart = []
        else:
            self.namePart = namePart
        self.namePart_nsprefix_ = None
        if displayForm is None:
            self.displayForm = []
        else:
            self.displayForm = displayForm
        self.displayForm_nsprefix_ = None
        if affiliation is None:
            self.affiliation = []
        else:
            self.affiliation = affiliation
        self.affiliation_nsprefix_ = None
        if role is None:
            self.role = []
        else:
            self.role = role
        self.role_nsprefix_ = None
        if description is None:
            self.description = []
        else:
            self.description = description
        self.description_nsprefix_ = None
        if nameIdentifier is None:
            self.nameIdentifier = []
        else:
            self.nameIdentifier = nameIdentifier
        self.nameIdentifier_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, subjectNameDefinition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if subjectNameDefinition.subclass:
            return subjectNameDefinition.subclass(*args_, **kwargs_)
        else:
            return subjectNameDefinition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_namePart(self):
        return self.namePart
    def set_namePart(self, namePart):
        self.namePart = namePart
    def add_namePart(self, value):
        self.namePart.append(value)
    def insert_namePart_at(self, index, value):
        self.namePart.insert(index, value)
    def replace_namePart_at(self, index, value):
        self.namePart[index] = value
    def get_displayForm(self):
        return self.displayForm
    def set_displayForm(self, displayForm):
        self.displayForm = displayForm
    def add_displayForm(self, value):
        self.displayForm.append(value)
    def insert_displayForm_at(self, index, value):
        self.displayForm.insert(index, value)
    def replace_displayForm_at(self, index, value):
        self.displayForm[index] = value
    def get_affiliation(self):
        return self.affiliation
    def set_affiliation(self, affiliation):
        self.affiliation = affiliation
    def add_affiliation(self, value):
        self.affiliation.append(value)
    def insert_affiliation_at(self, index, value):
        self.affiliation.insert(index, value)
    def replace_affiliation_at(self, index, value):
        self.affiliation[index] = value
    def get_role(self):
        return self.role
    def set_role(self, role):
        self.role = role
    def add_role(self, value):
        self.role.append(value)
    def insert_role_at(self, index, value):
        self.role.insert(index, value)
    def replace_role_at(self, index, value):
        self.role[index] = value
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def add_description(self, value):
        self.description.append(value)
    def insert_description_at(self, index, value):
        self.description.insert(index, value)
    def replace_description_at(self, index, value):
        self.description[index] = value
    def get_nameIdentifier(self):
        return self.nameIdentifier
    def set_nameIdentifier(self, nameIdentifier):
        self.nameIdentifier = nameIdentifier
    def add_nameIdentifier(self, value):
        self.nameIdentifier.append(value)
    def insert_nameIdentifier_at(self, index, value):
        self.nameIdentifier.insert(index, value)
    def replace_nameIdentifier_at(self, index, value):
        self.nameIdentifier[index] = value
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_displayLabel(self):
        return self.displayLabel
    def set_displayLabel(self, displayLabel):
        self.displayLabel = displayLabel
    def get_authority(self):
        return self.authority
    def set_authority(self, authority):
        self.authority = authority
    def get_authorityURI(self):
        return self.authorityURI
    def set_authorityURI(self, authorityURI):
        self.authorityURI = authorityURI
    def get_valueURI(self):
        return self.valueURI
    def set_valueURI(self, valueURI):
        self.valueURI = valueURI
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_href(self):
        return self.href
    def set_href(self, href):
        self.href = href
    def get_role_attr(self):
        return self.role_attr
    def set_role_attr(self, role_attr):
        self.role_attr = role_attr
    def get_arcrole(self):
        return self.arcrole
    def set_arcrole(self, arcrole):
        self.arcrole = arcrole
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def get_show(self):
        return self.show
    def set_show(self, show):
        self.show = show
    def get_actuate(self):
        return self.actuate
    def set_actuate(self, actuate):
        self.actuate = actuate
    def get_lang(self):
        return self.lang
    def set_lang(self, lang):
        self.lang = lang
    def get_lang(self):
        return self.lang
    def set_lang(self, lang):
        self.lang = lang
    def get_script(self):
        return self.script
    def set_script(self, script):
        self.script = script
    def get_transliteration(self):
        return self.transliteration
    def set_transliteration(self, transliteration):
        self.transliteration = transliteration
    def hasContent_(self):
        if (
            self.namePart or
            self.displayForm or
            self.affiliation or
            self.role or
            self.description or
            self.nameIdentifier
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='subjectNameDefinition', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('subjectNameDefinition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='subjectNameDefinition')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='subjectNameDefinition', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='subjectNameDefinition'):
        if self.type_ != "simple" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.displayLabel is not None and 'displayLabel' not in already_processed:
            already_processed.add('displayLabel')
            outfile.write(' displayLabel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.displayLabel), input_name='displayLabel')), ))
        if self.authority is not None and 'authority' not in already_processed:
            already_processed.add('authority')
            outfile.write(' authority=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.authority), input_name='authority')), ))
        if self.authorityURI is not None and 'authorityURI' not in already_processed:
            already_processed.add('authorityURI')
            outfile.write(' authorityURI=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.authorityURI), input_name='authorityURI')), ))
        if self.valueURI is not None and 'valueURI' not in already_processed:
            already_processed.add('valueURI')
            outfile.write(' valueURI=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.valueURI), input_name='valueURI')), ))
        if self.type_ != "simple" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (quote_attrib(self.href), ))
        if self.role_attr is not None and 'role_attr' not in already_processed:
            already_processed.add('role_attr')
            outfile.write(' role=%s' % (quote_attrib(self.role_attr), ))
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            outfile.write(' arcrole=%s' % (quote_attrib(self.arcrole), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.add('title')
            outfile.write(' title=%s' % (quote_attrib(self.title), ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.add('show')
            outfile.write(' show=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.show), input_name='show')), ))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            outfile.write(' actuate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.actuate), input_name='actuate')), ))
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lang), input_name='lang')), ))
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lang), input_name='lang')), ))
        if self.script is not None and 'script' not in already_processed:
            already_processed.add('script')
            outfile.write(' script=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.script), input_name='script')), ))
        if self.transliteration is not None and 'transliteration' not in already_processed:
            already_processed.add('transliteration')
            outfile.write(' transliteration=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.transliteration), input_name='transliteration')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='subjectNameDefinition', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for namePart_ in self.namePart:
            namespaceprefix_ = self.namePart_nsprefix_ + ':' if (UseCapturedNS_ and self.namePart_nsprefix_) else ''
            namePart_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='namePart', pretty_print=pretty_print)
        for displayForm_ in self.displayForm:
            namespaceprefix_ = self.displayForm_nsprefix_ + ':' if (UseCapturedNS_ and self.displayForm_nsprefix_) else ''
            displayForm_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='displayForm', pretty_print=pretty_print)
        for affiliation_ in self.affiliation:
            namespaceprefix_ = self.affiliation_nsprefix_ + ':' if (UseCapturedNS_ and self.affiliation_nsprefix_) else ''
            affiliation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='affiliation', pretty_print=pretty_print)
        for role_ in self.role:
            namespaceprefix_ = self.role_nsprefix_ + ':' if (UseCapturedNS_ and self.role_nsprefix_) else ''
            role_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='role', pretty_print=pretty_print)
        for description_ in self.description:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            description_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='description', pretty_print=pretty_print)
        for nameIdentifier_ in self.nameIdentifier:
            namespaceprefix_ = self.nameIdentifier_nsprefix_ + ':' if (UseCapturedNS_ and self.nameIdentifier_nsprefix_) else ''
            nameIdentifier_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='nameIdentifier', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('displayLabel', node)
        if value is not None and 'displayLabel' not in already_processed:
            already_processed.add('displayLabel')
            self.displayLabel = value
        value = find_attr_value_('authority', node)
        if value is not None and 'authority' not in already_processed:
            already_processed.add('authority')
            self.authority = value
        value = find_attr_value_('authorityURI', node)
        if value is not None and 'authorityURI' not in already_processed:
            already_processed.add('authorityURI')
            self.authorityURI = value
        value = find_attr_value_('valueURI', node)
        if value is not None and 'valueURI' not in already_processed:
            already_processed.add('valueURI')
            self.valueURI = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('role', node)
        if value is not None and 'role_attr' not in already_processed:
            already_processed.add('role_attr')
            self.role_attr = value
        value = find_attr_value_('arcrole', node)
        if value is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            self.arcrole = value
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.add('title')
            self.title = value
        value = find_attr_value_('show', node)
        if value is not None and 'show' not in already_processed:
            already_processed.add('show')
            self.show = value
        value = find_attr_value_('actuate', node)
        if value is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            self.actuate = value
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        value = find_attr_value_('script', node)
        if value is not None and 'script' not in already_processed:
            already_processed.add('script')
            self.script = value
        value = find_attr_value_('transliteration', node)
        if value is not None and 'transliteration' not in already_processed:
            already_processed.add('transliteration')
            self.transliteration = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'namePart':
            obj_ = namePartDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.namePart.append(obj_)
            obj_.original_tagname_ = 'namePart'
        elif nodeName_ == 'displayForm':
            class_obj_ = self.get_class_obj_(child_, stringPlusLanguage)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.displayForm.append(obj_)
            obj_.original_tagname_ = 'displayForm'
        elif nodeName_ == 'affiliation':
            class_obj_ = self.get_class_obj_(child_, stringPlusLanguage)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.affiliation.append(obj_)
            obj_.original_tagname_ = 'affiliation'
        elif nodeName_ == 'role':
            obj_ = roleDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.role.append(obj_)
            obj_.original_tagname_ = 'role'
        elif nodeName_ == 'description':
            class_obj_ = self.get_class_obj_(child_, stringPlusLanguage)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.description.append(obj_)
            obj_.original_tagname_ = 'description'
        elif nodeName_ == 'nameIdentifier':
            obj_ = identifierDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.nameIdentifier.append(obj_)
            obj_.original_tagname_ = 'nameIdentifier'
# end class subjectNameDefinition


class hierarchicalGeographicDefinition(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, authority=None, authorityURI=None, valueURI=None, extraTerrestrialArea=None, continent=None, country=None, province=None, region=None, state=None, territory=None, county=None, city=None, citySection=None, island=None, area=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.authority = _cast(None, authority)
        self.authority_nsprefix_ = None
        self.authorityURI = _cast(None, authorityURI)
        self.authorityURI_nsprefix_ = None
        self.valueURI = _cast(None, valueURI)
        self.valueURI_nsprefix_ = None
        if extraTerrestrialArea is None:
            self.extraTerrestrialArea = []
        else:
            self.extraTerrestrialArea = extraTerrestrialArea
        self.extraTerrestrialArea_nsprefix_ = None
        if continent is None:
            self.continent = []
        else:
            self.continent = continent
        self.continent_nsprefix_ = None
        if country is None:
            self.country = []
        else:
            self.country = country
        self.country_nsprefix_ = None
        if province is None:
            self.province = []
        else:
            self.province = province
        self.province_nsprefix_ = None
        if region is None:
            self.region = []
        else:
            self.region = region
        self.region_nsprefix_ = None
        if state is None:
            self.state = []
        else:
            self.state = state
        self.state_nsprefix_ = None
        if territory is None:
            self.territory = []
        else:
            self.territory = territory
        self.territory_nsprefix_ = None
        if county is None:
            self.county = []
        else:
            self.county = county
        self.county_nsprefix_ = None
        if city is None:
            self.city = []
        else:
            self.city = city
        self.city_nsprefix_ = None
        if citySection is None:
            self.citySection = []
        else:
            self.citySection = citySection
        self.citySection_nsprefix_ = None
        if island is None:
            self.island = []
        else:
            self.island = island
        self.island_nsprefix_ = None
        if area is None:
            self.area = []
        else:
            self.area = area
        self.area_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, hierarchicalGeographicDefinition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if hierarchicalGeographicDefinition.subclass:
            return hierarchicalGeographicDefinition.subclass(*args_, **kwargs_)
        else:
            return hierarchicalGeographicDefinition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_extraTerrestrialArea(self):
        return self.extraTerrestrialArea
    def set_extraTerrestrialArea(self, extraTerrestrialArea):
        self.extraTerrestrialArea = extraTerrestrialArea
    def add_extraTerrestrialArea(self, value):
        self.extraTerrestrialArea.append(value)
    def insert_extraTerrestrialArea_at(self, index, value):
        self.extraTerrestrialArea.insert(index, value)
    def replace_extraTerrestrialArea_at(self, index, value):
        self.extraTerrestrialArea[index] = value
    def get_continent(self):
        return self.continent
    def set_continent(self, continent):
        self.continent = continent
    def add_continent(self, value):
        self.continent.append(value)
    def insert_continent_at(self, index, value):
        self.continent.insert(index, value)
    def replace_continent_at(self, index, value):
        self.continent[index] = value
    def get_country(self):
        return self.country
    def set_country(self, country):
        self.country = country
    def add_country(self, value):
        self.country.append(value)
    def insert_country_at(self, index, value):
        self.country.insert(index, value)
    def replace_country_at(self, index, value):
        self.country[index] = value
    def get_province(self):
        return self.province
    def set_province(self, province):
        self.province = province
    def add_province(self, value):
        self.province.append(value)
    def insert_province_at(self, index, value):
        self.province.insert(index, value)
    def replace_province_at(self, index, value):
        self.province[index] = value
    def get_region(self):
        return self.region
    def set_region(self, region):
        self.region = region
    def add_region(self, value):
        self.region.append(value)
    def insert_region_at(self, index, value):
        self.region.insert(index, value)
    def replace_region_at(self, index, value):
        self.region[index] = value
    def get_state(self):
        return self.state
    def set_state(self, state):
        self.state = state
    def add_state(self, value):
        self.state.append(value)
    def insert_state_at(self, index, value):
        self.state.insert(index, value)
    def replace_state_at(self, index, value):
        self.state[index] = value
    def get_territory(self):
        return self.territory
    def set_territory(self, territory):
        self.territory = territory
    def add_territory(self, value):
        self.territory.append(value)
    def insert_territory_at(self, index, value):
        self.territory.insert(index, value)
    def replace_territory_at(self, index, value):
        self.territory[index] = value
    def get_county(self):
        return self.county
    def set_county(self, county):
        self.county = county
    def add_county(self, value):
        self.county.append(value)
    def insert_county_at(self, index, value):
        self.county.insert(index, value)
    def replace_county_at(self, index, value):
        self.county[index] = value
    def get_city(self):
        return self.city
    def set_city(self, city):
        self.city = city
    def add_city(self, value):
        self.city.append(value)
    def insert_city_at(self, index, value):
        self.city.insert(index, value)
    def replace_city_at(self, index, value):
        self.city[index] = value
    def get_citySection(self):
        return self.citySection
    def set_citySection(self, citySection):
        self.citySection = citySection
    def add_citySection(self, value):
        self.citySection.append(value)
    def insert_citySection_at(self, index, value):
        self.citySection.insert(index, value)
    def replace_citySection_at(self, index, value):
        self.citySection[index] = value
    def get_island(self):
        return self.island
    def set_island(self, island):
        self.island = island
    def add_island(self, value):
        self.island.append(value)
    def insert_island_at(self, index, value):
        self.island.insert(index, value)
    def replace_island_at(self, index, value):
        self.island[index] = value
    def get_area(self):
        return self.area
    def set_area(self, area):
        self.area = area
    def add_area(self, value):
        self.area.append(value)
    def insert_area_at(self, index, value):
        self.area.insert(index, value)
    def replace_area_at(self, index, value):
        self.area[index] = value
    def get_authority(self):
        return self.authority
    def set_authority(self, authority):
        self.authority = authority
    def get_authorityURI(self):
        return self.authorityURI
    def set_authorityURI(self, authorityURI):
        self.authorityURI = authorityURI
    def get_valueURI(self):
        return self.valueURI
    def set_valueURI(self, valueURI):
        self.valueURI = valueURI
    def hasContent_(self):
        if (
            self.extraTerrestrialArea or
            self.continent or
            self.country or
            self.province or
            self.region or
            self.state or
            self.territory or
            self.county or
            self.city or
            self.citySection or
            self.island or
            self.area
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='hierarchicalGeographicDefinition', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('hierarchicalGeographicDefinition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='hierarchicalGeographicDefinition')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='hierarchicalGeographicDefinition', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='hierarchicalGeographicDefinition'):
        if self.authority is not None and 'authority' not in already_processed:
            already_processed.add('authority')
            outfile.write(' authority=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.authority), input_name='authority')), ))
        if self.authorityURI is not None and 'authorityURI' not in already_processed:
            already_processed.add('authorityURI')
            outfile.write(' authorityURI=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.authorityURI), input_name='authorityURI')), ))
        if self.valueURI is not None and 'valueURI' not in already_processed:
            already_processed.add('valueURI')
            outfile.write(' valueURI=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.valueURI), input_name='valueURI')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='hierarchicalGeographicDefinition', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for extraTerrestrialArea_ in self.extraTerrestrialArea:
            namespaceprefix_ = self.extraTerrestrialArea_nsprefix_ + ':' if (UseCapturedNS_ and self.extraTerrestrialArea_nsprefix_) else ''
            extraTerrestrialArea_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='extraTerrestrialArea', pretty_print=pretty_print)
        for continent_ in self.continent:
            namespaceprefix_ = self.continent_nsprefix_ + ':' if (UseCapturedNS_ and self.continent_nsprefix_) else ''
            continent_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='continent', pretty_print=pretty_print)
        for country_ in self.country:
            namespaceprefix_ = self.country_nsprefix_ + ':' if (UseCapturedNS_ and self.country_nsprefix_) else ''
            country_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='country', pretty_print=pretty_print)
        for province_ in self.province:
            namespaceprefix_ = self.province_nsprefix_ + ':' if (UseCapturedNS_ and self.province_nsprefix_) else ''
            province_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='province', pretty_print=pretty_print)
        for region_ in self.region:
            namespaceprefix_ = self.region_nsprefix_ + ':' if (UseCapturedNS_ and self.region_nsprefix_) else ''
            region_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='region', pretty_print=pretty_print)
        for state_ in self.state:
            namespaceprefix_ = self.state_nsprefix_ + ':' if (UseCapturedNS_ and self.state_nsprefix_) else ''
            state_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='state', pretty_print=pretty_print)
        for territory_ in self.territory:
            namespaceprefix_ = self.territory_nsprefix_ + ':' if (UseCapturedNS_ and self.territory_nsprefix_) else ''
            territory_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='territory', pretty_print=pretty_print)
        for county_ in self.county:
            namespaceprefix_ = self.county_nsprefix_ + ':' if (UseCapturedNS_ and self.county_nsprefix_) else ''
            county_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='county', pretty_print=pretty_print)
        for city_ in self.city:
            namespaceprefix_ = self.city_nsprefix_ + ':' if (UseCapturedNS_ and self.city_nsprefix_) else ''
            city_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='city', pretty_print=pretty_print)
        for citySection_ in self.citySection:
            namespaceprefix_ = self.citySection_nsprefix_ + ':' if (UseCapturedNS_ and self.citySection_nsprefix_) else ''
            citySection_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='citySection', pretty_print=pretty_print)
        for island_ in self.island:
            namespaceprefix_ = self.island_nsprefix_ + ':' if (UseCapturedNS_ and self.island_nsprefix_) else ''
            island_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='island', pretty_print=pretty_print)
        for area_ in self.area:
            namespaceprefix_ = self.area_nsprefix_ + ':' if (UseCapturedNS_ and self.area_nsprefix_) else ''
            area_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='area', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('authority', node)
        if value is not None and 'authority' not in already_processed:
            already_processed.add('authority')
            self.authority = value
        value = find_attr_value_('authorityURI', node)
        if value is not None and 'authorityURI' not in already_processed:
            already_processed.add('authorityURI')
            self.authorityURI = value
        value = find_attr_value_('valueURI', node)
        if value is not None and 'valueURI' not in already_processed:
            already_processed.add('valueURI')
            self.valueURI = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'extraTerrestrialArea':
            class_obj_ = self.get_class_obj_(child_, hierarchicalPart)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.extraTerrestrialArea.append(obj_)
            obj_.original_tagname_ = 'extraTerrestrialArea'
        elif nodeName_ == 'continent':
            class_obj_ = self.get_class_obj_(child_, hierarchicalPart)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.continent.append(obj_)
            obj_.original_tagname_ = 'continent'
        elif nodeName_ == 'country':
            class_obj_ = self.get_class_obj_(child_, hierarchicalPart)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.country.append(obj_)
            obj_.original_tagname_ = 'country'
        elif nodeName_ == 'province':
            class_obj_ = self.get_class_obj_(child_, stringPlusLanguage)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.province.append(obj_)
            obj_.original_tagname_ = 'province'
        elif nodeName_ == 'region':
            obj_ = regionDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.region.append(obj_)
            obj_.original_tagname_ = 'region'
        elif nodeName_ == 'state':
            class_obj_ = self.get_class_obj_(child_, hierarchicalPart)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.state.append(obj_)
            obj_.original_tagname_ = 'state'
        elif nodeName_ == 'territory':
            class_obj_ = self.get_class_obj_(child_, hierarchicalPart)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.territory.append(obj_)
            obj_.original_tagname_ = 'territory'
        elif nodeName_ == 'county':
            class_obj_ = self.get_class_obj_(child_, hierarchicalPart)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.county.append(obj_)
            obj_.original_tagname_ = 'county'
        elif nodeName_ == 'city':
            class_obj_ = self.get_class_obj_(child_, hierarchicalPart)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.city.append(obj_)
            obj_.original_tagname_ = 'city'
        elif nodeName_ == 'citySection':
            obj_ = citySectionDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.citySection.append(obj_)
            obj_.original_tagname_ = 'citySection'
        elif nodeName_ == 'island':
            class_obj_ = self.get_class_obj_(child_, hierarchicalPart)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.island.append(obj_)
            obj_.original_tagname_ = 'island'
        elif nodeName_ == 'area':
            obj_ = areaDefinition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.area.append(obj_)
            obj_.original_tagname_ = 'area'
# end class hierarchicalGeographicDefinition


class cartographicsDefinition(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, authority=None, authorityURI=None, valueURI=None, scale=None, projection=None, coordinates=None, cartographicExtension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.authority = _cast(None, authority)
        self.authority_nsprefix_ = None
        self.authorityURI = _cast(None, authorityURI)
        self.authorityURI_nsprefix_ = None
        self.valueURI = _cast(None, valueURI)
        self.valueURI_nsprefix_ = None
        self.scale = scale
        self.scale_nsprefix_ = None
        self.projection = projection
        self.projection_nsprefix_ = None
        if coordinates is None:
            self.coordinates = []
        else:
            self.coordinates = coordinates
        self.coordinates_nsprefix_ = None
        if cartographicExtension is None:
            self.cartographicExtension = []
        else:
            self.cartographicExtension = cartographicExtension
        self.cartographicExtension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cartographicsDefinition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cartographicsDefinition.subclass:
            return cartographicsDefinition.subclass(*args_, **kwargs_)
        else:
            return cartographicsDefinition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_scale(self):
        return self.scale
    def set_scale(self, scale):
        self.scale = scale
    def get_projection(self):
        return self.projection
    def set_projection(self, projection):
        self.projection = projection
    def get_coordinates(self):
        return self.coordinates
    def set_coordinates(self, coordinates):
        self.coordinates = coordinates
    def add_coordinates(self, value):
        self.coordinates.append(value)
    def insert_coordinates_at(self, index, value):
        self.coordinates.insert(index, value)
    def replace_coordinates_at(self, index, value):
        self.coordinates[index] = value
    def get_cartographicExtension(self):
        return self.cartographicExtension
    def set_cartographicExtension(self, cartographicExtension):
        self.cartographicExtension = cartographicExtension
    def add_cartographicExtension(self, value):
        self.cartographicExtension.append(value)
    def insert_cartographicExtension_at(self, index, value):
        self.cartographicExtension.insert(index, value)
    def replace_cartographicExtension_at(self, index, value):
        self.cartographicExtension[index] = value
    def get_authority(self):
        return self.authority
    def set_authority(self, authority):
        self.authority = authority
    def get_authorityURI(self):
        return self.authorityURI
    def set_authorityURI(self, authorityURI):
        self.authorityURI = authorityURI
    def get_valueURI(self):
        return self.valueURI
    def set_valueURI(self, valueURI):
        self.valueURI = valueURI
    def hasContent_(self):
        if (
            self.scale is not None or
            self.projection is not None or
            self.coordinates or
            self.cartographicExtension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='cartographicsDefinition', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cartographicsDefinition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='cartographicsDefinition')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='cartographicsDefinition', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='cartographicsDefinition'):
        if self.authority is not None and 'authority' not in already_processed:
            already_processed.add('authority')
            outfile.write(' authority=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.authority), input_name='authority')), ))
        if self.authorityURI is not None and 'authorityURI' not in already_processed:
            already_processed.add('authorityURI')
            outfile.write(' authorityURI=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.authorityURI), input_name='authorityURI')), ))
        if self.valueURI is not None and 'valueURI' not in already_processed:
            already_processed.add('valueURI')
            outfile.write(' valueURI=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.valueURI), input_name='valueURI')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='cartographicsDefinition', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.scale is not None:
            namespaceprefix_ = self.scale_nsprefix_ + ':' if (UseCapturedNS_ and self.scale_nsprefix_) else ''
            self.scale.export(outfile, level, namespaceprefix_, namespacedef_='', name_='scale', pretty_print=pretty_print)
        if self.projection is not None:
            namespaceprefix_ = self.projection_nsprefix_ + ':' if (UseCapturedNS_ and self.projection_nsprefix_) else ''
            self.projection.export(outfile, level, namespaceprefix_, namespacedef_='', name_='projection', pretty_print=pretty_print)
        for coordinates_ in self.coordinates:
            namespaceprefix_ = self.coordinates_nsprefix_ + ':' if (UseCapturedNS_ and self.coordinates_nsprefix_) else ''
            coordinates_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='coordinates', pretty_print=pretty_print)
        for cartographicExtension_ in self.cartographicExtension:
            namespaceprefix_ = self.cartographicExtension_nsprefix_ + ':' if (UseCapturedNS_ and self.cartographicExtension_nsprefix_) else ''
            cartographicExtension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='cartographicExtension', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('authority', node)
        if value is not None and 'authority' not in already_processed:
            already_processed.add('authority')
            self.authority = value
        value = find_attr_value_('authorityURI', node)
        if value is not None and 'authorityURI' not in already_processed:
            already_processed.add('authorityURI')
            self.authorityURI = value
        value = find_attr_value_('valueURI', node)
        if value is not None and 'valueURI' not in already_processed:
            already_processed.add('valueURI')
            self.valueURI = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'scale':
            class_obj_ = self.get_class_obj_(child_, stringPlusLanguage)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.scale = obj_
            obj_.original_tagname_ = 'scale'
        elif nodeName_ == 'projection':
            class_obj_ = self.get_class_obj_(child_, stringPlusLanguage)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.projection = obj_
            obj_.original_tagname_ = 'projection'
        elif nodeName_ == 'coordinates':
            class_obj_ = self.get_class_obj_(child_, stringPlusLanguage)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.coordinates.append(obj_)
            obj_.original_tagname_ = 'coordinates'
        elif nodeName_ == 'cartographicExtension':
            class_obj_ = self.get_class_obj_(child_, extensionDefinition)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.cartographicExtension.append(obj_)
            obj_.original_tagname_ = 'cartographicExtension'
# end class cartographicsDefinition


class titleInfoDefinition(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_='simple', otherType=None, supplied='yes', altRepGroup=None, nameTitleGroup=None, usage='primary', ID=None, displayLabel=None, altFormat=None, contentType=None, authority=None, authorityURI=None, valueURI=None, href=None, role=None, arcrole=None, title_attr=None, show=None, actuate=None, lang=None, script=None, transliteration=None, title=None, subTitle=None, partNumber=None, partName=None, nonSort=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.otherType = _cast(None, otherType)
        self.otherType_nsprefix_ = None
        self.supplied = _cast(None, supplied)
        self.supplied_nsprefix_ = None
        self.altRepGroup = _cast(None, altRepGroup)
        self.altRepGroup_nsprefix_ = None
        self.nameTitleGroup = _cast(None, nameTitleGroup)
        self.nameTitleGroup_nsprefix_ = None
        self.usage = _cast(None, usage)
        self.usage_nsprefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.displayLabel = _cast(None, displayLabel)
        self.displayLabel_nsprefix_ = None
        self.altFormat = _cast(None, altFormat)
        self.altFormat_nsprefix_ = None
        self.contentType = _cast(None, contentType)
        self.contentType_nsprefix_ = None
        self.authority = _cast(None, authority)
        self.authority_nsprefix_ = None
        self.authorityURI = _cast(None, authorityURI)
        self.authorityURI_nsprefix_ = None
        self.valueURI = _cast(None, valueURI)
        self.valueURI_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.href = _cast(None, href)
        self.href_nsprefix_ = None
        self.role = _cast(None, role)
        self.role_nsprefix_ = None
        self.arcrole = _cast(None, arcrole)
        self.arcrole_nsprefix_ = None
        self.title_attr = _cast(None, title_attr)
        self.title_attr_nsprefix_ = None
        self.show = _cast(None, show)
        self.show_nsprefix_ = None
        self.actuate = _cast(None, actuate)
        self.actuate_nsprefix_ = None
        self.lang = _cast(None, lang)
        self.lang_nsprefix_ = None
        self.lang = _cast(None, lang)
        self.lang_nsprefix_ = None
        self.script = _cast(None, script)
        self.script_nsprefix_ = None
        self.transliteration = _cast(None, transliteration)
        self.transliteration_nsprefix_ = None
        if title is None:
            self.title = []
        else:
            self.title = title
        self.title_nsprefix_ = None
        if subTitle is None:
            self.subTitle = []
        else:
            self.subTitle = subTitle
        self.subTitle_nsprefix_ = None
        if partNumber is None:
            self.partNumber = []
        else:
            self.partNumber = partNumber
        self.partNumber_nsprefix_ = None
        if partName is None:
            self.partName = []
        else:
            self.partName = partName
        self.partName_nsprefix_ = None
        if nonSort is None:
            self.nonSort = []
        else:
            self.nonSort = nonSort
        self.nonSort_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, titleInfoDefinition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if titleInfoDefinition.subclass:
            return titleInfoDefinition.subclass(*args_, **kwargs_)
        else:
            return titleInfoDefinition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def add_title(self, value):
        self.title.append(value)
    def insert_title_at(self, index, value):
        self.title.insert(index, value)
    def replace_title_at(self, index, value):
        self.title[index] = value
    def get_subTitle(self):
        return self.subTitle
    def set_subTitle(self, subTitle):
        self.subTitle = subTitle
    def add_subTitle(self, value):
        self.subTitle.append(value)
    def insert_subTitle_at(self, index, value):
        self.subTitle.insert(index, value)
    def replace_subTitle_at(self, index, value):
        self.subTitle[index] = value
    def get_partNumber(self):
        return self.partNumber
    def set_partNumber(self, partNumber):
        self.partNumber = partNumber
    def add_partNumber(self, value):
        self.partNumber.append(value)
    def insert_partNumber_at(self, index, value):
        self.partNumber.insert(index, value)
    def replace_partNumber_at(self, index, value):
        self.partNumber[index] = value
    def get_partName(self):
        return self.partName
    def set_partName(self, partName):
        self.partName = partName
    def add_partName(self, value):
        self.partName.append(value)
    def insert_partName_at(self, index, value):
        self.partName.insert(index, value)
    def replace_partName_at(self, index, value):
        self.partName[index] = value
    def get_nonSort(self):
        return self.nonSort
    def set_nonSort(self, nonSort):
        self.nonSort = nonSort
    def add_nonSort(self, value):
        self.nonSort.append(value)
    def insert_nonSort_at(self, index, value):
        self.nonSort.insert(index, value)
    def replace_nonSort_at(self, index, value):
        self.nonSort[index] = value
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_otherType(self):
        return self.otherType
    def set_otherType(self, otherType):
        self.otherType = otherType
    def get_supplied(self):
        return self.supplied
    def set_supplied(self, supplied):
        self.supplied = supplied
    def get_altRepGroup(self):
        return self.altRepGroup
    def set_altRepGroup(self, altRepGroup):
        self.altRepGroup = altRepGroup
    def get_nameTitleGroup(self):
        return self.nameTitleGroup
    def set_nameTitleGroup(self, nameTitleGroup):
        self.nameTitleGroup = nameTitleGroup
    def get_usage(self):
        return self.usage
    def set_usage(self, usage):
        self.usage = usage
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_displayLabel(self):
        return self.displayLabel
    def set_displayLabel(self, displayLabel):
        self.displayLabel = displayLabel
    def get_altFormat(self):
        return self.altFormat
    def set_altFormat(self, altFormat):
        self.altFormat = altFormat
    def get_contentType(self):
        return self.contentType
    def set_contentType(self, contentType):
        self.contentType = contentType
    def get_authority(self):
        return self.authority
    def set_authority(self, authority):
        self.authority = authority
    def get_authorityURI(self):
        return self.authorityURI
    def set_authorityURI(self, authorityURI):
        self.authorityURI = authorityURI
    def get_valueURI(self):
        return self.valueURI
    def set_valueURI(self, valueURI):
        self.valueURI = valueURI
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_href(self):
        return self.href
    def set_href(self, href):
        self.href = href
    def get_role(self):
        return self.role
    def set_role(self, role):
        self.role = role
    def get_arcrole(self):
        return self.arcrole
    def set_arcrole(self, arcrole):
        self.arcrole = arcrole
    def get_title_attr(self):
        return self.title_attr
    def set_title_attr(self, title_attr):
        self.title_attr = title_attr
    def get_show(self):
        return self.show
    def set_show(self, show):
        self.show = show
    def get_actuate(self):
        return self.actuate
    def set_actuate(self, actuate):
        self.actuate = actuate
    def get_lang(self):
        return self.lang
    def set_lang(self, lang):
        self.lang = lang
    def get_lang(self):
        return self.lang
    def set_lang(self, lang):
        self.lang = lang
    def get_script(self):
        return self.script
    def set_script(self, script):
        self.script = script
    def get_transliteration(self):
        return self.transliteration
    def set_transliteration(self, transliteration):
        self.transliteration = transliteration
    def hasContent_(self):
        if (
            self.title or
            self.subTitle or
            self.partNumber or
            self.partName or
            self.nonSort
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='titleInfoDefinition', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('titleInfoDefinition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='titleInfoDefinition')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='titleInfoDefinition', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='titleInfoDefinition'):
        if self.type_ != "simple" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.otherType is not None and 'otherType' not in already_processed:
            already_processed.add('otherType')
            outfile.write(' otherType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.otherType), input_name='otherType')), ))
        if self.supplied != "yes" and 'supplied' not in already_processed:
            already_processed.add('supplied')
            outfile.write(' supplied=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.supplied), input_name='supplied')), ))
        if self.altRepGroup is not None and 'altRepGroup' not in already_processed:
            already_processed.add('altRepGroup')
            outfile.write(' altRepGroup=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.altRepGroup), input_name='altRepGroup')), ))
        if self.nameTitleGroup is not None and 'nameTitleGroup' not in already_processed:
            already_processed.add('nameTitleGroup')
            outfile.write(' nameTitleGroup=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.nameTitleGroup), input_name='nameTitleGroup')), ))
        if self.usage != "primary" and 'usage' not in already_processed:
            already_processed.add('usage')
            outfile.write(' usage=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.usage), input_name='usage')), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.displayLabel is not None and 'displayLabel' not in already_processed:
            already_processed.add('displayLabel')
            outfile.write(' displayLabel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.displayLabel), input_name='displayLabel')), ))
        if self.altFormat is not None and 'altFormat' not in already_processed:
            already_processed.add('altFormat')
            outfile.write(' altFormat=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.altFormat), input_name='altFormat')), ))
        if self.contentType is not None and 'contentType' not in already_processed:
            already_processed.add('contentType')
            outfile.write(' contentType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.contentType), input_name='contentType')), ))
        if self.authority is not None and 'authority' not in already_processed:
            already_processed.add('authority')
            outfile.write(' authority=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.authority), input_name='authority')), ))
        if self.authorityURI is not None and 'authorityURI' not in already_processed:
            already_processed.add('authorityURI')
            outfile.write(' authorityURI=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.authorityURI), input_name='authorityURI')), ))
        if self.valueURI is not None and 'valueURI' not in already_processed:
            already_processed.add('valueURI')
            outfile.write(' valueURI=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.valueURI), input_name='valueURI')), ))
        if self.type_ != "simple" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (quote_attrib(self.href), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.add('role')
            outfile.write(' role=%s' % (quote_attrib(self.role), ))
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            outfile.write(' arcrole=%s' % (quote_attrib(self.arcrole), ))
        if self.title_attr is not None and 'title_attr' not in already_processed:
            already_processed.add('title_attr')
            outfile.write(' title=%s' % (quote_attrib(self.title_attr), ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.add('show')
            outfile.write(' show=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.show), input_name='show')), ))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            outfile.write(' actuate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.actuate), input_name='actuate')), ))
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lang), input_name='lang')), ))
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lang), input_name='lang')), ))
        if self.script is not None and 'script' not in already_processed:
            already_processed.add('script')
            outfile.write(' script=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.script), input_name='script')), ))
        if self.transliteration is not None and 'transliteration' not in already_processed:
            already_processed.add('transliteration')
            outfile.write(' transliteration=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.transliteration), input_name='transliteration')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='titleInfoDefinition', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for title_ in self.title:
            namespaceprefix_ = self.title_nsprefix_ + ':' if (UseCapturedNS_ and self.title_nsprefix_) else ''
            title_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='title', pretty_print=pretty_print)
        for subTitle_ in self.subTitle:
            namespaceprefix_ = self.subTitle_nsprefix_ + ':' if (UseCapturedNS_ and self.subTitle_nsprefix_) else ''
            subTitle_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subTitle', pretty_print=pretty_print)
        for partNumber_ in self.partNumber:
            namespaceprefix_ = self.partNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.partNumber_nsprefix_) else ''
            partNumber_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='partNumber', pretty_print=pretty_print)
        for partName_ in self.partName:
            namespaceprefix_ = self.partName_nsprefix_ + ':' if (UseCapturedNS_ and self.partName_nsprefix_) else ''
            partName_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='partName', pretty_print=pretty_print)
        for nonSort_ in self.nonSort:
            namespaceprefix_ = self.nonSort_nsprefix_ + ':' if (UseCapturedNS_ and self.nonSort_nsprefix_) else ''
            nonSort_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='nonSort', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('otherType', node)
        if value is not None and 'otherType' not in already_processed:
            already_processed.add('otherType')
            self.otherType = value
        value = find_attr_value_('supplied', node)
        if value is not None and 'supplied' not in already_processed:
            already_processed.add('supplied')
            self.supplied = value
        value = find_attr_value_('altRepGroup', node)
        if value is not None and 'altRepGroup' not in already_processed:
            already_processed.add('altRepGroup')
            self.altRepGroup = value
        value = find_attr_value_('nameTitleGroup', node)
        if value is not None and 'nameTitleGroup' not in already_processed:
            already_processed.add('nameTitleGroup')
            self.nameTitleGroup = value
        value = find_attr_value_('usage', node)
        if value is not None and 'usage' not in already_processed:
            already_processed.add('usage')
            self.usage = value
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('displayLabel', node)
        if value is not None and 'displayLabel' not in already_processed:
            already_processed.add('displayLabel')
            self.displayLabel = value
        value = find_attr_value_('altFormat', node)
        if value is not None and 'altFormat' not in already_processed:
            already_processed.add('altFormat')
            self.altFormat = value
        value = find_attr_value_('contentType', node)
        if value is not None and 'contentType' not in already_processed:
            already_processed.add('contentType')
            self.contentType = value
        value = find_attr_value_('authority', node)
        if value is not None and 'authority' not in already_processed:
            already_processed.add('authority')
            self.authority = value
        value = find_attr_value_('authorityURI', node)
        if value is not None and 'authorityURI' not in already_processed:
            already_processed.add('authorityURI')
            self.authorityURI = value
        value = find_attr_value_('valueURI', node)
        if value is not None and 'valueURI' not in already_processed:
            already_processed.add('valueURI')
            self.valueURI = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.add('role')
            self.role = value
        value = find_attr_value_('arcrole', node)
        if value is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            self.arcrole = value
        value = find_attr_value_('title', node)
        if value is not None and 'title_attr' not in already_processed:
            already_processed.add('title_attr')
            self.title_attr = value
        value = find_attr_value_('show', node)
        if value is not None and 'show' not in already_processed:
            already_processed.add('show')
            self.show = value
        value = find_attr_value_('actuate', node)
        if value is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            self.actuate = value
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        value = find_attr_value_('script', node)
        if value is not None and 'script' not in already_processed:
            already_processed.add('script')
            self.script = value
        value = find_attr_value_('transliteration', node)
        if value is not None and 'transliteration' not in already_processed:
            already_processed.add('transliteration')
            self.transliteration = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'title':
            class_obj_ = self.get_class_obj_(child_, stringPlusLanguage)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.title.append(obj_)
            obj_.original_tagname_ = 'title'
        elif nodeName_ == 'subTitle':
            class_obj_ = self.get_class_obj_(child_, stringPlusLanguage)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subTitle.append(obj_)
            obj_.original_tagname_ = 'subTitle'
        elif nodeName_ == 'partNumber':
            class_obj_ = self.get_class_obj_(child_, stringPlusLanguage)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.partNumber.append(obj_)
            obj_.original_tagname_ = 'partNumber'
        elif nodeName_ == 'partName':
            class_obj_ = self.get_class_obj_(child_, stringPlusLanguage)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.partName.append(obj_)
            obj_.original_tagname_ = 'partName'
        elif nodeName_ == 'nonSort':
            obj_ = nonSort.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.nonSort.append(obj_)
            obj_.original_tagname_ = 'nonSort'
# end class titleInfoDefinition


class stringPlusLanguage(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, lang=None, script=None, transliteration=None, valueOf_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.lang = _cast(None, lang)
        self.lang_nsprefix_ = None
        self.lang = _cast(None, lang)
        self.lang_nsprefix_ = None
        self.script = _cast(None, script)
        self.script_nsprefix_ = None
        self.transliteration = _cast(None, transliteration)
        self.transliteration_nsprefix_ = None
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, stringPlusLanguage)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if stringPlusLanguage.subclass:
            return stringPlusLanguage.subclass(*args_, **kwargs_)
        else:
            return stringPlusLanguage(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_lang(self):
        return self.lang
    def set_lang(self, lang):
        self.lang = lang
    def get_lang(self):
        return self.lang
    def set_lang(self, lang):
        self.lang = lang
    def get_script(self):
        return self.script
    def set_script(self, script):
        self.script = script
    def get_transliteration(self):
        return self.transliteration
    def set_transliteration(self, transliteration):
        self.transliteration = transliteration
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='stringPlusLanguage', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('stringPlusLanguage')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='stringPlusLanguage')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='stringPlusLanguage', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='stringPlusLanguage'):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lang), input_name='lang')), ))
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lang), input_name='lang')), ))
        if self.script is not None and 'script' not in already_processed:
            already_processed.add('script')
            outfile.write(' script=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.script), input_name='script')), ))
        if self.transliteration is not None and 'transliteration' not in already_processed:
            already_processed.add('transliteration')
            outfile.write(' transliteration=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.transliteration), input_name='transliteration')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='stringPlusLanguage', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        value = find_attr_value_('script', node)
        if value is not None and 'script' not in already_processed:
            already_processed.add('script')
            self.script = value
        value = find_attr_value_('transliteration', node)
        if value is not None and 'transliteration' not in already_processed:
            already_processed.add('transliteration')
            self.transliteration = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class stringPlusLanguage


class stringPlusLanguagePlusAuthority(stringPlusLanguage):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = stringPlusLanguage
    def __init__(self, lang=None, script=None, transliteration=None, authority=None, authorityURI=None, valueURI=None, valueOf_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(stringPlusLanguagePlusAuthority, self).__init__(lang, script, transliteration, valueOf_, extensiontype_,  **kwargs_)
        self.authority = _cast(None, authority)
        self.authority_nsprefix_ = None
        self.authorityURI = _cast(None, authorityURI)
        self.authorityURI_nsprefix_ = None
        self.valueURI = _cast(None, valueURI)
        self.valueURI_nsprefix_ = None
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, stringPlusLanguagePlusAuthority)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if stringPlusLanguagePlusAuthority.subclass:
            return stringPlusLanguagePlusAuthority.subclass(*args_, **kwargs_)
        else:
            return stringPlusLanguagePlusAuthority(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_authority(self):
        return self.authority
    def set_authority(self, authority):
        self.authority = authority
    def get_authorityURI(self):
        return self.authorityURI
    def set_authorityURI(self, authorityURI):
        self.authorityURI = authorityURI
    def get_valueURI(self):
        return self.valueURI
    def set_valueURI(self, valueURI):
        self.valueURI = valueURI
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(stringPlusLanguagePlusAuthority, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='stringPlusLanguagePlusAuthority', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('stringPlusLanguagePlusAuthority')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='stringPlusLanguagePlusAuthority')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='stringPlusLanguagePlusAuthority', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='stringPlusLanguagePlusAuthority'):
        super(stringPlusLanguagePlusAuthority, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='stringPlusLanguagePlusAuthority')
        if self.authority is not None and 'authority' not in already_processed:
            already_processed.add('authority')
            outfile.write(' authority=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.authority), input_name='authority')), ))
        if self.authorityURI is not None and 'authorityURI' not in already_processed:
            already_processed.add('authorityURI')
            outfile.write(' authorityURI=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.authorityURI), input_name='authorityURI')), ))
        if self.valueURI is not None and 'valueURI' not in already_processed:
            already_processed.add('valueURI')
            outfile.write(' valueURI=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.valueURI), input_name='valueURI')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='stringPlusLanguagePlusAuthority', fromsubclass_=False, pretty_print=True):
        super(stringPlusLanguagePlusAuthority, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('authority', node)
        if value is not None and 'authority' not in already_processed:
            already_processed.add('authority')
            self.authority = value
        value = find_attr_value_('authorityURI', node)
        if value is not None and 'authorityURI' not in already_processed:
            already_processed.add('authorityURI')
            self.authorityURI = value
        value = find_attr_value_('valueURI', node)
        if value is not None and 'valueURI' not in already_processed:
            already_processed.add('valueURI')
            self.valueURI = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(stringPlusLanguagePlusAuthority, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class stringPlusLanguagePlusAuthority


class stringPlusLanguagePlusSupplied(stringPlusLanguage):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = stringPlusLanguage
    def __init__(self, lang=None, script=None, transliteration=None, supplied='yes', valueOf_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(stringPlusLanguagePlusSupplied, self).__init__(lang, script, transliteration, valueOf_, extensiontype_,  **kwargs_)
        self.supplied = _cast(None, supplied)
        self.supplied_nsprefix_ = None
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, stringPlusLanguagePlusSupplied)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if stringPlusLanguagePlusSupplied.subclass:
            return stringPlusLanguagePlusSupplied.subclass(*args_, **kwargs_)
        else:
            return stringPlusLanguagePlusSupplied(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_supplied(self):
        return self.supplied
    def set_supplied(self, supplied):
        self.supplied = supplied
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(stringPlusLanguagePlusSupplied, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='stringPlusLanguagePlusSupplied', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('stringPlusLanguagePlusSupplied')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='stringPlusLanguagePlusSupplied')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='stringPlusLanguagePlusSupplied', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='stringPlusLanguagePlusSupplied'):
        super(stringPlusLanguagePlusSupplied, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='stringPlusLanguagePlusSupplied')
        if self.supplied != "yes" and 'supplied' not in already_processed:
            already_processed.add('supplied')
            outfile.write(' supplied=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.supplied), input_name='supplied')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='stringPlusLanguagePlusSupplied', fromsubclass_=False, pretty_print=True):
        super(stringPlusLanguagePlusSupplied, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('supplied', node)
        if value is not None and 'supplied' not in already_processed:
            already_processed.add('supplied')
            self.supplied = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(stringPlusLanguagePlusSupplied, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class stringPlusLanguagePlusSupplied


class noteType(stringPlusLanguage):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = stringPlusLanguage
    def __init__(self, lang=None, script=None, transliteration=None, displayLabel=None, type_='simple', ID=None, href=None, role=None, arcrole=None, title=None, show=None, actuate=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(noteType, self).__init__(lang, script, transliteration, valueOf_,  **kwargs_)
        self.displayLabel = _cast(None, displayLabel)
        self.displayLabel_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.href = _cast(None, href)
        self.href_nsprefix_ = None
        self.role = _cast(None, role)
        self.role_nsprefix_ = None
        self.arcrole = _cast(None, arcrole)
        self.arcrole_nsprefix_ = None
        self.title = _cast(None, title)
        self.title_nsprefix_ = None
        self.show = _cast(None, show)
        self.show_nsprefix_ = None
        self.actuate = _cast(None, actuate)
        self.actuate_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, noteType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if noteType.subclass:
            return noteType.subclass(*args_, **kwargs_)
        else:
            return noteType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_displayLabel(self):
        return self.displayLabel
    def set_displayLabel(self, displayLabel):
        self.displayLabel = displayLabel
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_href(self):
        return self.href
    def set_href(self, href):
        self.href = href
    def get_role(self):
        return self.role
    def set_role(self, role):
        self.role = role
    def get_arcrole(self):
        return self.arcrole
    def set_arcrole(self, arcrole):
        self.arcrole = arcrole
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def get_show(self):
        return self.show
    def set_show(self, show):
        self.show = show
    def get_actuate(self):
        return self.actuate
    def set_actuate(self, actuate):
        self.actuate = actuate
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(noteType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='noteType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('noteType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='noteType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='noteType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='noteType'):
        super(noteType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='noteType')
        if self.displayLabel is not None and 'displayLabel' not in already_processed:
            already_processed.add('displayLabel')
            outfile.write(' displayLabel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.displayLabel), input_name='displayLabel')), ))
        if self.type_ != "simple" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.type_ != "simple" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (quote_attrib(self.href), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.add('role')
            outfile.write(' role=%s' % (quote_attrib(self.role), ))
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            outfile.write(' arcrole=%s' % (quote_attrib(self.arcrole), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.add('title')
            outfile.write(' title=%s' % (quote_attrib(self.title), ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.add('show')
            outfile.write(' show=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.show), input_name='show')), ))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            outfile.write(' actuate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.actuate), input_name='actuate')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='noteType', fromsubclass_=False, pretty_print=True):
        super(noteType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('displayLabel', node)
        if value is not None and 'displayLabel' not in already_processed:
            already_processed.add('displayLabel')
            self.displayLabel = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.add('role')
            self.role = value
        value = find_attr_value_('arcrole', node)
        if value is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            self.arcrole = value
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.add('title')
            self.title = value
        value = find_attr_value_('show', node)
        if value is not None and 'show' not in already_processed:
            already_processed.add('show')
            self.show = value
        value = find_attr_value_('actuate', node)
        if value is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            self.actuate = value
        super(noteType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class noteType


class typeOfResourceDefinition(stringPlusLanguagePlusAuthority):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = stringPlusLanguagePlusAuthority
    def __init__(self, lang=None, script=None, transliteration=None, authority=None, authorityURI=None, valueURI=None, collection='yes', manuscript='yes', displayLabel=None, altRepGroup=None, usage='primary', valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(typeOfResourceDefinition, self).__init__(lang, script, transliteration, authority, authorityURI, valueURI, valueOf_,  **kwargs_)
        self.collection = _cast(None, collection)
        self.collection_nsprefix_ = None
        self.manuscript = _cast(None, manuscript)
        self.manuscript_nsprefix_ = None
        self.displayLabel = _cast(None, displayLabel)
        self.displayLabel_nsprefix_ = None
        self.altRepGroup = _cast(None, altRepGroup)
        self.altRepGroup_nsprefix_ = None
        self.usage = _cast(None, usage)
        self.usage_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, typeOfResourceDefinition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if typeOfResourceDefinition.subclass:
            return typeOfResourceDefinition.subclass(*args_, **kwargs_)
        else:
            return typeOfResourceDefinition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_collection(self):
        return self.collection
    def set_collection(self, collection):
        self.collection = collection
    def get_manuscript(self):
        return self.manuscript
    def set_manuscript(self, manuscript):
        self.manuscript = manuscript
    def get_displayLabel(self):
        return self.displayLabel
    def set_displayLabel(self, displayLabel):
        self.displayLabel = displayLabel
    def get_altRepGroup(self):
        return self.altRepGroup
    def set_altRepGroup(self, altRepGroup):
        self.altRepGroup = altRepGroup
    def get_usage(self):
        return self.usage
    def set_usage(self, usage):
        self.usage = usage
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(typeOfResourceDefinition, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='typeOfResourceDefinition', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('typeOfResourceDefinition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='typeOfResourceDefinition')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='typeOfResourceDefinition', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='typeOfResourceDefinition'):
        super(typeOfResourceDefinition, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='typeOfResourceDefinition')
        if self.collection != "yes" and 'collection' not in already_processed:
            already_processed.add('collection')
            outfile.write(' collection=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.collection), input_name='collection')), ))
        if self.manuscript != "yes" and 'manuscript' not in already_processed:
            already_processed.add('manuscript')
            outfile.write(' manuscript=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.manuscript), input_name='manuscript')), ))
        if self.displayLabel is not None and 'displayLabel' not in already_processed:
            already_processed.add('displayLabel')
            outfile.write(' displayLabel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.displayLabel), input_name='displayLabel')), ))
        if self.altRepGroup is not None and 'altRepGroup' not in already_processed:
            already_processed.add('altRepGroup')
            outfile.write(' altRepGroup=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.altRepGroup), input_name='altRepGroup')), ))
        if self.usage != "primary" and 'usage' not in already_processed:
            already_processed.add('usage')
            outfile.write(' usage=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.usage), input_name='usage')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='typeOfResourceDefinition', fromsubclass_=False, pretty_print=True):
        super(typeOfResourceDefinition, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('collection', node)
        if value is not None and 'collection' not in already_processed:
            already_processed.add('collection')
            self.collection = value
        value = find_attr_value_('manuscript', node)
        if value is not None and 'manuscript' not in already_processed:
            already_processed.add('manuscript')
            self.manuscript = value
        value = find_attr_value_('displayLabel', node)
        if value is not None and 'displayLabel' not in already_processed:
            already_processed.add('displayLabel')
            self.displayLabel = value
        value = find_attr_value_('altRepGroup', node)
        if value is not None and 'altRepGroup' not in already_processed:
            already_processed.add('altRepGroup')
            self.altRepGroup = value
        value = find_attr_value_('usage', node)
        if value is not None and 'usage' not in already_processed:
            already_processed.add('usage')
            self.usage = value
        super(typeOfResourceDefinition, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class typeOfResourceDefinition


class nonSort(stringPlusLanguage):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = stringPlusLanguage
    def __init__(self, lang=None, script=None, transliteration=None, space=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(nonSort, self).__init__(lang, script, transliteration, valueOf_,  **kwargs_)
        self.space = _cast(None, space)
        self.space_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nonSort)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nonSort.subclass:
            return nonSort.subclass(*args_, **kwargs_)
        else:
            return nonSort(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_space(self):
        return self.space
    def set_space(self, space):
        self.space = space
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(nonSort, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='nonSort', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('nonSort')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='nonSort')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='nonSort', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='nonSort'):
        super(nonSort, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='nonSort')
        if self.space is not None and 'space' not in already_processed:
            already_processed.add('space')
            outfile.write(' space=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.space), input_name='space')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='nonSort', fromsubclass_=False, pretty_print=True):
        super(nonSort, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('space', node)
        if value is not None and 'space' not in already_processed:
            already_processed.add('space')
            self.space = value
        super(nonSort, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class nonSort


class targetAudienceDefinition(stringPlusLanguagePlusAuthority):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = stringPlusLanguagePlusAuthority
    def __init__(self, lang=None, script=None, transliteration=None, authority=None, authorityURI=None, valueURI=None, displayLabel=None, altRepGroup=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(targetAudienceDefinition, self).__init__(lang, script, transliteration, authority, authorityURI, valueURI, valueOf_,  **kwargs_)
        self.displayLabel = _cast(None, displayLabel)
        self.displayLabel_nsprefix_ = None
        self.altRepGroup = _cast(None, altRepGroup)
        self.altRepGroup_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, targetAudienceDefinition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if targetAudienceDefinition.subclass:
            return targetAudienceDefinition.subclass(*args_, **kwargs_)
        else:
            return targetAudienceDefinition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_displayLabel(self):
        return self.displayLabel
    def set_displayLabel(self, displayLabel):
        self.displayLabel = displayLabel
    def get_altRepGroup(self):
        return self.altRepGroup
    def set_altRepGroup(self, altRepGroup):
        self.altRepGroup = altRepGroup
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(targetAudienceDefinition, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='targetAudienceDefinition', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('targetAudienceDefinition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='targetAudienceDefinition')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='targetAudienceDefinition', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='targetAudienceDefinition'):
        super(targetAudienceDefinition, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='targetAudienceDefinition')
        if self.displayLabel is not None and 'displayLabel' not in already_processed:
            already_processed.add('displayLabel')
            outfile.write(' displayLabel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.displayLabel), input_name='displayLabel')), ))
        if self.altRepGroup is not None and 'altRepGroup' not in already_processed:
            already_processed.add('altRepGroup')
            outfile.write(' altRepGroup=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.altRepGroup), input_name='altRepGroup')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='targetAudienceDefinition', fromsubclass_=False, pretty_print=True):
        super(targetAudienceDefinition, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('displayLabel', node)
        if value is not None and 'displayLabel' not in already_processed:
            already_processed.add('displayLabel')
            self.displayLabel = value
        value = find_attr_value_('altRepGroup', node)
        if value is not None and 'altRepGroup' not in already_processed:
            already_processed.add('altRepGroup')
            self.altRepGroup = value
        super(targetAudienceDefinition, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class targetAudienceDefinition


class tableOfContentsDefinition(stringPlusLanguage):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = stringPlusLanguage
    def __init__(self, lang=None, script=None, transliteration=None, displayLabel=None, type_='simple', shareable='no', altRepGroup=None, href=None, role=None, arcrole=None, title=None, show=None, actuate=None, altFormat=None, contentType=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(tableOfContentsDefinition, self).__init__(lang, script, transliteration, valueOf_,  **kwargs_)
        self.displayLabel = _cast(None, displayLabel)
        self.displayLabel_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.shareable = _cast(None, shareable)
        self.shareable_nsprefix_ = None
        self.altRepGroup = _cast(None, altRepGroup)
        self.altRepGroup_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.href = _cast(None, href)
        self.href_nsprefix_ = None
        self.role = _cast(None, role)
        self.role_nsprefix_ = None
        self.arcrole = _cast(None, arcrole)
        self.arcrole_nsprefix_ = None
        self.title = _cast(None, title)
        self.title_nsprefix_ = None
        self.show = _cast(None, show)
        self.show_nsprefix_ = None
        self.actuate = _cast(None, actuate)
        self.actuate_nsprefix_ = None
        self.altFormat = _cast(None, altFormat)
        self.altFormat_nsprefix_ = None
        self.contentType = _cast(None, contentType)
        self.contentType_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tableOfContentsDefinition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tableOfContentsDefinition.subclass:
            return tableOfContentsDefinition.subclass(*args_, **kwargs_)
        else:
            return tableOfContentsDefinition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_displayLabel(self):
        return self.displayLabel
    def set_displayLabel(self, displayLabel):
        self.displayLabel = displayLabel
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_shareable(self):
        return self.shareable
    def set_shareable(self, shareable):
        self.shareable = shareable
    def get_altRepGroup(self):
        return self.altRepGroup
    def set_altRepGroup(self, altRepGroup):
        self.altRepGroup = altRepGroup
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_href(self):
        return self.href
    def set_href(self, href):
        self.href = href
    def get_role(self):
        return self.role
    def set_role(self, role):
        self.role = role
    def get_arcrole(self):
        return self.arcrole
    def set_arcrole(self, arcrole):
        self.arcrole = arcrole
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def get_show(self):
        return self.show
    def set_show(self, show):
        self.show = show
    def get_actuate(self):
        return self.actuate
    def set_actuate(self, actuate):
        self.actuate = actuate
    def get_altFormat(self):
        return self.altFormat
    def set_altFormat(self, altFormat):
        self.altFormat = altFormat
    def get_contentType(self):
        return self.contentType
    def set_contentType(self, contentType):
        self.contentType = contentType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(tableOfContentsDefinition, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tableOfContentsDefinition', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tableOfContentsDefinition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='tableOfContentsDefinition')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='tableOfContentsDefinition', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='tableOfContentsDefinition'):
        super(tableOfContentsDefinition, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='tableOfContentsDefinition')
        if self.displayLabel is not None and 'displayLabel' not in already_processed:
            already_processed.add('displayLabel')
            outfile.write(' displayLabel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.displayLabel), input_name='displayLabel')), ))
        if self.type_ != "simple" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.shareable != "no" and 'shareable' not in already_processed:
            already_processed.add('shareable')
            outfile.write(' shareable=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.shareable), input_name='shareable')), ))
        if self.altRepGroup is not None and 'altRepGroup' not in already_processed:
            already_processed.add('altRepGroup')
            outfile.write(' altRepGroup=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.altRepGroup), input_name='altRepGroup')), ))
        if self.type_ != "simple" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (quote_attrib(self.href), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.add('role')
            outfile.write(' role=%s' % (quote_attrib(self.role), ))
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            outfile.write(' arcrole=%s' % (quote_attrib(self.arcrole), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.add('title')
            outfile.write(' title=%s' % (quote_attrib(self.title), ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.add('show')
            outfile.write(' show=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.show), input_name='show')), ))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            outfile.write(' actuate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.actuate), input_name='actuate')), ))
        if self.altFormat is not None and 'altFormat' not in already_processed:
            already_processed.add('altFormat')
            outfile.write(' altFormat=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.altFormat), input_name='altFormat')), ))
        if self.contentType is not None and 'contentType' not in already_processed:
            already_processed.add('contentType')
            outfile.write(' contentType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.contentType), input_name='contentType')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tableOfContentsDefinition', fromsubclass_=False, pretty_print=True):
        super(tableOfContentsDefinition, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('displayLabel', node)
        if value is not None and 'displayLabel' not in already_processed:
            already_processed.add('displayLabel')
            self.displayLabel = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('shareable', node)
        if value is not None and 'shareable' not in already_processed:
            already_processed.add('shareable')
            self.shareable = value
        value = find_attr_value_('altRepGroup', node)
        if value is not None and 'altRepGroup' not in already_processed:
            already_processed.add('altRepGroup')
            self.altRepGroup = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.add('role')
            self.role = value
        value = find_attr_value_('arcrole', node)
        if value is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            self.arcrole = value
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.add('title')
            self.title = value
        value = find_attr_value_('show', node)
        if value is not None and 'show' not in already_processed:
            already_processed.add('show')
            self.show = value
        value = find_attr_value_('actuate', node)
        if value is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            self.actuate = value
        value = find_attr_value_('altFormat', node)
        if value is not None and 'altFormat' not in already_processed:
            already_processed.add('altFormat')
            self.altFormat = value
        value = find_attr_value_('contentType', node)
        if value is not None and 'contentType' not in already_processed:
            already_processed.add('contentType')
            self.contentType = value
        super(tableOfContentsDefinition, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class tableOfContentsDefinition


class hierarchicalPart(stringPlusLanguage):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = stringPlusLanguage
    def __init__(self, lang=None, script=None, transliteration=None, level=None, period=None, authority=None, authorityURI=None, valueURI=None, valueOf_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(hierarchicalPart, self).__init__(lang, script, transliteration, valueOf_, extensiontype_,  **kwargs_)
        self.level = _cast(None, level)
        self.level_nsprefix_ = None
        self.period = _cast(None, period)
        self.period_nsprefix_ = None
        self.authority = _cast(None, authority)
        self.authority_nsprefix_ = None
        self.authorityURI = _cast(None, authorityURI)
        self.authorityURI_nsprefix_ = None
        self.valueURI = _cast(None, valueURI)
        self.valueURI_nsprefix_ = None
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, hierarchicalPart)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if hierarchicalPart.subclass:
            return hierarchicalPart.subclass(*args_, **kwargs_)
        else:
            return hierarchicalPart(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_level(self):
        return self.level
    def set_level(self, level):
        self.level = level
    def get_period(self):
        return self.period
    def set_period(self, period):
        self.period = period
    def get_authority(self):
        return self.authority
    def set_authority(self, authority):
        self.authority = authority
    def get_authorityURI(self):
        return self.authorityURI
    def set_authorityURI(self, authorityURI):
        self.authorityURI = authorityURI
    def get_valueURI(self):
        return self.valueURI
    def set_valueURI(self, valueURI):
        self.valueURI = valueURI
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(hierarchicalPart, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='hierarchicalPart', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('hierarchicalPart')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='hierarchicalPart')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='hierarchicalPart', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='hierarchicalPart'):
        super(hierarchicalPart, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='hierarchicalPart')
        if self.level is not None and 'level' not in already_processed:
            already_processed.add('level')
            outfile.write(' level=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.level), input_name='level')), ))
        if self.period is not None and 'period' not in already_processed:
            already_processed.add('period')
            outfile.write(' period=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.period), input_name='period')), ))
        if self.authority is not None and 'authority' not in already_processed:
            already_processed.add('authority')
            outfile.write(' authority=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.authority), input_name='authority')), ))
        if self.authorityURI is not None and 'authorityURI' not in already_processed:
            already_processed.add('authorityURI')
            outfile.write(' authorityURI=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.authorityURI), input_name='authorityURI')), ))
        if self.valueURI is not None and 'valueURI' not in already_processed:
            already_processed.add('valueURI')
            outfile.write(' valueURI=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.valueURI), input_name='valueURI')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='hierarchicalPart', fromsubclass_=False, pretty_print=True):
        super(hierarchicalPart, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('level', node)
        if value is not None and 'level' not in already_processed:
            already_processed.add('level')
            self.level = value
        value = find_attr_value_('period', node)
        if value is not None and 'period' not in already_processed:
            already_processed.add('period')
            self.period = value
        value = find_attr_value_('authority', node)
        if value is not None and 'authority' not in already_processed:
            already_processed.add('authority')
            self.authority = value
        value = find_attr_value_('authorityURI', node)
        if value is not None and 'authorityURI' not in already_processed:
            already_processed.add('authorityURI')
            self.authorityURI = value
        value = find_attr_value_('valueURI', node)
        if value is not None and 'valueURI' not in already_processed:
            already_processed.add('valueURI')
            self.valueURI = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(hierarchicalPart, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class hierarchicalPart


class geographicCodeDefinition(stringPlusLanguage):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = stringPlusLanguage
    def __init__(self, lang=None, script=None, transliteration=None, authorityURI=None, valueURI=None, authority=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(geographicCodeDefinition, self).__init__(lang, script, transliteration, valueOf_,  **kwargs_)
        self.authorityURI = _cast(None, authorityURI)
        self.authorityURI_nsprefix_ = None
        self.valueURI = _cast(None, valueURI)
        self.valueURI_nsprefix_ = None
        self.authority = _cast(None, authority)
        self.authority_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, geographicCodeDefinition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if geographicCodeDefinition.subclass:
            return geographicCodeDefinition.subclass(*args_, **kwargs_)
        else:
            return geographicCodeDefinition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_authorityURI(self):
        return self.authorityURI
    def set_authorityURI(self, authorityURI):
        self.authorityURI = authorityURI
    def get_valueURI(self):
        return self.valueURI
    def set_valueURI(self, valueURI):
        self.valueURI = valueURI
    def get_authority(self):
        return self.authority
    def set_authority(self, authority):
        self.authority = authority
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(geographicCodeDefinition, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='geographicCodeDefinition', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('geographicCodeDefinition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='geographicCodeDefinition')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='geographicCodeDefinition', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='geographicCodeDefinition'):
        super(geographicCodeDefinition, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='geographicCodeDefinition')
        if self.authorityURI is not None and 'authorityURI' not in already_processed:
            already_processed.add('authorityURI')
            outfile.write(' authorityURI=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.authorityURI), input_name='authorityURI')), ))
        if self.valueURI is not None and 'valueURI' not in already_processed:
            already_processed.add('valueURI')
            outfile.write(' valueURI=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.valueURI), input_name='valueURI')), ))
        if self.authority is not None and 'authority' not in already_processed:
            already_processed.add('authority')
            outfile.write(' authority=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.authority), input_name='authority')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='geographicCodeDefinition', fromsubclass_=False, pretty_print=True):
        super(geographicCodeDefinition, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('authorityURI', node)
        if value is not None and 'authorityURI' not in already_processed:
            already_processed.add('authorityURI')
            self.authorityURI = value
        value = find_attr_value_('valueURI', node)
        if value is not None and 'valueURI' not in already_processed:
            already_processed.add('valueURI')
            self.valueURI = value
        value = find_attr_value_('authority', node)
        if value is not None and 'authority' not in already_processed:
            already_processed.add('authority')
            self.authority = value
        super(geographicCodeDefinition, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class geographicCodeDefinition


class recordIdentifierDefinition(stringPlusLanguage):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = stringPlusLanguage
    def __init__(self, lang=None, script=None, transliteration=None, source=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(recordIdentifierDefinition, self).__init__(lang, script, transliteration, valueOf_,  **kwargs_)
        self.source = _cast(None, source)
        self.source_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, recordIdentifierDefinition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if recordIdentifierDefinition.subclass:
            return recordIdentifierDefinition.subclass(*args_, **kwargs_)
        else:
            return recordIdentifierDefinition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_source(self):
        return self.source
    def set_source(self, source):
        self.source = source
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(recordIdentifierDefinition, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='recordIdentifierDefinition', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('recordIdentifierDefinition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='recordIdentifierDefinition')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='recordIdentifierDefinition', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='recordIdentifierDefinition'):
        super(recordIdentifierDefinition, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='recordIdentifierDefinition')
        if self.source is not None and 'source' not in already_processed:
            already_processed.add('source')
            outfile.write(' source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.source), input_name='source')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='recordIdentifierDefinition', fromsubclass_=False, pretty_print=True):
        super(recordIdentifierDefinition, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('source', node)
        if value is not None and 'source' not in already_processed:
            already_processed.add('source')
            self.source = value
        super(recordIdentifierDefinition, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class recordIdentifierDefinition


class physicalDescriptionNote(stringPlusLanguage):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = stringPlusLanguage
    def __init__(self, lang=None, script=None, transliteration=None, displayLabel=None, type_='simple', typeURI=None, ID=None, href=None, role=None, arcrole=None, title=None, show=None, actuate=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(physicalDescriptionNote, self).__init__(lang, script, transliteration, valueOf_,  **kwargs_)
        self.displayLabel = _cast(None, displayLabel)
        self.displayLabel_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.typeURI = _cast(None, typeURI)
        self.typeURI_nsprefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.href = _cast(None, href)
        self.href_nsprefix_ = None
        self.role = _cast(None, role)
        self.role_nsprefix_ = None
        self.arcrole = _cast(None, arcrole)
        self.arcrole_nsprefix_ = None
        self.title = _cast(None, title)
        self.title_nsprefix_ = None
        self.show = _cast(None, show)
        self.show_nsprefix_ = None
        self.actuate = _cast(None, actuate)
        self.actuate_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, physicalDescriptionNote)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if physicalDescriptionNote.subclass:
            return physicalDescriptionNote.subclass(*args_, **kwargs_)
        else:
            return physicalDescriptionNote(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_displayLabel(self):
        return self.displayLabel
    def set_displayLabel(self, displayLabel):
        self.displayLabel = displayLabel
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_typeURI(self):
        return self.typeURI
    def set_typeURI(self, typeURI):
        self.typeURI = typeURI
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_href(self):
        return self.href
    def set_href(self, href):
        self.href = href
    def get_role(self):
        return self.role
    def set_role(self, role):
        self.role = role
    def get_arcrole(self):
        return self.arcrole
    def set_arcrole(self, arcrole):
        self.arcrole = arcrole
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def get_show(self):
        return self.show
    def set_show(self, show):
        self.show = show
    def get_actuate(self):
        return self.actuate
    def set_actuate(self, actuate):
        self.actuate = actuate
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(physicalDescriptionNote, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='physicalDescriptionNote', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('physicalDescriptionNote')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='physicalDescriptionNote')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='physicalDescriptionNote', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='physicalDescriptionNote'):
        super(physicalDescriptionNote, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='physicalDescriptionNote')
        if self.displayLabel is not None and 'displayLabel' not in already_processed:
            already_processed.add('displayLabel')
            outfile.write(' displayLabel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.displayLabel), input_name='displayLabel')), ))
        if self.type_ != "simple" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.typeURI is not None and 'typeURI' not in already_processed:
            already_processed.add('typeURI')
            outfile.write(' typeURI=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.typeURI), input_name='typeURI')), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.type_ != "simple" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (quote_attrib(self.href), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.add('role')
            outfile.write(' role=%s' % (quote_attrib(self.role), ))
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            outfile.write(' arcrole=%s' % (quote_attrib(self.arcrole), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.add('title')
            outfile.write(' title=%s' % (quote_attrib(self.title), ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.add('show')
            outfile.write(' show=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.show), input_name='show')), ))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            outfile.write(' actuate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.actuate), input_name='actuate')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='physicalDescriptionNote', fromsubclass_=False, pretty_print=True):
        super(physicalDescriptionNote, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('displayLabel', node)
        if value is not None and 'displayLabel' not in already_processed:
            already_processed.add('displayLabel')
            self.displayLabel = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('typeURI', node)
        if value is not None and 'typeURI' not in already_processed:
            already_processed.add('typeURI')
            self.typeURI = value
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.add('role')
            self.role = value
        value = find_attr_value_('arcrole', node)
        if value is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            self.arcrole = value
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.add('title')
            self.title = value
        value = find_attr_value_('show', node)
        if value is not None and 'show' not in already_processed:
            already_processed.add('show')
            self.show = value
        value = find_attr_value_('actuate', node)
        if value is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            self.actuate = value
        super(physicalDescriptionNote, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class physicalDescriptionNote


class extent(stringPlusLanguagePlusSupplied):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = stringPlusLanguagePlusSupplied
    def __init__(self, lang=None, script=None, transliteration=None, supplied='yes', unit=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(extent, self).__init__(lang, script, transliteration, supplied, valueOf_,  **kwargs_)
        self.unit = _cast(None, unit)
        self.unit_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, extent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if extent.subclass:
            return extent.subclass(*args_, **kwargs_)
        else:
            return extent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_unit(self):
        return self.unit
    def set_unit(self, unit):
        self.unit = unit
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(extent, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='extent', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('extent')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='extent')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='extent', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='extent'):
        super(extent, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='extent')
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            outfile.write(' unit=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.unit), input_name='unit')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='extent', fromsubclass_=False, pretty_print=True):
        super(extent, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            self.unit = value
        super(extent, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class extent


class text(stringPlusLanguage):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = stringPlusLanguage
    def __init__(self, lang=None, script=None, transliteration=None, displayLabel=None, type_='simple', href=None, role=None, arcrole=None, title=None, show=None, actuate=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(text, self).__init__(lang, script, transliteration, valueOf_,  **kwargs_)
        self.displayLabel = _cast(None, displayLabel)
        self.displayLabel_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.href = _cast(None, href)
        self.href_nsprefix_ = None
        self.role = _cast(None, role)
        self.role_nsprefix_ = None
        self.arcrole = _cast(None, arcrole)
        self.arcrole_nsprefix_ = None
        self.title = _cast(None, title)
        self.title_nsprefix_ = None
        self.show = _cast(None, show)
        self.show_nsprefix_ = None
        self.actuate = _cast(None, actuate)
        self.actuate_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, text)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if text.subclass:
            return text.subclass(*args_, **kwargs_)
        else:
            return text(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_displayLabel(self):
        return self.displayLabel
    def set_displayLabel(self, displayLabel):
        self.displayLabel = displayLabel
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_href(self):
        return self.href
    def set_href(self, href):
        self.href = href
    def get_role(self):
        return self.role
    def set_role(self, role):
        self.role = role
    def get_arcrole(self):
        return self.arcrole
    def set_arcrole(self, arcrole):
        self.arcrole = arcrole
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def get_show(self):
        return self.show
    def set_show(self, show):
        self.show = show
    def get_actuate(self):
        return self.actuate
    def set_actuate(self, actuate):
        self.actuate = actuate
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(text, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='text', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('text')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='text')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='text', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='text'):
        super(text, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='text')
        if self.displayLabel is not None and 'displayLabel' not in already_processed:
            already_processed.add('displayLabel')
            outfile.write(' displayLabel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.displayLabel), input_name='displayLabel')), ))
        if self.type_ != "simple" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.type_ != "simple" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (quote_attrib(self.href), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.add('role')
            outfile.write(' role=%s' % (quote_attrib(self.role), ))
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            outfile.write(' arcrole=%s' % (quote_attrib(self.arcrole), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.add('title')
            outfile.write(' title=%s' % (quote_attrib(self.title), ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.add('show')
            outfile.write(' show=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.show), input_name='show')), ))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            outfile.write(' actuate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.actuate), input_name='actuate')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='text', fromsubclass_=False, pretty_print=True):
        super(text, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('displayLabel', node)
        if value is not None and 'displayLabel' not in already_processed:
            already_processed.add('displayLabel')
            self.displayLabel = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.add('role')
            self.role = value
        value = find_attr_value_('arcrole', node)
        if value is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            self.arcrole = value
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.add('title')
            self.title = value
        value = find_attr_value_('show', node)
        if value is not None and 'show' not in already_processed:
            already_processed.add('show')
            self.show = value
        value = find_attr_value_('actuate', node)
        if value is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            self.actuate = value
        super(text, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class text


class dateDefinition(stringPlusLanguage):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = stringPlusLanguage
    def __init__(self, lang=None, script=None, transliteration=None, encoding=None, qualifier=None, point=None, keyDate='yes', calendar=None, valueOf_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(dateDefinition, self).__init__(lang, script, transliteration, valueOf_, extensiontype_,  **kwargs_)
        self.encoding = _cast(None, encoding)
        self.encoding_nsprefix_ = None
        self.qualifier = _cast(None, qualifier)
        self.qualifier_nsprefix_ = None
        self.point = _cast(None, point)
        self.point_nsprefix_ = None
        self.keyDate = _cast(None, keyDate)
        self.keyDate_nsprefix_ = None
        self.calendar = _cast(None, calendar)
        self.calendar_nsprefix_ = None
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, dateDefinition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if dateDefinition.subclass:
            return dateDefinition.subclass(*args_, **kwargs_)
        else:
            return dateDefinition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_encoding(self):
        return self.encoding
    def set_encoding(self, encoding):
        self.encoding = encoding
    def get_qualifier(self):
        return self.qualifier
    def set_qualifier(self, qualifier):
        self.qualifier = qualifier
    def get_point(self):
        return self.point
    def set_point(self, point):
        self.point = point
    def get_keyDate(self):
        return self.keyDate
    def set_keyDate(self, keyDate):
        self.keyDate = keyDate
    def get_calendar(self):
        return self.calendar
    def set_calendar(self, calendar):
        self.calendar = calendar
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(dateDefinition, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='dateDefinition', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('dateDefinition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='dateDefinition')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='dateDefinition', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='dateDefinition'):
        super(dateDefinition, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='dateDefinition')
        if self.encoding is not None and 'encoding' not in already_processed:
            already_processed.add('encoding')
            outfile.write(' encoding=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.encoding), input_name='encoding')), ))
        if self.qualifier is not None and 'qualifier' not in already_processed:
            already_processed.add('qualifier')
            outfile.write(' qualifier=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.qualifier), input_name='qualifier')), ))
        if self.point is not None and 'point' not in already_processed:
            already_processed.add('point')
            outfile.write(' point=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.point), input_name='point')), ))
        if self.keyDate != "yes" and 'keyDate' not in already_processed:
            already_processed.add('keyDate')
            outfile.write(' keyDate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.keyDate), input_name='keyDate')), ))
        if self.calendar is not None and 'calendar' not in already_processed:
            already_processed.add('calendar')
            outfile.write(' calendar=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.calendar), input_name='calendar')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='dateDefinition', fromsubclass_=False, pretty_print=True):
        super(dateDefinition, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('encoding', node)
        if value is not None and 'encoding' not in already_processed:
            already_processed.add('encoding')
            self.encoding = value
        value = find_attr_value_('qualifier', node)
        if value is not None and 'qualifier' not in already_processed:
            already_processed.add('qualifier')
            self.qualifier = value
        value = find_attr_value_('point', node)
        if value is not None and 'point' not in already_processed:
            already_processed.add('point')
            self.point = value
        value = find_attr_value_('keyDate', node)
        if value is not None and 'keyDate' not in already_processed:
            already_processed.add('keyDate')
            self.keyDate = value
        value = find_attr_value_('calendar', node)
        if value is not None and 'calendar' not in already_processed:
            already_processed.add('calendar')
            self.calendar = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(dateDefinition, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class dateDefinition


class publisherDefinition(stringPlusLanguagePlusSupplied):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = stringPlusLanguagePlusSupplied
    def __init__(self, lang=None, script=None, transliteration=None, supplied='yes', authority=None, authorityURI=None, valueURI=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(publisherDefinition, self).__init__(lang, script, transliteration, supplied, valueOf_,  **kwargs_)
        self.authority = _cast(None, authority)
        self.authority_nsprefix_ = None
        self.authorityURI = _cast(None, authorityURI)
        self.authorityURI_nsprefix_ = None
        self.valueURI = _cast(None, valueURI)
        self.valueURI_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, publisherDefinition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if publisherDefinition.subclass:
            return publisherDefinition.subclass(*args_, **kwargs_)
        else:
            return publisherDefinition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_authority(self):
        return self.authority
    def set_authority(self, authority):
        self.authority = authority
    def get_authorityURI(self):
        return self.authorityURI
    def set_authorityURI(self, authorityURI):
        self.authorityURI = authorityURI
    def get_valueURI(self):
        return self.valueURI
    def set_valueURI(self, valueURI):
        self.valueURI = valueURI
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(publisherDefinition, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='publisherDefinition', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('publisherDefinition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='publisherDefinition')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='publisherDefinition', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='publisherDefinition'):
        super(publisherDefinition, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='publisherDefinition')
        if self.authority is not None and 'authority' not in already_processed:
            already_processed.add('authority')
            outfile.write(' authority=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.authority), input_name='authority')), ))
        if self.authorityURI is not None and 'authorityURI' not in already_processed:
            already_processed.add('authorityURI')
            outfile.write(' authorityURI=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.authorityURI), input_name='authorityURI')), ))
        if self.valueURI is not None and 'valueURI' not in already_processed:
            already_processed.add('valueURI')
            outfile.write(' valueURI=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.valueURI), input_name='valueURI')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='publisherDefinition', fromsubclass_=False, pretty_print=True):
        super(publisherDefinition, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('authority', node)
        if value is not None and 'authority' not in already_processed:
            already_processed.add('authority')
            self.authority = value
        value = find_attr_value_('authorityURI', node)
        if value is not None and 'authorityURI' not in already_processed:
            already_processed.add('authorityURI')
            self.authorityURI = value
        value = find_attr_value_('valueURI', node)
        if value is not None and 'valueURI' not in already_processed:
            already_processed.add('valueURI')
            self.valueURI = value
        super(publisherDefinition, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class publisherDefinition


class placeTermDefinition(stringPlusLanguage):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = stringPlusLanguage
    def __init__(self, lang=None, script=None, transliteration=None, authorityURI=None, valueURI=None, authority=None, type_=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(placeTermDefinition, self).__init__(lang, script, transliteration, valueOf_,  **kwargs_)
        self.authorityURI = _cast(None, authorityURI)
        self.authorityURI_nsprefix_ = None
        self.valueURI = _cast(None, valueURI)
        self.valueURI_nsprefix_ = None
        self.authority = _cast(None, authority)
        self.authority_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, placeTermDefinition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if placeTermDefinition.subclass:
            return placeTermDefinition.subclass(*args_, **kwargs_)
        else:
            return placeTermDefinition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_authorityURI(self):
        return self.authorityURI
    def set_authorityURI(self, authorityURI):
        self.authorityURI = authorityURI
    def get_valueURI(self):
        return self.valueURI
    def set_valueURI(self, valueURI):
        self.valueURI = valueURI
    def get_authority(self):
        return self.authority
    def set_authority(self, authority):
        self.authority = authority
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_codeOrText(self, value):
        # Validate type codeOrText, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['code', 'text']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on codeOrText' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(placeTermDefinition, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='placeTermDefinition', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('placeTermDefinition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='placeTermDefinition')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='placeTermDefinition', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='placeTermDefinition'):
        super(placeTermDefinition, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='placeTermDefinition')
        if self.authorityURI is not None and 'authorityURI' not in already_processed:
            already_processed.add('authorityURI')
            outfile.write(' authorityURI=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.authorityURI), input_name='authorityURI')), ))
        if self.valueURI is not None and 'valueURI' not in already_processed:
            already_processed.add('valueURI')
            outfile.write(' valueURI=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.valueURI), input_name='valueURI')), ))
        if self.authority is not None and 'authority' not in already_processed:
            already_processed.add('authority')
            outfile.write(' authority=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.authority), input_name='authority')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='placeTermDefinition', fromsubclass_=False, pretty_print=True):
        super(placeTermDefinition, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('authorityURI', node)
        if value is not None and 'authorityURI' not in already_processed:
            already_processed.add('authorityURI')
            self.authorityURI = value
        value = find_attr_value_('valueURI', node)
        if value is not None and 'valueURI' not in already_processed:
            already_processed.add('valueURI')
            self.valueURI = value
        value = find_attr_value_('authority', node)
        if value is not None and 'authority' not in already_processed:
            already_processed.add('authority')
            self.authority = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_codeOrText(self.type_)    # validate type codeOrText
        super(placeTermDefinition, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class placeTermDefinition


class noteDefinition(stringPlusLanguage):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = stringPlusLanguage
    def __init__(self, lang=None, script=None, transliteration=None, displayLabel=None, type_='simple', typeURI=None, ID=None, altRepGroup=None, href=None, role=None, arcrole=None, title=None, show=None, actuate=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(noteDefinition, self).__init__(lang, script, transliteration, valueOf_,  **kwargs_)
        self.displayLabel = _cast(None, displayLabel)
        self.displayLabel_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.typeURI = _cast(None, typeURI)
        self.typeURI_nsprefix_ = None
        self.ID = _cast(None, ID)
        self.ID_nsprefix_ = None
        self.altRepGroup = _cast(None, altRepGroup)
        self.altRepGroup_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.href = _cast(None, href)
        self.href_nsprefix_ = None
        self.role = _cast(None, role)
        self.role_nsprefix_ = None
        self.arcrole = _cast(None, arcrole)
        self.arcrole_nsprefix_ = None
        self.title = _cast(None, title)
        self.title_nsprefix_ = None
        self.show = _cast(None, show)
        self.show_nsprefix_ = None
        self.actuate = _cast(None, actuate)
        self.actuate_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, noteDefinition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if noteDefinition.subclass:
            return noteDefinition.subclass(*args_, **kwargs_)
        else:
            return noteDefinition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_displayLabel(self):
        return self.displayLabel
    def set_displayLabel(self, displayLabel):
        self.displayLabel = displayLabel
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_typeURI(self):
        return self.typeURI
    def set_typeURI(self, typeURI):
        self.typeURI = typeURI
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_altRepGroup(self):
        return self.altRepGroup
    def set_altRepGroup(self, altRepGroup):
        self.altRepGroup = altRepGroup
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_href(self):
        return self.href
    def set_href(self, href):
        self.href = href
    def get_role(self):
        return self.role
    def set_role(self, role):
        self.role = role
    def get_arcrole(self):
        return self.arcrole
    def set_arcrole(self, arcrole):
        self.arcrole = arcrole
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def get_show(self):
        return self.show
    def set_show(self, show):
        self.show = show
    def get_actuate(self):
        return self.actuate
    def set_actuate(self, actuate):
        self.actuate = actuate
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(noteDefinition, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='noteDefinition', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('noteDefinition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='noteDefinition')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='noteDefinition', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='noteDefinition'):
        super(noteDefinition, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='noteDefinition')
        if self.displayLabel is not None and 'displayLabel' not in already_processed:
            already_processed.add('displayLabel')
            outfile.write(' displayLabel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.displayLabel), input_name='displayLabel')), ))
        if self.type_ != "simple" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.typeURI is not None and 'typeURI' not in already_processed:
            already_processed.add('typeURI')
            outfile.write(' typeURI=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.typeURI), input_name='typeURI')), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.altRepGroup is not None and 'altRepGroup' not in already_processed:
            already_processed.add('altRepGroup')
            outfile.write(' altRepGroup=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.altRepGroup), input_name='altRepGroup')), ))
        if self.type_ != "simple" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (quote_attrib(self.href), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.add('role')
            outfile.write(' role=%s' % (quote_attrib(self.role), ))
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            outfile.write(' arcrole=%s' % (quote_attrib(self.arcrole), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.add('title')
            outfile.write(' title=%s' % (quote_attrib(self.title), ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.add('show')
            outfile.write(' show=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.show), input_name='show')), ))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            outfile.write(' actuate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.actuate), input_name='actuate')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='noteDefinition', fromsubclass_=False, pretty_print=True):
        super(noteDefinition, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('displayLabel', node)
        if value is not None and 'displayLabel' not in already_processed:
            already_processed.add('displayLabel')
            self.displayLabel = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('typeURI', node)
        if value is not None and 'typeURI' not in already_processed:
            already_processed.add('typeURI')
            self.typeURI = value
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('altRepGroup', node)
        if value is not None and 'altRepGroup' not in already_processed:
            already_processed.add('altRepGroup')
            self.altRepGroup = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.add('role')
            self.role = value
        value = find_attr_value_('arcrole', node)
        if value is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            self.arcrole = value
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.add('title')
            self.title = value
        value = find_attr_value_('show', node)
        if value is not None and 'show' not in already_processed:
            already_processed.add('show')
            self.show = value
        value = find_attr_value_('actuate', node)
        if value is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            self.actuate = value
        super(noteDefinition, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class noteDefinition


class roleTermDefinition(stringPlusLanguagePlusAuthority):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = stringPlusLanguagePlusAuthority
    def __init__(self, lang=None, script=None, transliteration=None, authority=None, authorityURI=None, valueURI=None, type_=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(roleTermDefinition, self).__init__(lang, script, transliteration, authority, authorityURI, valueURI, valueOf_,  **kwargs_)
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, roleTermDefinition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if roleTermDefinition.subclass:
            return roleTermDefinition.subclass(*args_, **kwargs_)
        else:
            return roleTermDefinition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_codeOrText(self, value):
        # Validate type codeOrText, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['code', 'text']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on codeOrText' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(roleTermDefinition, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='roleTermDefinition', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('roleTermDefinition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='roleTermDefinition')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='roleTermDefinition', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='roleTermDefinition'):
        super(roleTermDefinition, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='roleTermDefinition')
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='roleTermDefinition', fromsubclass_=False, pretty_print=True):
        super(roleTermDefinition, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_codeOrText(self.type_)    # validate type codeOrText
        super(roleTermDefinition, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class roleTermDefinition


class namePartDefinition(stringPlusLanguage):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = stringPlusLanguage
    def __init__(self, lang=None, script=None, transliteration=None, type_=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(namePartDefinition, self).__init__(lang, script, transliteration, valueOf_,  **kwargs_)
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, namePartDefinition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if namePartDefinition.subclass:
            return namePartDefinition.subclass(*args_, **kwargs_)
        else:
            return namePartDefinition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(namePartDefinition, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='namePartDefinition', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('namePartDefinition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='namePartDefinition')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='namePartDefinition', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='namePartDefinition'):
        super(namePartDefinition, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='namePartDefinition')
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='namePartDefinition', fromsubclass_=False, pretty_print=True):
        super(namePartDefinition, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        super(namePartDefinition, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class namePartDefinition


class enumerationAndChronologyDefinition(stringPlusLanguage):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = stringPlusLanguage
    def __init__(self, lang=None, script=None, transliteration=None, unitType=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(enumerationAndChronologyDefinition, self).__init__(lang, script, transliteration, valueOf_,  **kwargs_)
        self.unitType = _cast(None, unitType)
        self.unitType_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, enumerationAndChronologyDefinition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if enumerationAndChronologyDefinition.subclass:
            return enumerationAndChronologyDefinition.subclass(*args_, **kwargs_)
        else:
            return enumerationAndChronologyDefinition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_unitType(self):
        return self.unitType
    def set_unitType(self, unitType):
        self.unitType = unitType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(enumerationAndChronologyDefinition, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='enumerationAndChronologyDefinition', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('enumerationAndChronologyDefinition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='enumerationAndChronologyDefinition')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='enumerationAndChronologyDefinition', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='enumerationAndChronologyDefinition'):
        super(enumerationAndChronologyDefinition, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='enumerationAndChronologyDefinition')
        if self.unitType is not None and 'unitType' not in already_processed:
            already_processed.add('unitType')
            outfile.write(' unitType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.unitType), input_name='unitType')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='enumerationAndChronologyDefinition', fromsubclass_=False, pretty_print=True):
        super(enumerationAndChronologyDefinition, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('unitType', node)
        if value is not None and 'unitType' not in already_processed:
            already_processed.add('unitType')
            self.unitType = value
        super(enumerationAndChronologyDefinition, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class enumerationAndChronologyDefinition


class formDefinition(stringPlusLanguagePlusAuthority):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = stringPlusLanguagePlusAuthority
    def __init__(self, lang=None, script=None, transliteration=None, authority=None, authorityURI=None, valueURI=None, type_=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(formDefinition, self).__init__(lang, script, transliteration, authority, authorityURI, valueURI, valueOf_,  **kwargs_)
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, formDefinition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if formDefinition.subclass:
            return formDefinition.subclass(*args_, **kwargs_)
        else:
            return formDefinition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(formDefinition, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='formDefinition', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('formDefinition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='formDefinition')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='formDefinition', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='formDefinition'):
        super(formDefinition, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='formDefinition')
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='formDefinition', fromsubclass_=False, pretty_print=True):
        super(formDefinition, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        super(formDefinition, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class formDefinition


class itemIdentifierDefinition(stringPlusLanguage):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = stringPlusLanguage
    def __init__(self, lang=None, script=None, transliteration=None, type_=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(itemIdentifierDefinition, self).__init__(lang, script, transliteration, valueOf_,  **kwargs_)
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, itemIdentifierDefinition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if itemIdentifierDefinition.subclass:
            return itemIdentifierDefinition.subclass(*args_, **kwargs_)
        else:
            return itemIdentifierDefinition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(itemIdentifierDefinition, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='itemIdentifierDefinition', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('itemIdentifierDefinition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='itemIdentifierDefinition')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='itemIdentifierDefinition', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='itemIdentifierDefinition'):
        super(itemIdentifierDefinition, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='itemIdentifierDefinition')
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='itemIdentifierDefinition', fromsubclass_=False, pretty_print=True):
        super(itemIdentifierDefinition, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        super(itemIdentifierDefinition, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class itemIdentifierDefinition


class physicalLocationDefinition(stringPlusLanguagePlusAuthority):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = stringPlusLanguagePlusAuthority
    def __init__(self, lang=None, script=None, transliteration=None, authority=None, authorityURI=None, valueURI=None, displayLabel=None, type_='simple', href=None, role=None, arcrole=None, title=None, show=None, actuate=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(physicalLocationDefinition, self).__init__(lang, script, transliteration, authority, authorityURI, valueURI, valueOf_,  **kwargs_)
        self.displayLabel = _cast(None, displayLabel)
        self.displayLabel_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.href = _cast(None, href)
        self.href_nsprefix_ = None
        self.role = _cast(None, role)
        self.role_nsprefix_ = None
        self.arcrole = _cast(None, arcrole)
        self.arcrole_nsprefix_ = None
        self.title = _cast(None, title)
        self.title_nsprefix_ = None
        self.show = _cast(None, show)
        self.show_nsprefix_ = None
        self.actuate = _cast(None, actuate)
        self.actuate_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, physicalLocationDefinition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if physicalLocationDefinition.subclass:
            return physicalLocationDefinition.subclass(*args_, **kwargs_)
        else:
            return physicalLocationDefinition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_displayLabel(self):
        return self.displayLabel
    def set_displayLabel(self, displayLabel):
        self.displayLabel = displayLabel
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_href(self):
        return self.href
    def set_href(self, href):
        self.href = href
    def get_role(self):
        return self.role
    def set_role(self, role):
        self.role = role
    def get_arcrole(self):
        return self.arcrole
    def set_arcrole(self, arcrole):
        self.arcrole = arcrole
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def get_show(self):
        return self.show
    def set_show(self, show):
        self.show = show
    def get_actuate(self):
        return self.actuate
    def set_actuate(self, actuate):
        self.actuate = actuate
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(physicalLocationDefinition, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='physicalLocationDefinition', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('physicalLocationDefinition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='physicalLocationDefinition')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='physicalLocationDefinition', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='physicalLocationDefinition'):
        super(physicalLocationDefinition, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='physicalLocationDefinition')
        if self.displayLabel is not None and 'displayLabel' not in already_processed:
            already_processed.add('displayLabel')
            outfile.write(' displayLabel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.displayLabel), input_name='displayLabel')), ))
        if self.type_ != "simple" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.type_ != "simple" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (quote_attrib(self.href), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.add('role')
            outfile.write(' role=%s' % (quote_attrib(self.role), ))
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            outfile.write(' arcrole=%s' % (quote_attrib(self.arcrole), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.add('title')
            outfile.write(' title=%s' % (quote_attrib(self.title), ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.add('show')
            outfile.write(' show=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.show), input_name='show')), ))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            outfile.write(' actuate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.actuate), input_name='actuate')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='physicalLocationDefinition', fromsubclass_=False, pretty_print=True):
        super(physicalLocationDefinition, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('displayLabel', node)
        if value is not None and 'displayLabel' not in already_processed:
            already_processed.add('displayLabel')
            self.displayLabel = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.add('role')
            self.role = value
        value = find_attr_value_('arcrole', node)
        if value is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            self.arcrole = value
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.add('title')
            self.title = value
        value = find_attr_value_('show', node)
        if value is not None and 'show' not in already_processed:
            already_processed.add('show')
            self.show = value
        value = find_attr_value_('actuate', node)
        if value is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            self.actuate = value
        super(physicalLocationDefinition, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class physicalLocationDefinition


class scriptTermDefinition(stringPlusLanguagePlusAuthority):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = stringPlusLanguagePlusAuthority
    def __init__(self, lang=None, script=None, transliteration=None, authority=None, authorityURI=None, valueURI=None, type_=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(scriptTermDefinition, self).__init__(lang, script, transliteration, authority, authorityURI, valueURI, valueOf_,  **kwargs_)
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, scriptTermDefinition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if scriptTermDefinition.subclass:
            return scriptTermDefinition.subclass(*args_, **kwargs_)
        else:
            return scriptTermDefinition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_codeOrText(self, value):
        # Validate type codeOrText, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['code', 'text']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on codeOrText' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(scriptTermDefinition, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='scriptTermDefinition', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('scriptTermDefinition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='scriptTermDefinition')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='scriptTermDefinition', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='scriptTermDefinition'):
        super(scriptTermDefinition, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='scriptTermDefinition')
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='scriptTermDefinition', fromsubclass_=False, pretty_print=True):
        super(scriptTermDefinition, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_codeOrText(self.type_)    # validate type codeOrText
        super(scriptTermDefinition, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class scriptTermDefinition


class languageTermDefinition(stringPlusLanguage):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = stringPlusLanguage
    def __init__(self, lang=None, script=None, transliteration=None, authorityURI=None, valueURI=None, authority=None, type_=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(languageTermDefinition, self).__init__(lang, script, transliteration, valueOf_,  **kwargs_)
        self.authorityURI = _cast(None, authorityURI)
        self.authorityURI_nsprefix_ = None
        self.valueURI = _cast(None, valueURI)
        self.valueURI_nsprefix_ = None
        self.authority = _cast(None, authority)
        self.authority_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, languageTermDefinition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if languageTermDefinition.subclass:
            return languageTermDefinition.subclass(*args_, **kwargs_)
        else:
            return languageTermDefinition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_authorityURI(self):
        return self.authorityURI
    def set_authorityURI(self, authorityURI):
        self.authorityURI = authorityURI
    def get_valueURI(self):
        return self.valueURI
    def set_valueURI(self, valueURI):
        self.valueURI = valueURI
    def get_authority(self):
        return self.authority
    def set_authority(self, authority):
        self.authority = authority
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_codeOrText(self, value):
        # Validate type codeOrText, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['code', 'text']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on codeOrText' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(languageTermDefinition, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='languageTermDefinition', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('languageTermDefinition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='languageTermDefinition')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='languageTermDefinition', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='languageTermDefinition'):
        super(languageTermDefinition, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='languageTermDefinition')
        if self.authorityURI is not None and 'authorityURI' not in already_processed:
            already_processed.add('authorityURI')
            outfile.write(' authorityURI=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.authorityURI), input_name='authorityURI')), ))
        if self.valueURI is not None and 'valueURI' not in already_processed:
            already_processed.add('valueURI')
            outfile.write(' valueURI=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.valueURI), input_name='valueURI')), ))
        if self.authority is not None and 'authority' not in already_processed:
            already_processed.add('authority')
            outfile.write(' authority=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.authority), input_name='authority')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='languageTermDefinition', fromsubclass_=False, pretty_print=True):
        super(languageTermDefinition, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('authorityURI', node)
        if value is not None and 'authorityURI' not in already_processed:
            already_processed.add('authorityURI')
            self.authorityURI = value
        value = find_attr_value_('valueURI', node)
        if value is not None and 'valueURI' not in already_processed:
            already_processed.add('valueURI')
            self.valueURI = value
        value = find_attr_value_('authority', node)
        if value is not None and 'authority' not in already_processed:
            already_processed.add('authority')
            self.authority = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_codeOrText(self.type_)    # validate type codeOrText
        super(languageTermDefinition, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class languageTermDefinition


class identifierDefinition(stringPlusLanguage):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = stringPlusLanguage
    def __init__(self, lang=None, script=None, transliteration=None, displayLabel=None, type_=None, typeURI=None, invalid='yes', altRepGroup=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(identifierDefinition, self).__init__(lang, script, transliteration, valueOf_,  **kwargs_)
        self.displayLabel = _cast(None, displayLabel)
        self.displayLabel_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.typeURI = _cast(None, typeURI)
        self.typeURI_nsprefix_ = None
        self.invalid = _cast(None, invalid)
        self.invalid_nsprefix_ = None
        self.altRepGroup = _cast(None, altRepGroup)
        self.altRepGroup_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, identifierDefinition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if identifierDefinition.subclass:
            return identifierDefinition.subclass(*args_, **kwargs_)
        else:
            return identifierDefinition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_displayLabel(self):
        return self.displayLabel
    def set_displayLabel(self, displayLabel):
        self.displayLabel = displayLabel
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_typeURI(self):
        return self.typeURI
    def set_typeURI(self, typeURI):
        self.typeURI = typeURI
    def get_invalid(self):
        return self.invalid
    def set_invalid(self, invalid):
        self.invalid = invalid
    def get_altRepGroup(self):
        return self.altRepGroup
    def set_altRepGroup(self, altRepGroup):
        self.altRepGroup = altRepGroup
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(identifierDefinition, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='identifierDefinition', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('identifierDefinition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='identifierDefinition')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='identifierDefinition', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='identifierDefinition'):
        super(identifierDefinition, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='identifierDefinition')
        if self.displayLabel is not None and 'displayLabel' not in already_processed:
            already_processed.add('displayLabel')
            outfile.write(' displayLabel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.displayLabel), input_name='displayLabel')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.typeURI is not None and 'typeURI' not in already_processed:
            already_processed.add('typeURI')
            outfile.write(' typeURI=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.typeURI), input_name='typeURI')), ))
        if self.invalid != "yes" and 'invalid' not in already_processed:
            already_processed.add('invalid')
            outfile.write(' invalid=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.invalid), input_name='invalid')), ))
        if self.altRepGroup is not None and 'altRepGroup' not in already_processed:
            already_processed.add('altRepGroup')
            outfile.write(' altRepGroup=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.altRepGroup), input_name='altRepGroup')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='identifierDefinition', fromsubclass_=False, pretty_print=True):
        super(identifierDefinition, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('displayLabel', node)
        if value is not None and 'displayLabel' not in already_processed:
            already_processed.add('displayLabel')
            self.displayLabel = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('typeURI', node)
        if value is not None and 'typeURI' not in already_processed:
            already_processed.add('typeURI')
            self.typeURI = value
        value = find_attr_value_('invalid', node)
        if value is not None and 'invalid' not in already_processed:
            already_processed.add('invalid')
            self.invalid = value
        value = find_attr_value_('altRepGroup', node)
        if value is not None and 'altRepGroup' not in already_processed:
            already_processed.add('altRepGroup')
            self.altRepGroup = value
        super(identifierDefinition, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class identifierDefinition


class genreDefinition(stringPlusLanguagePlusAuthority):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = stringPlusLanguagePlusAuthority
    def __init__(self, lang=None, script=None, transliteration=None, authority=None, authorityURI=None, valueURI=None, type_=None, displayLabel=None, altRepGroup=None, usage='primary', valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(genreDefinition, self).__init__(lang, script, transliteration, authority, authorityURI, valueURI, valueOf_,  **kwargs_)
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.displayLabel = _cast(None, displayLabel)
        self.displayLabel_nsprefix_ = None
        self.altRepGroup = _cast(None, altRepGroup)
        self.altRepGroup_nsprefix_ = None
        self.usage = _cast(None, usage)
        self.usage_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, genreDefinition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if genreDefinition.subclass:
            return genreDefinition.subclass(*args_, **kwargs_)
        else:
            return genreDefinition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_displayLabel(self):
        return self.displayLabel
    def set_displayLabel(self, displayLabel):
        self.displayLabel = displayLabel
    def get_altRepGroup(self):
        return self.altRepGroup
    def set_altRepGroup(self, altRepGroup):
        self.altRepGroup = altRepGroup
    def get_usage(self):
        return self.usage
    def set_usage(self, usage):
        self.usage = usage
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(genreDefinition, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='genreDefinition', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('genreDefinition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='genreDefinition')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='genreDefinition', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='genreDefinition'):
        super(genreDefinition, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='genreDefinition')
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.displayLabel is not None and 'displayLabel' not in already_processed:
            already_processed.add('displayLabel')
            outfile.write(' displayLabel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.displayLabel), input_name='displayLabel')), ))
        if self.altRepGroup is not None and 'altRepGroup' not in already_processed:
            already_processed.add('altRepGroup')
            outfile.write(' altRepGroup=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.altRepGroup), input_name='altRepGroup')), ))
        if self.usage != "primary" and 'usage' not in already_processed:
            already_processed.add('usage')
            outfile.write(' usage=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.usage), input_name='usage')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='genreDefinition', fromsubclass_=False, pretty_print=True):
        super(genreDefinition, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('displayLabel', node)
        if value is not None and 'displayLabel' not in already_processed:
            already_processed.add('displayLabel')
            self.displayLabel = value
        value = find_attr_value_('altRepGroup', node)
        if value is not None and 'altRepGroup' not in already_processed:
            already_processed.add('altRepGroup')
            self.altRepGroup = value
        value = find_attr_value_('usage', node)
        if value is not None and 'usage' not in already_processed:
            already_processed.add('usage')
            self.usage = value
        super(genreDefinition, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class genreDefinition


class classificationDefinition(stringPlusLanguagePlusAuthority):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = stringPlusLanguagePlusAuthority
    def __init__(self, lang=None, script=None, transliteration=None, authority=None, authorityURI=None, valueURI=None, edition=None, displayLabel=None, altRepGroup=None, usage='primary', generator=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(classificationDefinition, self).__init__(lang, script, transliteration, authority, authorityURI, valueURI, valueOf_,  **kwargs_)
        self.edition = _cast(None, edition)
        self.edition_nsprefix_ = None
        self.displayLabel = _cast(None, displayLabel)
        self.displayLabel_nsprefix_ = None
        self.altRepGroup = _cast(None, altRepGroup)
        self.altRepGroup_nsprefix_ = None
        self.usage = _cast(None, usage)
        self.usage_nsprefix_ = None
        self.generator = _cast(None, generator)
        self.generator_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, classificationDefinition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if classificationDefinition.subclass:
            return classificationDefinition.subclass(*args_, **kwargs_)
        else:
            return classificationDefinition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_edition(self):
        return self.edition
    def set_edition(self, edition):
        self.edition = edition
    def get_displayLabel(self):
        return self.displayLabel
    def set_displayLabel(self, displayLabel):
        self.displayLabel = displayLabel
    def get_altRepGroup(self):
        return self.altRepGroup
    def set_altRepGroup(self, altRepGroup):
        self.altRepGroup = altRepGroup
    def get_usage(self):
        return self.usage
    def set_usage(self, usage):
        self.usage = usage
    def get_generator(self):
        return self.generator
    def set_generator(self, generator):
        self.generator = generator
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(classificationDefinition, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='classificationDefinition', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('classificationDefinition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='classificationDefinition')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='classificationDefinition', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='classificationDefinition'):
        super(classificationDefinition, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='classificationDefinition')
        if self.edition is not None and 'edition' not in already_processed:
            already_processed.add('edition')
            outfile.write(' edition=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.edition), input_name='edition')), ))
        if self.displayLabel is not None and 'displayLabel' not in already_processed:
            already_processed.add('displayLabel')
            outfile.write(' displayLabel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.displayLabel), input_name='displayLabel')), ))
        if self.altRepGroup is not None and 'altRepGroup' not in already_processed:
            already_processed.add('altRepGroup')
            outfile.write(' altRepGroup=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.altRepGroup), input_name='altRepGroup')), ))
        if self.usage != "primary" and 'usage' not in already_processed:
            already_processed.add('usage')
            outfile.write(' usage=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.usage), input_name='usage')), ))
        if self.generator is not None and 'generator' not in already_processed:
            already_processed.add('generator')
            outfile.write(' generator=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.generator), input_name='generator')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='classificationDefinition', fromsubclass_=False, pretty_print=True):
        super(classificationDefinition, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('edition', node)
        if value is not None and 'edition' not in already_processed:
            already_processed.add('edition')
            self.edition = value
        value = find_attr_value_('displayLabel', node)
        if value is not None and 'displayLabel' not in already_processed:
            already_processed.add('displayLabel')
            self.displayLabel = value
        value = find_attr_value_('altRepGroup', node)
        if value is not None and 'altRepGroup' not in already_processed:
            already_processed.add('altRepGroup')
            self.altRepGroup = value
        value = find_attr_value_('usage', node)
        if value is not None and 'usage' not in already_processed:
            already_processed.add('usage')
            self.usage = value
        value = find_attr_value_('generator', node)
        if value is not None and 'generator' not in already_processed:
            already_processed.add('generator')
            self.generator = value
        super(classificationDefinition, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class classificationDefinition


class accessConditionDefinition(extensionDefinition):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = extensionDefinition
    def __init__(self, displayLabel=None, anytypeobjs_=None, type_='simple', altRepGroup=None, href=None, role=None, arcrole=None, title=None, show=None, actuate=None, lang=None, script=None, transliteration=None, altFormat=None, contentType=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(accessConditionDefinition, self).__init__(displayLabel, anytypeobjs_, valueOf_, mixedclass_, content_,  **kwargs_)
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.altRepGroup = _cast(None, altRepGroup)
        self.altRepGroup_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.href = _cast(None, href)
        self.href_nsprefix_ = None
        self.role = _cast(None, role)
        self.role_nsprefix_ = None
        self.arcrole = _cast(None, arcrole)
        self.arcrole_nsprefix_ = None
        self.title = _cast(None, title)
        self.title_nsprefix_ = None
        self.show = _cast(None, show)
        self.show_nsprefix_ = None
        self.actuate = _cast(None, actuate)
        self.actuate_nsprefix_ = None
        self.lang = _cast(None, lang)
        self.lang_nsprefix_ = None
        self.lang = _cast(None, lang)
        self.lang_nsprefix_ = None
        self.script = _cast(None, script)
        self.script_nsprefix_ = None
        self.transliteration = _cast(None, transliteration)
        self.transliteration_nsprefix_ = None
        self.altFormat = _cast(None, altFormat)
        self.altFormat_nsprefix_ = None
        self.contentType = _cast(None, contentType)
        self.contentType_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, accessConditionDefinition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if accessConditionDefinition.subclass:
            return accessConditionDefinition.subclass(*args_, **kwargs_)
        else:
            return accessConditionDefinition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_altRepGroup(self):
        return self.altRepGroup
    def set_altRepGroup(self, altRepGroup):
        self.altRepGroup = altRepGroup
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_href(self):
        return self.href
    def set_href(self, href):
        self.href = href
    def get_role(self):
        return self.role
    def set_role(self, role):
        self.role = role
    def get_arcrole(self):
        return self.arcrole
    def set_arcrole(self, arcrole):
        self.arcrole = arcrole
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def get_show(self):
        return self.show
    def set_show(self, show):
        self.show = show
    def get_actuate(self):
        return self.actuate
    def set_actuate(self, actuate):
        self.actuate = actuate
    def get_lang(self):
        return self.lang
    def set_lang(self, lang):
        self.lang = lang
    def get_lang(self):
        return self.lang
    def set_lang(self, lang):
        self.lang = lang
    def get_script(self):
        return self.script
    def set_script(self, script):
        self.script = script
    def get_transliteration(self):
        return self.transliteration
    def set_transliteration(self, transliteration):
        self.transliteration = transliteration
    def get_altFormat(self):
        return self.altFormat
    def set_altFormat(self, altFormat):
        self.altFormat = altFormat
    def get_contentType(self):
        return self.contentType
    def set_contentType(self, contentType):
        self.contentType = contentType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(accessConditionDefinition, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='accessConditionDefinition', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('accessConditionDefinition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='accessConditionDefinition')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='accessConditionDefinition', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='accessConditionDefinition'):
        super(accessConditionDefinition, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='accessConditionDefinition')
        if self.type_ != "simple" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.altRepGroup is not None and 'altRepGroup' not in already_processed:
            already_processed.add('altRepGroup')
            outfile.write(' altRepGroup=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.altRepGroup), input_name='altRepGroup')), ))
        if self.type_ != "simple" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (quote_attrib(self.href), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.add('role')
            outfile.write(' role=%s' % (quote_attrib(self.role), ))
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            outfile.write(' arcrole=%s' % (quote_attrib(self.arcrole), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.add('title')
            outfile.write(' title=%s' % (quote_attrib(self.title), ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.add('show')
            outfile.write(' show=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.show), input_name='show')), ))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            outfile.write(' actuate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.actuate), input_name='actuate')), ))
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lang), input_name='lang')), ))
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lang), input_name='lang')), ))
        if self.script is not None and 'script' not in already_processed:
            already_processed.add('script')
            outfile.write(' script=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.script), input_name='script')), ))
        if self.transliteration is not None and 'transliteration' not in already_processed:
            already_processed.add('transliteration')
            outfile.write(' transliteration=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.transliteration), input_name='transliteration')), ))
        if self.altFormat is not None and 'altFormat' not in already_processed:
            already_processed.add('altFormat')
            outfile.write(' altFormat=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.altFormat), input_name='altFormat')), ))
        if self.contentType is not None and 'contentType' not in already_processed:
            already_processed.add('contentType')
            outfile.write(' contentType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.contentType), input_name='contentType')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='accessConditionDefinition', fromsubclass_=False, pretty_print=True):
        super(accessConditionDefinition, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('altRepGroup', node)
        if value is not None and 'altRepGroup' not in already_processed:
            already_processed.add('altRepGroup')
            self.altRepGroup = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.add('role')
            self.role = value
        value = find_attr_value_('arcrole', node)
        if value is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            self.arcrole = value
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.add('title')
            self.title = value
        value = find_attr_value_('show', node)
        if value is not None and 'show' not in already_processed:
            already_processed.add('show')
            self.show = value
        value = find_attr_value_('actuate', node)
        if value is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            self.actuate = value
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        value = find_attr_value_('script', node)
        if value is not None and 'script' not in already_processed:
            already_processed.add('script')
            self.script = value
        value = find_attr_value_('transliteration', node)
        if value is not None and 'transliteration' not in already_processed:
            already_processed.add('transliteration')
            self.transliteration = value
        value = find_attr_value_('altFormat', node)
        if value is not None and 'altFormat' not in already_processed:
            already_processed.add('altFormat')
            self.altFormat = value
        value = find_attr_value_('contentType', node)
        if value is not None and 'contentType' not in already_processed:
            already_processed.add('contentType')
            self.contentType = value
        super(accessConditionDefinition, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(accessConditionDefinition, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class accessConditionDefinition


class abstractDefinition(stringPlusLanguage):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = stringPlusLanguage
    def __init__(self, lang=None, script=None, transliteration=None, displayLabel=None, type_='simple', shareable='no', altRepGroup=None, href=None, role=None, arcrole=None, title=None, show=None, actuate=None, altFormat=None, contentType=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(abstractDefinition, self).__init__(lang, script, transliteration, valueOf_,  **kwargs_)
        self.displayLabel = _cast(None, displayLabel)
        self.displayLabel_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.shareable = _cast(None, shareable)
        self.shareable_nsprefix_ = None
        self.altRepGroup = _cast(None, altRepGroup)
        self.altRepGroup_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.href = _cast(None, href)
        self.href_nsprefix_ = None
        self.role = _cast(None, role)
        self.role_nsprefix_ = None
        self.arcrole = _cast(None, arcrole)
        self.arcrole_nsprefix_ = None
        self.title = _cast(None, title)
        self.title_nsprefix_ = None
        self.show = _cast(None, show)
        self.show_nsprefix_ = None
        self.actuate = _cast(None, actuate)
        self.actuate_nsprefix_ = None
        self.altFormat = _cast(None, altFormat)
        self.altFormat_nsprefix_ = None
        self.contentType = _cast(None, contentType)
        self.contentType_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, abstractDefinition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if abstractDefinition.subclass:
            return abstractDefinition.subclass(*args_, **kwargs_)
        else:
            return abstractDefinition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_displayLabel(self):
        return self.displayLabel
    def set_displayLabel(self, displayLabel):
        self.displayLabel = displayLabel
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_shareable(self):
        return self.shareable
    def set_shareable(self, shareable):
        self.shareable = shareable
    def get_altRepGroup(self):
        return self.altRepGroup
    def set_altRepGroup(self, altRepGroup):
        self.altRepGroup = altRepGroup
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_href(self):
        return self.href
    def set_href(self, href):
        self.href = href
    def get_role(self):
        return self.role
    def set_role(self, role):
        self.role = role
    def get_arcrole(self):
        return self.arcrole
    def set_arcrole(self, arcrole):
        self.arcrole = arcrole
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def get_show(self):
        return self.show
    def set_show(self, show):
        self.show = show
    def get_actuate(self):
        return self.actuate
    def set_actuate(self, actuate):
        self.actuate = actuate
    def get_altFormat(self):
        return self.altFormat
    def set_altFormat(self, altFormat):
        self.altFormat = altFormat
    def get_contentType(self):
        return self.contentType
    def set_contentType(self, contentType):
        self.contentType = contentType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(abstractDefinition, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='abstractDefinition', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('abstractDefinition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='abstractDefinition')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='abstractDefinition', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='abstractDefinition'):
        super(abstractDefinition, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='abstractDefinition')
        if self.displayLabel is not None and 'displayLabel' not in already_processed:
            already_processed.add('displayLabel')
            outfile.write(' displayLabel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.displayLabel), input_name='displayLabel')), ))
        if self.type_ != "simple" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.shareable != "no" and 'shareable' not in already_processed:
            already_processed.add('shareable')
            outfile.write(' shareable=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.shareable), input_name='shareable')), ))
        if self.altRepGroup is not None and 'altRepGroup' not in already_processed:
            already_processed.add('altRepGroup')
            outfile.write(' altRepGroup=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.altRepGroup), input_name='altRepGroup')), ))
        if self.type_ != "simple" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (quote_attrib(self.href), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.add('role')
            outfile.write(' role=%s' % (quote_attrib(self.role), ))
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            outfile.write(' arcrole=%s' % (quote_attrib(self.arcrole), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.add('title')
            outfile.write(' title=%s' % (quote_attrib(self.title), ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.add('show')
            outfile.write(' show=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.show), input_name='show')), ))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            outfile.write(' actuate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.actuate), input_name='actuate')), ))
        if self.altFormat is not None and 'altFormat' not in already_processed:
            already_processed.add('altFormat')
            outfile.write(' altFormat=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.altFormat), input_name='altFormat')), ))
        if self.contentType is not None and 'contentType' not in already_processed:
            already_processed.add('contentType')
            outfile.write(' contentType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.contentType), input_name='contentType')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='abstractDefinition', fromsubclass_=False, pretty_print=True):
        super(abstractDefinition, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('displayLabel', node)
        if value is not None and 'displayLabel' not in already_processed:
            already_processed.add('displayLabel')
            self.displayLabel = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('shareable', node)
        if value is not None and 'shareable' not in already_processed:
            already_processed.add('shareable')
            self.shareable = value
        value = find_attr_value_('altRepGroup', node)
        if value is not None and 'altRepGroup' not in already_processed:
            already_processed.add('altRepGroup')
            self.altRepGroup = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.add('role')
            self.role = value
        value = find_attr_value_('arcrole', node)
        if value is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            self.arcrole = value
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.add('title')
            self.title = value
        value = find_attr_value_('show', node)
        if value is not None and 'show' not in already_processed:
            already_processed.add('show')
            self.show = value
        value = find_attr_value_('actuate', node)
        if value is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            self.actuate = value
        value = find_attr_value_('altFormat', node)
        if value is not None and 'altFormat' not in already_processed:
            already_processed.add('altFormat')
            self.altFormat = value
        value = find_attr_value_('contentType', node)
        if value is not None and 'contentType' not in already_processed:
            already_processed.add('contentType')
            self.contentType = value
        super(abstractDefinition, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class abstractDefinition


class citySectionDefinition(hierarchicalPart):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = hierarchicalPart
    def __init__(self, lang=None, script=None, transliteration=None, level=None, period=None, authority=None, authorityURI=None, valueURI=None, citySectionType=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(citySectionDefinition, self).__init__(lang, script, transliteration, level, period, authority, authorityURI, valueURI, valueOf_,  **kwargs_)
        self.citySectionType = _cast(None, citySectionType)
        self.citySectionType_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, citySectionDefinition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if citySectionDefinition.subclass:
            return citySectionDefinition.subclass(*args_, **kwargs_)
        else:
            return citySectionDefinition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_citySectionType(self):
        return self.citySectionType
    def set_citySectionType(self, citySectionType):
        self.citySectionType = citySectionType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(citySectionDefinition, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='citySectionDefinition', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('citySectionDefinition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='citySectionDefinition')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='citySectionDefinition', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='citySectionDefinition'):
        super(citySectionDefinition, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='citySectionDefinition')
        if self.citySectionType is not None and 'citySectionType' not in already_processed:
            already_processed.add('citySectionType')
            outfile.write(' citySectionType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.citySectionType), input_name='citySectionType')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='citySectionDefinition', fromsubclass_=False, pretty_print=True):
        super(citySectionDefinition, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('citySectionType', node)
        if value is not None and 'citySectionType' not in already_processed:
            already_processed.add('citySectionType')
            self.citySectionType = value
        super(citySectionDefinition, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class citySectionDefinition


class regionDefinition(hierarchicalPart):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = hierarchicalPart
    def __init__(self, lang=None, script=None, transliteration=None, level=None, period=None, authority=None, authorityURI=None, valueURI=None, regionType=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(regionDefinition, self).__init__(lang, script, transliteration, level, period, authority, authorityURI, valueURI, valueOf_,  **kwargs_)
        self.regionType = _cast(None, regionType)
        self.regionType_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, regionDefinition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if regionDefinition.subclass:
            return regionDefinition.subclass(*args_, **kwargs_)
        else:
            return regionDefinition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_regionType(self):
        return self.regionType
    def set_regionType(self, regionType):
        self.regionType = regionType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(regionDefinition, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='regionDefinition', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('regionDefinition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='regionDefinition')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='regionDefinition', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='regionDefinition'):
        super(regionDefinition, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='regionDefinition')
        if self.regionType is not None and 'regionType' not in already_processed:
            already_processed.add('regionType')
            outfile.write(' regionType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.regionType), input_name='regionType')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='regionDefinition', fromsubclass_=False, pretty_print=True):
        super(regionDefinition, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('regionType', node)
        if value is not None and 'regionType' not in already_processed:
            already_processed.add('regionType')
            self.regionType = value
        super(regionDefinition, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class regionDefinition


class areaDefinition(hierarchicalPart):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = hierarchicalPart
    def __init__(self, lang=None, script=None, transliteration=None, level=None, period=None, authority=None, authorityURI=None, valueURI=None, areaType=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(areaDefinition, self).__init__(lang, script, transliteration, level, period, authority, authorityURI, valueURI, valueOf_,  **kwargs_)
        self.areaType = _cast(None, areaType)
        self.areaType_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, areaDefinition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if areaDefinition.subclass:
            return areaDefinition.subclass(*args_, **kwargs_)
        else:
            return areaDefinition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_areaType(self):
        return self.areaType
    def set_areaType(self, areaType):
        self.areaType = areaType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(areaDefinition, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='areaDefinition', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('areaDefinition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='areaDefinition')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='areaDefinition', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='areaDefinition'):
        super(areaDefinition, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='areaDefinition')
        if self.areaType is not None and 'areaType' not in already_processed:
            already_processed.add('areaType')
            outfile.write(' areaType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.areaType), input_name='areaType')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='areaDefinition', fromsubclass_=False, pretty_print=True):
        super(areaDefinition, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('areaType', node)
        if value is not None and 'areaType' not in already_processed:
            already_processed.add('areaType')
            self.areaType = value
        super(areaDefinition, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class areaDefinition


class temporalDefinition(dateDefinition):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = dateDefinition
    def __init__(self, lang=None, script=None, transliteration=None, encoding=None, qualifier=None, point=None, keyDate='yes', calendar=None, authority=None, authorityURI=None, valueURI=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(temporalDefinition, self).__init__(lang, script, transliteration, encoding, qualifier, point, keyDate, calendar, valueOf_,  **kwargs_)
        self.authority = _cast(None, authority)
        self.authority_nsprefix_ = None
        self.authorityURI = _cast(None, authorityURI)
        self.authorityURI_nsprefix_ = None
        self.valueURI = _cast(None, valueURI)
        self.valueURI_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, temporalDefinition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if temporalDefinition.subclass:
            return temporalDefinition.subclass(*args_, **kwargs_)
        else:
            return temporalDefinition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_authority(self):
        return self.authority
    def set_authority(self, authority):
        self.authority = authority
    def get_authorityURI(self):
        return self.authorityURI
    def set_authorityURI(self, authorityURI):
        self.authorityURI = authorityURI
    def get_valueURI(self):
        return self.valueURI
    def set_valueURI(self, valueURI):
        self.valueURI = valueURI
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(temporalDefinition, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='temporalDefinition', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('temporalDefinition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='temporalDefinition')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='temporalDefinition', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='temporalDefinition'):
        super(temporalDefinition, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='temporalDefinition')
        if self.authority is not None and 'authority' not in already_processed:
            already_processed.add('authority')
            outfile.write(' authority=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.authority), input_name='authority')), ))
        if self.authorityURI is not None and 'authorityURI' not in already_processed:
            already_processed.add('authorityURI')
            outfile.write(' authorityURI=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.authorityURI), input_name='authorityURI')), ))
        if self.valueURI is not None and 'valueURI' not in already_processed:
            already_processed.add('valueURI')
            outfile.write(' valueURI=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.valueURI), input_name='valueURI')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='temporalDefinition', fromsubclass_=False, pretty_print=True):
        super(temporalDefinition, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('authority', node)
        if value is not None and 'authority' not in already_processed:
            already_processed.add('authority')
            self.authority = value
        value = find_attr_value_('authorityURI', node)
        if value is not None and 'authorityURI' not in already_processed:
            already_processed.add('authorityURI')
            self.authorityURI = value
        value = find_attr_value_('valueURI', node)
        if value is not None and 'valueURI' not in already_processed:
            already_processed.add('valueURI')
            self.valueURI = value
        super(temporalDefinition, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class temporalDefinition


class dateOtherDefinition(dateDefinition):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = dateDefinition
    def __init__(self, lang=None, script=None, transliteration=None, encoding=None, qualifier=None, point=None, keyDate='yes', calendar=None, type_=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(dateOtherDefinition, self).__init__(lang, script, transliteration, encoding, qualifier, point, keyDate, calendar, valueOf_,  **kwargs_)
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, dateOtherDefinition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if dateOtherDefinition.subclass:
            return dateOtherDefinition.subclass(*args_, **kwargs_)
        else:
            return dateOtherDefinition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(dateOtherDefinition, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='dateOtherDefinition', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('dateOtherDefinition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='dateOtherDefinition')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='dateOtherDefinition', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='dateOtherDefinition'):
        super(dateOtherDefinition, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='dateOtherDefinition')
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='dateOtherDefinition', fromsubclass_=False, pretty_print=True):
        super(dateOtherDefinition, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        super(dateOtherDefinition, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class dateOtherDefinition


GDSClassesMapping = {
    'abstract': abstractDefinition,
    'accessCondition': accessConditionDefinition,
    'affiliation': stringPlusLanguage,
    'alternativeName': alternativeNameDefinition,
    'area': areaDefinition,
    'caption': stringPlusLanguage,
    'cartographicExtension': extensionDefinition,
    'cartographics': cartographicsDefinition,
    'city': hierarchicalPart,
    'citySection': citySectionDefinition,
    'classification': classificationDefinition,
    'continent': hierarchicalPart,
    'coordinates': stringPlusLanguage,
    'copyInformation': copyInformationDefinition,
    'copyrightDate': dateDefinition,
    'country': hierarchicalPart,
    'county': hierarchicalPart,
    'date': dateDefinition,
    'dateCaptured': dateDefinition,
    'dateCreated': dateDefinition,
    'dateIssued': dateDefinition,
    'dateModified': dateDefinition,
    'dateOther': dateOtherDefinition,
    'dateValid': dateDefinition,
    'description': stringPlusLanguage,
    'descriptionStandard': stringPlusLanguagePlusAuthority,
    'detail': detailDefinition,
    'displayForm': stringPlusLanguage,
    'edition': stringPlusLanguagePlusSupplied,
    'electronicLocator': stringPlusLanguage,
    'end': stringPlusLanguage,
    'enumerationAndChronology': enumerationAndChronologyDefinition,
    'etal': stringPlusLanguage,
    'extension': extensionDefinition,
    'extraTerrestrialArea': hierarchicalPart,
    'form': formDefinition,
    'frequency': stringPlusLanguagePlusAuthority,
    'genre': genreDefinition,
    'geographic': stringPlusLanguagePlusAuthority,
    'geographicCode': geographicCodeDefinition,
    'hierarchicalGeographic': hierarchicalGeographicDefinition,
    'holdingExternal': extensionDefinition,
    'holdingSimple': holdingSimpleDefinition,
    'identifier': identifierDefinition,
    'internetMediaType': stringPlusLanguage,
    'island': hierarchicalPart,
    'itemIdentifier': itemIdentifierDefinition,
    'language': languageDefinition,
    'languageOfCataloging': languageDefinition,
    'languageTerm': languageTermDefinition,
    'list': stringPlusLanguage,
    'location': locationDefinition,
    'mods': modsDefinition,
    'modsCollection': modsCollectionDefinition,
    'name': nameDefinition,
    'nameIdentifier': identifierDefinition,
    'namePart': namePartDefinition,
    'note': noteDefinition,
    'number': stringPlusLanguage,
    'occupation': stringPlusLanguagePlusAuthority,
    'originInfo': originInfoDefinition,
    'part': partDefinition,
    'partName': stringPlusLanguage,
    'partNumber': stringPlusLanguage,
    'physicalDescription': physicalDescriptionDefinition,
    'physicalLocation': physicalLocationDefinition,
    'place': placeDefinition,
    'placeTerm': placeTermDefinition,
    'projection': stringPlusLanguage,
    'province': stringPlusLanguage,
    'publisher': publisherDefinition,
    'recordChangeDate': dateDefinition,
    'recordContentSource': stringPlusLanguagePlusAuthority,
    'recordCreationDate': dateDefinition,
    'recordIdentifier': recordIdentifierDefinition,
    'recordInfo': recordInfoDefinition,
    'recordInfoNote': noteDefinition,
    'recordOrigin': stringPlusLanguage,
    'region': regionDefinition,
    'relatedItem': relatedItemDefinition,
    'role': roleDefinition,
    'roleTerm': roleTermDefinition,
    'scale': stringPlusLanguage,
    'scriptTerm': scriptTermDefinition,
    'shelfLocator': stringPlusLanguage,
    'start': stringPlusLanguage,
    'state': hierarchicalPart,
    'subLocation': stringPlusLanguage,
    'subTitle': stringPlusLanguage,
    'subject': subjectDefinition,
    'tableOfContents': tableOfContentsDefinition,
    'targetAudience': targetAudienceDefinition,
    'temporal': temporalDefinition,
    'territory': hierarchicalPart,
    'title': stringPlusLanguage,
    'titleInfo': titleInfoDefinition,
    'topic': stringPlusLanguagePlusAuthority,
    'typeOfResource': typeOfResourceDefinition,
    'url': urlDefinition,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def get_required_ns_prefix_defs(rootNode):
    '''Get all name space prefix definitions required in this XML doc.
    Return a dictionary of definitions and a char string of definitions.
    '''
    nsmap = {
        prefix: uri
        for node in rootNode.iter()
        for (prefix, uri) in node.nsmap.items()
        if prefix is not None
    }
    namespacedefs = ' '.join([
        'xmlns:{}="{}"'.format(prefix, uri)
        for prefix, uri in nsmap.items()
    ])
    return nsmap, namespacedefs


def parse(inFileName, silence=False, print_warnings=True):
    global CapturedNsmap_
    gds_collector = GdsCollector_()
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'mods'
        rootClass = mods
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    CapturedNsmap_, namespacedefs = get_required_ns_prefix_defs(rootNode)
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_=namespacedefs,
            pretty_print=True)
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseEtree(inFileName, silence=False, print_warnings=True):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'mods'
        rootClass = mods
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    # Enable Python to collect the space used by the DOM.
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(str(content))
        sys.stdout.write('\n')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False, print_warnings=True):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    gds_collector = GdsCollector_()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'mods'
        rootClass = mods
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    if not SaveElementTreeNode:
        rootNode = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseLiteral(inFileName, silence=False, print_warnings=True):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'mods'
        rootClass = mods
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    # Enable Python to collect the space used by the DOM.
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        sys.stdout.write('#from mods_generateds import *\n\n')
        sys.stdout.write('import mods_generateds as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()

RenameMappings_ = {
}

__all__ = [
    "abstractDefinition",
    "accessConditionDefinition",
    "alternativeNameDefinition",
    "areaDefinition",
    "cartographicsDefinition",
    "citySectionDefinition",
    "classificationDefinition",
    "copyInformationDefinition",
    "dateDefinition",
    "dateOtherDefinition",
    "detailDefinition",
    "enumerationAndChronologyDefinition",
    "extensionDefinition",
    "extent",
    "extentDefinition",
    "formDefinition",
    "genreDefinition",
    "geographicCodeDefinition",
    "hierarchicalGeographicDefinition",
    "hierarchicalPart",
    "holdingSimpleDefinition",
    "identifierDefinition",
    "itemIdentifierDefinition",
    "languageDefinition",
    "languageTermDefinition",
    "locationDefinition",
    "modsCollectionDefinition",
    "modsDefinition",
    "nameDefinition",
    "namePartDefinition",
    "nonSort",
    "noteDefinition",
    "noteType",
    "originInfoDefinition",
    "partDefinition",
    "physicalDescriptionDefinition",
    "physicalDescriptionNote",
    "physicalLocationDefinition",
    "placeDefinition",
    "placeTermDefinition",
    "publisherDefinition",
    "recordIdentifierDefinition",
    "recordInfoDefinition",
    "regionDefinition",
    "relatedItemDefinition",
    "roleDefinition",
    "roleTermDefinition",
    "scriptTermDefinition",
    "stringPlusLanguage",
    "stringPlusLanguagePlusAuthority",
    "stringPlusLanguagePlusSupplied",
    "subjectDefinition",
    "subjectNameDefinition",
    "subjectTitleInfoDefinition",
    "tableOfContentsDefinition",
    "targetAudienceDefinition",
    "temporalDefinition",
    "text",
    "titleInfoDefinition",
    "typeOfResourceDefinition",
    "urlDefinition"
]
