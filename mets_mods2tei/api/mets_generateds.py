#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Tue Nov 19 09:11:01 2019 by generateDS.py version 2.32.0.
# Python 3.6.7 (default, Oct 22 2018, 11:32:17)  [GCC 8.2.0]
#
# Command line options:
#   ('-f', '')
#   ('--root-element', 'mets')
#   ('-o', 'mets_mods2teiHeader/api/mets_generateds.py')
#
# Command line arguments:
#   mets.xsd
#
# Command line:
#   /home/kmw/Documents/Work/SLUB/src/mets-mods2teiHeader/env/bin/generateDS -f --root-element="mets" -o "mets_mods2teiHeader/api/mets_generateds.py" mets.xsd
#
# Current working directory (os.getcwd()):
#   mets-mods2teiHeader
#

import os
import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
import decimal as decimal_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    try:
        if isinstance(infile, os.PathLike):
            infile = os.path.join(infile)
    except AttributeError:
        pass
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for an example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#
# Additionally, the generatedsnamespaces module can contain a python
# dictionary named GenerateDSNamespaceTypePrefixes that associates element
# types with the namespace prefixes that are to be added to the
# "xsi:type" attribute value.  See the exportAttributes method of
# any generated element type and the generation of "xsi:type" for an
# example of the use of this table.
# An example table:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceTypePrefixes = {
#         "ElementtypeC": "aaa:",
#         "ElementtypeD": "bbb:",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}
try:
    from generatedsnamespaces import GenerateDSNamespaceTypePrefixes as GenerateDSNamespaceTypePrefixes_
except ImportError:
    GenerateDSNamespaceTypePrefixes_ = {}

#
# The super-class for enum types
#

try:
    from enum import Enum
except ImportError:
    Enum = object

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:
    
    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_parse_string(self, input_data, node=None, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_parse_integer(self, input_data, node=None, input_name=''):
            try:
                ival = int(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'requires integer: %s' % exp)
            return ival
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_parse_float(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'requires float or double: %s' % exp)
            return fval_
        def gds_validate_float(self, input_data, node=None, input_name=''):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires sequence of floats')
            return value
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_decimal(self, input_data, input_name=''):
            return ('%0.10f' % input_data).rstrip('0')
        def gds_parse_decimal(self, input_data, node=None, input_name=''):
            try:
                decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return input_data
        def gds_validate_decimal(self, input_data, node=None, input_name=''):
            try:
                value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return value
        def gds_format_decimal_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_decimal_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    decimal_.Decimal(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of decimal values')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_parse_double(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'requires float or double: %s' % exp)
            return fval_
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_parse_boolean(self, input_data, node=None, input_name=''):
            if input_data in ('true', '1'):
                bval = True
            elif input_data in ('false', '0'):
                bval = False
            else:
                raise_parse_error(node, 'requires boolean')
            return bval
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (
                    time_parts[0], "{}".format(micro_seconds).rjust(6, "0"), )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.
            # The target value must match at least one of the patterns
            # in order for the test to succeed.
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    mo = re_.search(patterns2, target)
                    if mo is not None and len(mo.group(0)) == len(target):
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            content = etree_.tostring(node, encoding="unicode")
            return content
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.items()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                if ExternalEncoding:
                    encoding = ExternalEncoding
                else:
                    encoding = 'utf-8'
                return instring.encode(encoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            if type(self) != type(other):
                return False
            return self.__dict__ == other.__dict__
        def __ne__(self, other):
            return not self.__eq__(other)
        # Django ETL transform hooks.
        def gds_djo_etl_transform(self):
            pass
        def gds_djo_etl_transform_db_obj(self, dbobj):
            pass
        # SQLAlchemy ETL transform hooks.
        def gds_sqa_etl_transform(self):
            return 0, None
        def gds_sqa_etl_transform_db_obj(self, dbobj):
            pass
    
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = ''
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if node is not None:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name_=name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class metsType(GeneratedsSuper):
    """metsType: Complex Type for METS Sections
    A METS document consists of seven possible subsidiary sections: metsHdr
    (METS document header), dmdSec (descriptive metadata section), amdSec
    (administrative metadata section), fileGrp (file inventory group),
    structLink (structural map linking), structMap (structural map) and
    behaviorSec (behaviors section).
    ID (ID/O): This attribute uniquely identifies the element within the METS
    document, and would allow the element to be referenced unambiguously
    from another element or document via an IDREF or an XPTR. For more
    information on using ID attributes for internal and external linking
    see Chapter 4 of the METS Primer.
    OBJID (string/O): Is the primary identifier assigned to the METS object as
    a whole. Although this attribute is not required, it is strongly
    recommended. This identifier is used to tag the entire METS object to
    external systems, in contrast with the ID identifier.
    LABEL (string/O): Is a simple title string used to identify the
    object/entity being described in the METS document for the user.
    TYPE (string/O): Specifies the class or type of the object, e.g.: book,
    journal, stereograph, dataset, video, etc.
    PROFILE (string/O): Indicates to which of the registered profile(s) the
    METS document conforms. For additional information about PROFILES see
    Chapter 5 of the METS Primer."""
    subclass = None
    superclass = None
    def __init__(self, ID=None, OBJID=None, LABEL=None, TYPE=None, PROFILE=None, metsHdr=None, dmdSec=None, amdSec=None, fileSec=None, structMap=None, structLink=None, behaviorSec=None, extensiontype_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ID = _cast(None, ID)
        self.OBJID = _cast(None, OBJID)
        self.LABEL = _cast(None, LABEL)
        self.TYPE = _cast(None, TYPE)
        self.PROFILE = _cast(None, PROFILE)
        self.metsHdr = metsHdr
        if dmdSec is None:
            self.dmdSec = []
        else:
            self.dmdSec = dmdSec
        if amdSec is None:
            self.amdSec = []
        else:
            self.amdSec = amdSec
        self.fileSec = fileSec
        if structMap is None:
            self.structMap = []
        else:
            self.structMap = structMap
        self.structLink = structLink
        if behaviorSec is None:
            self.behaviorSec = []
        else:
            self.behaviorSec = behaviorSec
        self.anyAttributes_ = {}
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, metsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if metsType.subclass:
            return metsType.subclass(*args_, **kwargs_)
        else:
            return metsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_metsHdr(self):
        return self.metsHdr
    def set_metsHdr(self, metsHdr):
        self.metsHdr = metsHdr
    def get_dmdSec(self):
        return self.dmdSec
    def set_dmdSec(self, dmdSec):
        self.dmdSec = dmdSec
    def add_dmdSec(self, value):
        self.dmdSec.append(value)
    def insert_dmdSec_at(self, index, value):
        self.dmdSec.insert(index, value)
    def replace_dmdSec_at(self, index, value):
        self.dmdSec[index] = value
    def get_amdSec(self):
        return self.amdSec
    def set_amdSec(self, amdSec):
        self.amdSec = amdSec
    def add_amdSec(self, value):
        self.amdSec.append(value)
    def insert_amdSec_at(self, index, value):
        self.amdSec.insert(index, value)
    def replace_amdSec_at(self, index, value):
        self.amdSec[index] = value
    def get_fileSec(self):
        return self.fileSec
    def set_fileSec(self, fileSec):
        self.fileSec = fileSec
    def get_structMap(self):
        return self.structMap
    def set_structMap(self, structMap):
        self.structMap = structMap
    def add_structMap(self, value):
        self.structMap.append(value)
    def insert_structMap_at(self, index, value):
        self.structMap.insert(index, value)
    def replace_structMap_at(self, index, value):
        self.structMap[index] = value
    def get_structLink(self):
        return self.structLink
    def set_structLink(self, structLink):
        self.structLink = structLink
    def get_behaviorSec(self):
        return self.behaviorSec
    def set_behaviorSec(self, behaviorSec):
        self.behaviorSec = behaviorSec
    def add_behaviorSec(self, value):
        self.behaviorSec.append(value)
    def insert_behaviorSec_at(self, index, value):
        self.behaviorSec.insert(index, value)
    def replace_behaviorSec_at(self, index, value):
        self.behaviorSec[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_OBJID(self):
        return self.OBJID
    def set_OBJID(self, OBJID):
        self.OBJID = OBJID
    def get_LABEL(self):
        return self.LABEL
    def set_LABEL(self, LABEL):
        self.LABEL = LABEL
    def get_TYPE(self):
        return self.TYPE
    def set_TYPE(self, TYPE):
        self.TYPE = TYPE
    def get_PROFILE(self):
        return self.PROFILE
    def set_PROFILE(self, PROFILE):
        self.PROFILE = PROFILE
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.metsHdr is not None or
            self.dmdSec or
            self.amdSec or
            self.fileSec is not None or
            self.structMap or
            self.structLink is not None or
            self.behaviorSec
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='metsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('metsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='metsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, '', namespacedef_, name_='metsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='metsType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' %d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.OBJID is not None and 'OBJID' not in already_processed:
            already_processed.add('OBJID')
            outfile.write(' OBJID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.OBJID), input_name='OBJID')), ))
        if self.LABEL is not None and 'LABEL' not in already_processed:
            already_processed.add('LABEL')
            outfile.write(' LABEL=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.LABEL), input_name='LABEL')), ))
        if self.TYPE is not None and 'TYPE' not in already_processed:
            already_processed.add('TYPE')
            outfile.write(' TYPE=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.TYPE), input_name='TYPE')), ))
        if self.PROFILE is not None and 'PROFILE' not in already_processed:
            already_processed.add('PROFILE')
            outfile.write(' PROFILE=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.PROFILE), input_name='PROFILE')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='metsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.metsHdr is not None:
            self.metsHdr.export(outfile, level, namespaceprefix_, namespacedef_='', name_='metsHdr', pretty_print=pretty_print)
        for dmdSec_ in self.dmdSec:
            dmdSec_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dmdSec', pretty_print=pretty_print)
        for amdSec_ in self.amdSec:
            amdSec_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='amdSec', pretty_print=pretty_print)
        if self.fileSec is not None:
            self.fileSec.export(outfile, level, namespaceprefix_, namespacedef_='', name_='fileSec', pretty_print=pretty_print)
        for structMap_ in self.structMap:
            structMap_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='structMap', pretty_print=pretty_print)
        if self.structLink is not None:
            self.structLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='structLink', pretty_print=pretty_print)
        for behaviorSec_ in self.behaviorSec:
            behaviorSec_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='behaviorSec', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('OBJID', node)
        if value is not None and 'OBJID' not in already_processed:
            already_processed.add('OBJID')
            self.OBJID = value
        value = find_attr_value_('LABEL', node)
        if value is not None and 'LABEL' not in already_processed:
            already_processed.add('LABEL')
            self.LABEL = value
        value = find_attr_value_('TYPE', node)
        if value is not None and 'TYPE' not in already_processed:
            already_processed.add('TYPE')
            self.TYPE = value
        value = find_attr_value_('PROFILE', node)
        if value is not None and 'PROFILE' not in already_processed:
            already_processed.add('PROFILE')
            self.PROFILE = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'metsHdr':
            obj_ = metsHdrType.factory(parent_object_=self)
            obj_.build(child_)
            self.metsHdr = obj_
            obj_.original_tagname_ = 'metsHdr'
        elif nodeName_ == 'dmdSec':
            obj_ = mdSecType.factory(parent_object_=self)
            obj_.build(child_)
            self.dmdSec.append(obj_)
            obj_.original_tagname_ = 'dmdSec'
        elif nodeName_ == 'amdSec':
            obj_ = amdSecType.factory(parent_object_=self)
            obj_.build(child_)
            self.amdSec.append(obj_)
            obj_.original_tagname_ = 'amdSec'
        elif nodeName_ == 'fileSec':
            obj_ = fileSecType.factory(parent_object_=self)
            obj_.build(child_)
            self.fileSec = obj_
            obj_.original_tagname_ = 'fileSec'
        elif nodeName_ == 'structMap':
            obj_ = structMapType.factory(parent_object_=self)
            obj_.build(child_)
            self.structMap.append(obj_)
            obj_.original_tagname_ = 'structMap'
        elif nodeName_ == 'structLink':
            obj_ = structLinkType2.factory(parent_object_=self)
            obj_.build(child_)
            self.structLink = obj_
            obj_.original_tagname_ = 'structLink'
        elif nodeName_ == 'behaviorSec':
            obj_ = behaviorSecType.factory(parent_object_=self)
            obj_.build(child_)
            self.behaviorSec.append(obj_)
            obj_.original_tagname_ = 'behaviorSec'
# end class metsType


class amdSecType(GeneratedsSuper):
    """amdSecType: Complex Type for Administrative Metadata Sections
    The administrative metadata section consists of four possible subsidiary
    sections: techMD (technical metadata for text/image/audio/video files),
    rightsMD (intellectual property rights metadata), sourceMD
    (analog/digital source metadata), and digiprovMD (digital provenance
    metadata, that is, the history of migrations/translations performed on
    a digital library object from it's original digital capture/encoding).
    ID (ID/O): This attribute uniquely identifies the element within the METS
    document, and would allow the element to be referenced unambiguously
    from another element or document via an IDREF or an XPTR. For more
    information on using ID attributes for internal and external linking
    see Chapter 4 of the METS Primer."""
    subclass = None
    superclass = None
    def __init__(self, ID=None, techMD=None, rightsMD=None, sourceMD=None, digiprovMD=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ID = _cast(None, ID)
        if techMD is None:
            self.techMD = []
        else:
            self.techMD = techMD
        if rightsMD is None:
            self.rightsMD = []
        else:
            self.rightsMD = rightsMD
        if sourceMD is None:
            self.sourceMD = []
        else:
            self.sourceMD = sourceMD
        if digiprovMD is None:
            self.digiprovMD = []
        else:
            self.digiprovMD = digiprovMD
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, amdSecType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if amdSecType.subclass:
            return amdSecType.subclass(*args_, **kwargs_)
        else:
            return amdSecType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_techMD(self):
        return self.techMD
    def set_techMD(self, techMD):
        self.techMD = techMD
    def add_techMD(self, value):
        self.techMD.append(value)
    def insert_techMD_at(self, index, value):
        self.techMD.insert(index, value)
    def replace_techMD_at(self, index, value):
        self.techMD[index] = value
    def get_rightsMD(self):
        return self.rightsMD
    def set_rightsMD(self, rightsMD):
        self.rightsMD = rightsMD
    def add_rightsMD(self, value):
        self.rightsMD.append(value)
    def insert_rightsMD_at(self, index, value):
        self.rightsMD.insert(index, value)
    def replace_rightsMD_at(self, index, value):
        self.rightsMD[index] = value
    def get_sourceMD(self):
        return self.sourceMD
    def set_sourceMD(self, sourceMD):
        self.sourceMD = sourceMD
    def add_sourceMD(self, value):
        self.sourceMD.append(value)
    def insert_sourceMD_at(self, index, value):
        self.sourceMD.insert(index, value)
    def replace_sourceMD_at(self, index, value):
        self.sourceMD[index] = value
    def get_digiprovMD(self):
        return self.digiprovMD
    def set_digiprovMD(self, digiprovMD):
        self.digiprovMD = digiprovMD
    def add_digiprovMD(self, value):
        self.digiprovMD.append(value)
    def insert_digiprovMD_at(self, index, value):
        self.digiprovMD.insert(index, value)
    def replace_digiprovMD_at(self, index, value):
        self.digiprovMD[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.techMD or
            self.rightsMD or
            self.sourceMD or
            self.digiprovMD
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='amdSecType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('amdSecType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='amdSecType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, '', namespacedef_, name_='amdSecType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='amdSecType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' %d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='amdSecType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for techMD_ in self.techMD:
            techMD_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='techMD', pretty_print=pretty_print)
        for rightsMD_ in self.rightsMD:
            rightsMD_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='rightsMD', pretty_print=pretty_print)
        for sourceMD_ in self.sourceMD:
            sourceMD_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sourceMD', pretty_print=pretty_print)
        for digiprovMD_ in self.digiprovMD:
            digiprovMD_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='digiprovMD', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'techMD':
            obj_ = mdSecType.factory(parent_object_=self)
            obj_.build(child_)
            self.techMD.append(obj_)
            obj_.original_tagname_ = 'techMD'
        elif nodeName_ == 'rightsMD':
            obj_ = mdSecType.factory(parent_object_=self)
            obj_.build(child_)
            self.rightsMD.append(obj_)
            obj_.original_tagname_ = 'rightsMD'
        elif nodeName_ == 'sourceMD':
            obj_ = mdSecType.factory(parent_object_=self)
            obj_.build(child_)
            self.sourceMD.append(obj_)
            obj_.original_tagname_ = 'sourceMD'
        elif nodeName_ == 'digiprovMD':
            obj_ = mdSecType.factory(parent_object_=self)
            obj_.build(child_)
            self.digiprovMD.append(obj_)
            obj_.original_tagname_ = 'digiprovMD'
# end class amdSecType


class fileGrpType(GeneratedsSuper):
    """fileGrpType: Complex Type for File Groups
    The file group is used to cluster all of the digital files composing a
    digital library object in a hierarchical arrangement (fileGrp is
    recursively defined to enable the creation of the hierarchy). Any file
    group may contain zero or more file elements. File elements in turn can
    contain one or more FLocat elements (a pointer to a file containing
    content for this object) and/or a FContent element (the contents of the
    file, in either XML or Base64 encoding).
    ID (ID/O): This attribute uniquely identifies the element within the METS
    document, and would allow the element to be referenced unambiguously
    from another element or document via an IDREF or an XPTR. For more
    information on using ID attributes for internal and external linking
    see Chapter 4 of the METS Primer.
    VERSDATE (dateTime/O): An optional dateTime attribute specifying the date
    this version/fileGrp of the digital object was created.
    ADMID (IDREF/O): Contains the ID attribute values of the <techMD>,
    <sourceMD>, <rightsMD> and/or <digiprovMD> elements within the <amdSec>
    of the METS document applicable to all of the files in a particular
    file group. For more information on using METS IDREFS and IDREF type
    attributes for internal linking, see Chapter 4 of the METS Primer.
    USE (string/O): A tagging attribute to indicate the intended use of files
    within this file group (e.g., master, reference, thumbnails for image
    files). A USE attribute can be expressed at the<fileGrp> level, the
    <file> level, the <FLocat> level and/or the <FContent> level. A USE
    attribute value at the <fileGrp> level should pertain to all of the
    files in the <fileGrp>. A USE attribute at the <file> level should
    pertain to all copies of the file as represented by subsidiary <FLocat>
    and/or <FContent> elements. A USE attribute at the <FLocat> or
    <FContent> level pertains to the particular copy of the file that is
    either referenced (<FLocat>) or wrapped (<FContent>)."""
    subclass = None
    superclass = None
    def __init__(self, ID=None, VERSDATE=None, ADMID=None, USE=None, fileGrp=None, file=None, extensiontype_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ID = _cast(None, ID)
        if isinstance(VERSDATE, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(VERSDATE, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = VERSDATE
        self.VERSDATE = initvalue_
        self.ADMID = _cast(None, ADMID)
        self.USE = _cast(None, USE)
        if fileGrp is None:
            self.fileGrp = []
        else:
            self.fileGrp = fileGrp
        if file is None:
            self.file = []
        else:
            self.file = file
        self.anyAttributes_ = {}
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, fileGrpType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if fileGrpType.subclass:
            return fileGrpType.subclass(*args_, **kwargs_)
        else:
            return fileGrpType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_fileGrp(self):
        return self.fileGrp
    def set_fileGrp(self, fileGrp):
        self.fileGrp = fileGrp
    def add_fileGrp(self, value):
        self.fileGrp.append(value)
    def insert_fileGrp_at(self, index, value):
        self.fileGrp.insert(index, value)
    def replace_fileGrp_at(self, index, value):
        self.fileGrp[index] = value
    def get_file(self):
        return self.file
    def set_file(self, file):
        self.file = file
    def add_file(self, value):
        self.file.append(value)
    def insert_file_at(self, index, value):
        self.file.insert(index, value)
    def replace_file_at(self, index, value):
        self.file[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_VERSDATE(self):
        return self.VERSDATE
    def set_VERSDATE(self, VERSDATE):
        self.VERSDATE = VERSDATE
    def get_ADMID(self):
        return self.ADMID
    def set_ADMID(self, ADMID):
        self.ADMID = ADMID
    def get_USE(self):
        return self.USE
    def set_USE(self, USE):
        self.USE = USE
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.fileGrp or
            self.file
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='fileGrpType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('fileGrpType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='fileGrpType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, '', namespacedef_, name_='fileGrpType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='fileGrpType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' %d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.VERSDATE is not None and 'VERSDATE' not in already_processed:
            already_processed.add('VERSDATE')
            outfile.write(' VERSDATE="%s"' % self.gds_format_datetime(self.VERSDATE, input_name='VERSDATE'))
        if self.ADMID is not None and 'ADMID' not in already_processed:
            already_processed.add('ADMID')
            outfile.write(' ADMID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ADMID), input_name='ADMID')), ))
        if self.USE is not None and 'USE' not in already_processed:
            already_processed.add('USE')
            outfile.write(' USE=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.USE), input_name='USE')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='fileGrpType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for fileGrp_ in self.fileGrp:
            fileGrp_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='fileGrp', pretty_print=pretty_print)
        for file_ in self.file:
            file_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='file', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('VERSDATE', node)
        if value is not None and 'VERSDATE' not in already_processed:
            already_processed.add('VERSDATE')
            try:
                self.VERSDATE = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (VERSDATE): %s' % exp)
        value = find_attr_value_('ADMID', node)
        if value is not None and 'ADMID' not in already_processed:
            already_processed.add('ADMID')
            self.ADMID = value
        value = find_attr_value_('USE', node)
        if value is not None and 'USE' not in already_processed:
            already_processed.add('USE')
            self.USE = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'fileGrp':
            class_obj_ = self.get_class_obj_(child_, fileGrpType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_)
            self.fileGrp.append(obj_)
            obj_.original_tagname_ = 'fileGrp'
        elif nodeName_ == 'file':
            obj_ = fileType.factory(parent_object_=self)
            obj_.build(child_)
            self.file.append(obj_)
            obj_.original_tagname_ = 'file'
# end class fileGrpType


class structMapType(GeneratedsSuper):
    """structMapType: Complex Type for Structural Maps
    The structural map (structMap) outlines a hierarchical structure for the
    original object being encoded, using a series of nested div elements.
    ID (ID/O): This attribute uniquely identifies the element within the METS
    document, and would allow the element to be referenced unambiguously
    from another element or document via an IDREF or an XPTR. For more
    information on using ID attributes for internal and external linking
    see Chapter 4 of the METS Primer.
    TYPE (string/O): Identifies the type of structure represented by the
    <structMap>. For example, a <structMap> that represented a purely
    logical or intellectual structure could be assigned a TYPE value of
    logical whereas a <structMap> that represented a purely physical
    structure could be assigned a TYPE value of physical. However, the
    METS schema neither defines nor requires a common vocabulary for this
    attribute. A METS profile, however, may well constrain the values for
    the <structMap> TYPE.
    LABEL (string/O): Describes the <structMap> to viewers of the METS
    document. This would be useful primarily where more than one
    <structMap> is provided for a single object. A descriptive LABEL value,
    in that case, could clarify to users the purpose of each of the
    available structMaps."""
    subclass = None
    superclass = None
    def __init__(self, ID=None, TYPE=None, LABEL=None, div=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ID = _cast(None, ID)
        self.TYPE = _cast(None, TYPE)
        self.LABEL = _cast(None, LABEL)
        self.div = div
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, structMapType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if structMapType.subclass:
            return structMapType.subclass(*args_, **kwargs_)
        else:
            return structMapType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_div(self):
        return self.div
    def set_div(self, div):
        self.div = div
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_TYPE(self):
        return self.TYPE
    def set_TYPE(self, TYPE):
        self.TYPE = TYPE
    def get_LABEL(self):
        return self.LABEL
    def set_LABEL(self, LABEL):
        self.LABEL = LABEL
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.div is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='structMapType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('structMapType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='structMapType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, '', namespacedef_, name_='structMapType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='structMapType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' %d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.TYPE is not None and 'TYPE' not in already_processed:
            already_processed.add('TYPE')
            outfile.write(' TYPE=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.TYPE), input_name='TYPE')), ))
        if self.LABEL is not None and 'LABEL' not in already_processed:
            already_processed.add('LABEL')
            outfile.write(' LABEL=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.LABEL), input_name='LABEL')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='structMapType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.div is not None:
            self.div.export(outfile, level, namespaceprefix_, namespacedef_='', name_='div', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('TYPE', node)
        if value is not None and 'TYPE' not in already_processed:
            already_processed.add('TYPE')
            self.TYPE = value
        value = find_attr_value_('LABEL', node)
        if value is not None and 'LABEL' not in already_processed:
            already_processed.add('LABEL')
            self.LABEL = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'div':
            obj_ = divType.factory(parent_object_=self)
            obj_.build(child_)
            self.div = obj_
            obj_.original_tagname_ = 'div'
# end class structMapType


class divType(GeneratedsSuper):
    """divType: Complex Type for Divisions
    The METS standard represents a document structurally as a series of nested
    div elements, that is, as a hierarchy (e.g., a book, which is composed
    of chapters, which are composed of subchapters, which are composed of
    text). Every div node in the structural map hierarchy may be connected
    (via subsidiary mptr or fptr elements) to content files which represent
    that div's portion of the whole document.
    SPECIAL NOTE REGARDING DIV ATTRIBUTE VALUES:
    to clarify the differences between the ORDER, ORDERLABEL, and LABEL
    attributes for the <div> element, imagine a text with 10 roman numbered
    pages followed by 10 arabic numbered pages. Page iii would have an
    ORDER of "3", an ORDERLABEL of "iii" and a LABEL of "Page iii", while
    page 3 would have an ORDER of "13", an ORDERLABEL of "3" and a LABEL of
    "Page 3".
    ID (ID/O): This attribute uniquely identifies the element within the METS
    document, and would allow the element to be referenced unambiguously
    from another element or document via an IDREF or an XPTR. For more
    information on using ID attributes for internal and external linking
    see Chapter 4 of the METS Primer.
    DMDID (IDREFS/O): Contains the ID attribute values identifying the
    <dmdSec>, elements in the METS document that contain or link to
    descriptive metadata pertaining to the structural division represented
    by the current <div> element. For more information on using METS IDREFS
    and IDREF type attributes for internal linking, see Chapter 4 of the
    METS Primer.
    ADMID (IDREFS/O): Contains the ID attribute values identifying the
    <rightsMD>, <sourceMD>, <techMD> and/or <digiprovMD> elements within
    the <amdSec> of the METS document that contain or link to
    administrative metadata pertaining to the structural division
    represented by the <div> element. Typically the <div> ADMID attribute
    would be used to identify the <rightsMD> element or elements that
    pertain to the <div>, but it could be used anytime there was a need to
    link a <div> with pertinent administrative metadata. For more
    information on using METS IDREFS and IDREF type attributes for internal
    linking, see Chapter 4 of the METS Primer.
    TYPE (string/O): An attribute that specifies the type of structural
    division that the <div> element represents. Possible <div> TYPE
    attribute values include: chapter, article, page, track, segment,
    section etc. METS places no constraints on the possible TYPE values.
    Suggestions for controlled vocabularies for TYPE may be found on the
    METS website.
    CONTENTIDS (URI/O): Content IDs for the content represented by the <div>
    (equivalent to DIDL DII or Digital Item Identifier, a unique external
    ID).
    xlink:label - an xlink label to be referred to by an smLink element"""
    subclass = None
    superclass = None
    def __init__(self, ID=None, DMDID=None, ADMID=None, TYPE=None, CONTENTIDS=None, label=None, ORDER=None, ORDERLABEL=None, LABEL=None, mptr=None, fptr=None, div=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ID = _cast(None, ID)
        self.DMDID = _cast(None, DMDID)
        self.ADMID = _cast(None, ADMID)
        self.TYPE = _cast(None, TYPE)
        self.CONTENTIDS = _cast(None, CONTENTIDS)
        self.label = _cast(None, label)
        self.ORDER = _cast(int, ORDER)
        self.ORDERLABEL = _cast(None, ORDERLABEL)
        self.LABEL = _cast(None, LABEL)
        if mptr is None:
            self.mptr = []
        else:
            self.mptr = mptr
        if fptr is None:
            self.fptr = []
        else:
            self.fptr = fptr
        if div is None:
            self.div = []
        else:
            self.div = div
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, divType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if divType.subclass:
            return divType.subclass(*args_, **kwargs_)
        else:
            return divType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_mptr(self):
        return self.mptr
    def set_mptr(self, mptr):
        self.mptr = mptr
    def add_mptr(self, value):
        self.mptr.append(value)
    def insert_mptr_at(self, index, value):
        self.mptr.insert(index, value)
    def replace_mptr_at(self, index, value):
        self.mptr[index] = value
    def get_fptr(self):
        return self.fptr
    def set_fptr(self, fptr):
        self.fptr = fptr
    def add_fptr(self, value):
        self.fptr.append(value)
    def insert_fptr_at(self, index, value):
        self.fptr.insert(index, value)
    def replace_fptr_at(self, index, value):
        self.fptr[index] = value
    def get_div(self):
        return self.div
    def set_div(self, div):
        self.div = div
    def add_div(self, value):
        self.div.append(value)
    def insert_div_at(self, index, value):
        self.div.insert(index, value)
    def replace_div_at(self, index, value):
        self.div[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_DMDID(self):
        return self.DMDID
    def set_DMDID(self, DMDID):
        self.DMDID = DMDID
    def get_ADMID(self):
        return self.ADMID
    def set_ADMID(self, ADMID):
        self.ADMID = ADMID
    def get_TYPE(self):
        return self.TYPE
    def set_TYPE(self, TYPE):
        self.TYPE = TYPE
    def get_CONTENTIDS(self):
        return self.CONTENTIDS
    def set_CONTENTIDS(self, CONTENTIDS):
        self.CONTENTIDS = CONTENTIDS
    def get_label(self):
        return self.label
    def set_label(self, label):
        self.label = label
    def get_ORDER(self):
        return self.ORDER
    def set_ORDER(self, ORDER):
        self.ORDER = ORDER
    def get_ORDERLABEL(self):
        return self.ORDERLABEL
    def set_ORDERLABEL(self, ORDERLABEL):
        self.ORDERLABEL = ORDERLABEL
    def get_LABEL(self):
        return self.LABEL
    def set_LABEL(self, LABEL):
        self.LABEL = LABEL
    def validate_URIs(self, value):
        # Validate type URIs, a restriction on xsd:anyURI.
        pass
    def hasContent_(self):
        if (
            self.mptr or
            self.fptr or
            self.div
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='divType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('divType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='divType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, '', namespacedef_, name_='divType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='divType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.DMDID is not None and 'DMDID' not in already_processed:
            already_processed.add('DMDID')
            outfile.write(' DMDID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.DMDID), input_name='DMDID')), ))
        if self.ADMID is not None and 'ADMID' not in already_processed:
            already_processed.add('ADMID')
            outfile.write(' ADMID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ADMID), input_name='ADMID')), ))
        if self.TYPE is not None and 'TYPE' not in already_processed:
            already_processed.add('TYPE')
            outfile.write(' TYPE=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.TYPE), input_name='TYPE')), ))
        if self.CONTENTIDS is not None and 'CONTENTIDS' not in already_processed:
            already_processed.add('CONTENTIDS')
            outfile.write(' CONTENTIDS=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.CONTENTIDS), input_name='CONTENTIDS')), ))
        if self.label is not None and 'label' not in already_processed:
            already_processed.add('label')
            outfile.write(' label=%s' % (quote_attrib(self.label), ))
        if self.ORDER is not None and 'ORDER' not in already_processed:
            already_processed.add('ORDER')
            outfile.write(' ORDER="%s"' % self.gds_format_integer(self.ORDER, input_name='ORDER'))
        if self.ORDERLABEL is not None and 'ORDERLABEL' not in already_processed:
            already_processed.add('ORDERLABEL')
            outfile.write(' ORDERLABEL=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ORDERLABEL), input_name='ORDERLABEL')), ))
        if self.LABEL is not None and 'LABEL' not in already_processed:
            already_processed.add('LABEL')
            outfile.write(' LABEL=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.LABEL), input_name='LABEL')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='divType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for mptr_ in self.mptr:
            mptr_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='mptr', pretty_print=pretty_print)
        for fptr_ in self.fptr:
            fptr_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='fptr', pretty_print=pretty_print)
        for div_ in self.div:
            div_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='div', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('DMDID', node)
        if value is not None and 'DMDID' not in already_processed:
            already_processed.add('DMDID')
            self.DMDID = value
        value = find_attr_value_('ADMID', node)
        if value is not None and 'ADMID' not in already_processed:
            already_processed.add('ADMID')
            self.ADMID = value
        value = find_attr_value_('TYPE', node)
        if value is not None and 'TYPE' not in already_processed:
            already_processed.add('TYPE')
            self.TYPE = value
        value = find_attr_value_('CONTENTIDS', node)
        if value is not None and 'CONTENTIDS' not in already_processed:
            already_processed.add('CONTENTIDS')
            self.CONTENTIDS = value
            self.validate_URIs(self.CONTENTIDS)    # validate type URIs
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.add('label')
            self.label = value
        value = find_attr_value_('ORDER', node)
        if value is not None and 'ORDER' not in already_processed:
            already_processed.add('ORDER')
            try:
                self.ORDER = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('ORDERLABEL', node)
        if value is not None and 'ORDERLABEL' not in already_processed:
            already_processed.add('ORDERLABEL')
            self.ORDERLABEL = value
        value = find_attr_value_('LABEL', node)
        if value is not None and 'LABEL' not in already_processed:
            already_processed.add('LABEL')
            self.LABEL = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'mptr':
            obj_ = mptrType.factory(parent_object_=self)
            obj_.build(child_)
            self.mptr.append(obj_)
            obj_.original_tagname_ = 'mptr'
        elif nodeName_ == 'fptr':
            obj_ = fptrType.factory(parent_object_=self)
            obj_.build(child_)
            self.fptr.append(obj_)
            obj_.original_tagname_ = 'fptr'
        elif nodeName_ == 'div':
            obj_ = divType.factory(parent_object_=self)
            obj_.build(child_)
            self.div.append(obj_)
            obj_.original_tagname_ = 'div'
# end class divType


class parType(GeneratedsSuper):
    """parType: Complex Type for Parallel Files
    The <par> or parallel files element aggregates pointers to files, parts of
    files, and/or sequences of files or parts of files that must be played
    or displayed simultaneously to manifest a block of digital content
    represented by an <fptr> element.
    ID (ID/O): This attribute uniquely identifies the element within the METS
    document, and would allow the element to be referenced unambiguously
    from another element or document via an IDREF or an XPTR. For more
    information on using ID attributes for internal and external linking
    see Chapter 4 of the METS Primer."""
    subclass = None
    superclass = None
    def __init__(self, ID=None, ORDER=None, ORDERLABEL=None, LABEL=None, area=None, seq=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ID = _cast(None, ID)
        self.ORDER = _cast(int, ORDER)
        self.ORDERLABEL = _cast(None, ORDERLABEL)
        self.LABEL = _cast(None, LABEL)
        if area is None:
            self.area = []
        else:
            self.area = area
        if seq is None:
            self.seq = []
        else:
            self.seq = seq
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, parType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if parType.subclass:
            return parType.subclass(*args_, **kwargs_)
        else:
            return parType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_area(self):
        return self.area
    def set_area(self, area):
        self.area = area
    def add_area(self, value):
        self.area.append(value)
    def insert_area_at(self, index, value):
        self.area.insert(index, value)
    def replace_area_at(self, index, value):
        self.area[index] = value
    def get_seq(self):
        return self.seq
    def set_seq(self, seq):
        self.seq = seq
    def add_seq(self, value):
        self.seq.append(value)
    def insert_seq_at(self, index, value):
        self.seq.insert(index, value)
    def replace_seq_at(self, index, value):
        self.seq[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_ORDER(self):
        return self.ORDER
    def set_ORDER(self, ORDER):
        self.ORDER = ORDER
    def get_ORDERLABEL(self):
        return self.ORDERLABEL
    def set_ORDERLABEL(self, ORDERLABEL):
        self.ORDERLABEL = ORDERLABEL
    def get_LABEL(self):
        return self.LABEL
    def set_LABEL(self, LABEL):
        self.LABEL = LABEL
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.area or
            self.seq
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='parType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('parType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='parType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, '', namespacedef_, name_='parType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='parType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' %d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.ORDER is not None and 'ORDER' not in already_processed:
            already_processed.add('ORDER')
            outfile.write(' ORDER="%s"' % self.gds_format_integer(self.ORDER, input_name='ORDER'))
        if self.ORDERLABEL is not None and 'ORDERLABEL' not in already_processed:
            already_processed.add('ORDERLABEL')
            outfile.write(' ORDERLABEL=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ORDERLABEL), input_name='ORDERLABEL')), ))
        if self.LABEL is not None and 'LABEL' not in already_processed:
            already_processed.add('LABEL')
            outfile.write(' LABEL=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.LABEL), input_name='LABEL')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='parType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for area_ in self.area:
            area_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='area', pretty_print=pretty_print)
        for seq_ in self.seq:
            seq_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='seq', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('ORDER', node)
        if value is not None and 'ORDER' not in already_processed:
            already_processed.add('ORDER')
            try:
                self.ORDER = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('ORDERLABEL', node)
        if value is not None and 'ORDERLABEL' not in already_processed:
            already_processed.add('ORDERLABEL')
            self.ORDERLABEL = value
        value = find_attr_value_('LABEL', node)
        if value is not None and 'LABEL' not in already_processed:
            already_processed.add('LABEL')
            self.LABEL = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'area':
            obj_ = areaType.factory(parent_object_=self)
            obj_.build(child_)
            self.area.append(obj_)
            obj_.original_tagname_ = 'area'
        elif nodeName_ == 'seq':
            obj_ = seqType.factory(parent_object_=self)
            obj_.build(child_)
            self.seq.append(obj_)
            obj_.original_tagname_ = 'seq'
# end class parType


class seqType(GeneratedsSuper):
    """seqType: Complex Type for Sequences of Files
    The seq element should be used to link a div to a set of content files when
    those files should be played/displayed sequentially to deliver content
    to a user. Individual <area> subelements within the seq element provide
    the links to the files or portions thereof.
    ID (ID/O): This attribute uniquely identifies the element within the METS
    document, and would allow the element to be referenced unambiguously
    from another element or document via an IDREF or an XPTR. For more
    information on using ID attributes for internal and external linking
    see Chapter 4 of the METS Primer."""
    subclass = None
    superclass = None
    def __init__(self, ID=None, ORDER=None, ORDERLABEL=None, LABEL=None, area=None, par=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ID = _cast(None, ID)
        self.ORDER = _cast(int, ORDER)
        self.ORDERLABEL = _cast(None, ORDERLABEL)
        self.LABEL = _cast(None, LABEL)
        if area is None:
            self.area = []
        else:
            self.area = area
        if par is None:
            self.par = []
        else:
            self.par = par
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, seqType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if seqType.subclass:
            return seqType.subclass(*args_, **kwargs_)
        else:
            return seqType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_area(self):
        return self.area
    def set_area(self, area):
        self.area = area
    def add_area(self, value):
        self.area.append(value)
    def insert_area_at(self, index, value):
        self.area.insert(index, value)
    def replace_area_at(self, index, value):
        self.area[index] = value
    def get_par(self):
        return self.par
    def set_par(self, par):
        self.par = par
    def add_par(self, value):
        self.par.append(value)
    def insert_par_at(self, index, value):
        self.par.insert(index, value)
    def replace_par_at(self, index, value):
        self.par[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_ORDER(self):
        return self.ORDER
    def set_ORDER(self, ORDER):
        self.ORDER = ORDER
    def get_ORDERLABEL(self):
        return self.ORDERLABEL
    def set_ORDERLABEL(self, ORDERLABEL):
        self.ORDERLABEL = ORDERLABEL
    def get_LABEL(self):
        return self.LABEL
    def set_LABEL(self, LABEL):
        self.LABEL = LABEL
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.area or
            self.par
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='seqType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('seqType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='seqType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, '', namespacedef_, name_='seqType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='seqType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' %d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.ORDER is not None and 'ORDER' not in already_processed:
            already_processed.add('ORDER')
            outfile.write(' ORDER="%s"' % self.gds_format_integer(self.ORDER, input_name='ORDER'))
        if self.ORDERLABEL is not None and 'ORDERLABEL' not in already_processed:
            already_processed.add('ORDERLABEL')
            outfile.write(' ORDERLABEL=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ORDERLABEL), input_name='ORDERLABEL')), ))
        if self.LABEL is not None and 'LABEL' not in already_processed:
            already_processed.add('LABEL')
            outfile.write(' LABEL=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.LABEL), input_name='LABEL')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='seqType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for area_ in self.area:
            area_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='area', pretty_print=pretty_print)
        for par_ in self.par:
            par_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='par', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('ORDER', node)
        if value is not None and 'ORDER' not in already_processed:
            already_processed.add('ORDER')
            try:
                self.ORDER = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('ORDERLABEL', node)
        if value is not None and 'ORDERLABEL' not in already_processed:
            already_processed.add('ORDERLABEL')
            self.ORDERLABEL = value
        value = find_attr_value_('LABEL', node)
        if value is not None and 'LABEL' not in already_processed:
            already_processed.add('LABEL')
            self.LABEL = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'area':
            obj_ = areaType.factory(parent_object_=self)
            obj_.build(child_)
            self.area.append(obj_)
            obj_.original_tagname_ = 'area'
        elif nodeName_ == 'par':
            obj_ = parType.factory(parent_object_=self)
            obj_.build(child_)
            self.par.append(obj_)
            obj_.original_tagname_ = 'par'
# end class seqType


class areaType(GeneratedsSuper):
    """areaType: Complex Type for Area Linking
    The area element provides for more sophisticated linking between a div
    element and content files representing that div, be they text, image,
    audio, or video files. An area element can link a div to a point within
    a file, to a one-dimension segment of a file (e.g., text segment, image
    line, audio/video clip), or a two-dimensional section of a file (e.g,
    subsection of an image, or a subsection of the video display of a video
    file. The area element has no content; all information is recorded
    within its various attributes.
    ID (ID/O): This attribute uniquely identifies the element within the METS
    document, and would allow the element to be referenced unambiguously
    from another element or document via an IDREF or an XPTR. For more
    information on using ID attributes for internal and external linking
    see Chapter 4 of the METS Primer.
    FILEID (IDREF/R): An attribute which provides the XML ID value that
    identifies the <file> element in the <fileSec> that then points to
    and/or contains the digital content represented by the <area> element.
    It must contain an ID value represented in an ID attribute associated
    with a <file> element in the <fileSec> element in the same METS
    document.
    SHAPE (string/O): An attribute that can be used as in HTML to define the
    shape of the relevant area within the content file pointed to by the
    <area> element. Typically this would be used with image content (still
    image or video frame) when only a portion of an integal image map
    pertains. If SHAPE is specified then COORDS must also be present. SHAPE
    should be used in conjunction with COORDS in the manner defined for the
    shape and coords attributes on an HTML4 <area> element. SHAPE must
    contain one of the following values:
    RECT
    CIRCLE
    POLY
    COORDS (string/O): Specifies the coordinates in an image map for the shape
    of the pertinent area as specified in the SHAPE attribute. While
    technically optional, SHAPE and COORDS must both appear together to
    define the relevant area of image content. COORDS should be used in
    conjunction with SHAPE in the manner defined for the COORDs and SHAPE
    attributes on an HTML4 <area> element. COORDS must be a comma delimited
    string of integer value pairs representing coordinates (plus radius in
    the case of CIRCLE) within an image map. Number of coordinates pairs
    depends on shape: RECT: x1, y1, x2, y2; CIRC: x1, y1; POLY: x1, y1, x2,
    y2, x3, y3 . . .
    BEGIN (string/O): An attribute that specifies the point in the content file
    where the relevant section of content begins. It can be used in
    conjunction with either the END attribute or the EXTENT attribute as a
    means of defining the relevant portion of the referenced file
    precisely. It can only be interpreted meaningfully in conjunction with
    the BETYPE or EXTTYPE, which specify the kind of beginning/ending point
    values or beginning/extent values that are being used. The BEGIN
    attribute can be used with or without a companion END or EXTENT
    element. In this case, the end of the content file is assumed to be the
    end point.
    END (string/O): An attribute that specifies the point in the content file
    where the relevant section of content ends. It can only be interpreted
    meaningfully in conjunction with the BETYPE, which specifies the kind
    of ending point values being used. Typically the END attribute would
    only appear in conjunction with a BEGIN element.
    BETYPE: Begin/End Type.
    BETYPE (string/O): An attribute that specifies the kind of BEGIN and/or END
    values that are being used. For example, if BYTE is specified, then the
    BEGIN and END point values represent the byte offsets into a file. If
    IDREF is specified, then the BEGIN element specifies the ID value that
    identifies the element in a structured text file where the relevant
    section of the file begins; and the END value (if present) would
    specify the ID value that identifies the element with which the
    relevant section of the file ends. Must be one of the following values:
    BYTE
    IDREF
    SMIL
    MIDI
    SMPTE-25
    SMPTE-24
    SMPTE-DF30
    SMPTE-NDF30
    SMPTE-DF29.97
    SMPTE-NDF29.97
    TIME
    TCF
    XPTR
    EXTENT (string/O): An attribute that specifies the extent of the relevant
    section of the content file. Can only be interpreted meaningfully in
    conjunction with the EXTTYPE which specifies the kind of value that is
    being used. Typically the EXTENT attribute would only appear in
    conjunction with a BEGIN element and would not be used if the BEGIN
    point represents an IDREF.
    EXTTYPE (string/O): An attribute that specifies the kind of EXTENT values
    that are being used. For example if BYTE is specified then EXTENT would
    represent a byte count. If TIME is specified the EXTENT would represent
    a duration of time. EXTTYPE must be one of the following values:
    BYTE
    SMIL
    MIDI
    SMPTE-25
    SMPTE-24
    SMPTE-DF30
    SMPTE-NDF30
    SMPTE-DF29.97
    SMPTE-NDF29.97
    TIME
    TCF.
    ADMID (IDREFS/O): Contains the ID attribute values identifying the
    <rightsMD>, <sourceMD>, <techMD> and/or <digiprovMD> elements within
    the <amdSec> of the METS document that contain or link to
    administrative metadata pertaining to the content represented by the
    <area> element. Typically the <area> ADMID attribute would be used to
    identify the <rightsMD> element or elements that pertain to the <area>,
    but it could be used anytime there was a need to link an <area> with
    pertinent administrative metadata. For more information on using METS
    IDREFS and IDREF type attributes for internal linking, see Chapter 4 of
    the METS Primer
    CONTENTIDS (URI/O): Content IDs for the content represented by the <area>
    (equivalent to DIDL DII or Digital Item Identifier, a unique external
    ID)."""
    subclass = None
    superclass = None
    def __init__(self, ID=None, FILEID=None, SHAPE=None, COORDS=None, BEGIN=None, END=None, BETYPE=None, EXTENT=None, EXTTYPE=None, ADMID=None, CONTENTIDS=None, ORDER=None, ORDERLABEL=None, LABEL=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ID = _cast(None, ID)
        self.FILEID = _cast(None, FILEID)
        self.SHAPE = _cast(None, SHAPE)
        self.COORDS = _cast(None, COORDS)
        self.BEGIN = _cast(None, BEGIN)
        self.END = _cast(None, END)
        self.BETYPE = _cast(None, BETYPE)
        self.EXTENT = _cast(None, EXTENT)
        self.EXTTYPE = _cast(None, EXTTYPE)
        self.ADMID = _cast(None, ADMID)
        self.CONTENTIDS = _cast(None, CONTENTIDS)
        self.ORDER = _cast(int, ORDER)
        self.ORDERLABEL = _cast(None, ORDERLABEL)
        self.LABEL = _cast(None, LABEL)
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, areaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if areaType.subclass:
            return areaType.subclass(*args_, **kwargs_)
        else:
            return areaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_FILEID(self):
        return self.FILEID
    def set_FILEID(self, FILEID):
        self.FILEID = FILEID
    def get_SHAPE(self):
        return self.SHAPE
    def set_SHAPE(self, SHAPE):
        self.SHAPE = SHAPE
    def get_COORDS(self):
        return self.COORDS
    def set_COORDS(self, COORDS):
        self.COORDS = COORDS
    def get_BEGIN(self):
        return self.BEGIN
    def set_BEGIN(self, BEGIN):
        self.BEGIN = BEGIN
    def get_END(self):
        return self.END
    def set_END(self, END):
        self.END = END
    def get_BETYPE(self):
        return self.BETYPE
    def set_BETYPE(self, BETYPE):
        self.BETYPE = BETYPE
    def get_EXTENT(self):
        return self.EXTENT
    def set_EXTENT(self, EXTENT):
        self.EXTENT = EXTENT
    def get_EXTTYPE(self):
        return self.EXTTYPE
    def set_EXTTYPE(self, EXTTYPE):
        self.EXTTYPE = EXTTYPE
    def get_ADMID(self):
        return self.ADMID
    def set_ADMID(self, ADMID):
        self.ADMID = ADMID
    def get_CONTENTIDS(self):
        return self.CONTENTIDS
    def set_CONTENTIDS(self, CONTENTIDS):
        self.CONTENTIDS = CONTENTIDS
    def get_ORDER(self):
        return self.ORDER
    def set_ORDER(self, ORDER):
        self.ORDER = ORDER
    def get_ORDERLABEL(self):
        return self.ORDERLABEL
    def set_ORDERLABEL(self, ORDERLABEL):
        self.ORDERLABEL = ORDERLABEL
    def get_LABEL(self):
        return self.LABEL
    def set_LABEL(self, LABEL):
        self.LABEL = LABEL
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def validate_URIs(self, value):
        # Validate type URIs, a restriction on xsd:anyURI.
        pass
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='areaType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('areaType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='areaType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, '', namespacedef_, name_='areaType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='areaType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' %d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if 'FILEID' not in already_processed:
            already_processed.add('FILEID')
            outfile.write(' FILEID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.FILEID), input_name='FILEID')), ))
        if self.SHAPE is not None and 'SHAPE' not in already_processed:
            already_processed.add('SHAPE')
            outfile.write(' SHAPE=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.SHAPE), input_name='SHAPE')), ))
        if self.COORDS is not None and 'COORDS' not in already_processed:
            already_processed.add('COORDS')
            outfile.write(' COORDS=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.COORDS), input_name='COORDS')), ))
        if self.BEGIN is not None and 'BEGIN' not in already_processed:
            already_processed.add('BEGIN')
            outfile.write(' BEGIN=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.BEGIN), input_name='BEGIN')), ))
        if self.END is not None and 'END' not in already_processed:
            already_processed.add('END')
            outfile.write(' END=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.END), input_name='END')), ))
        if self.BETYPE is not None and 'BETYPE' not in already_processed:
            already_processed.add('BETYPE')
            outfile.write(' BETYPE=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.BETYPE), input_name='BETYPE')), ))
        if self.EXTENT is not None and 'EXTENT' not in already_processed:
            already_processed.add('EXTENT')
            outfile.write(' EXTENT=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.EXTENT), input_name='EXTENT')), ))
        if self.EXTTYPE is not None and 'EXTTYPE' not in already_processed:
            already_processed.add('EXTTYPE')
            outfile.write(' EXTTYPE=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.EXTTYPE), input_name='EXTTYPE')), ))
        if self.ADMID is not None and 'ADMID' not in already_processed:
            already_processed.add('ADMID')
            outfile.write(' ADMID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ADMID), input_name='ADMID')), ))
        if self.CONTENTIDS is not None and 'CONTENTIDS' not in already_processed:
            already_processed.add('CONTENTIDS')
            outfile.write(' CONTENTIDS=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.CONTENTIDS), input_name='CONTENTIDS')), ))
        if self.ORDER is not None and 'ORDER' not in already_processed:
            already_processed.add('ORDER')
            outfile.write(' ORDER="%s"' % self.gds_format_integer(self.ORDER, input_name='ORDER'))
        if self.ORDERLABEL is not None and 'ORDERLABEL' not in already_processed:
            already_processed.add('ORDERLABEL')
            outfile.write(' ORDERLABEL=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ORDERLABEL), input_name='ORDERLABEL')), ))
        if self.LABEL is not None and 'LABEL' not in already_processed:
            already_processed.add('LABEL')
            outfile.write(' LABEL=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.LABEL), input_name='LABEL')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='areaType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('FILEID', node)
        if value is not None and 'FILEID' not in already_processed:
            already_processed.add('FILEID')
            self.FILEID = value
        value = find_attr_value_('SHAPE', node)
        if value is not None and 'SHAPE' not in already_processed:
            already_processed.add('SHAPE')
            self.SHAPE = value
        value = find_attr_value_('COORDS', node)
        if value is not None and 'COORDS' not in already_processed:
            already_processed.add('COORDS')
            self.COORDS = value
        value = find_attr_value_('BEGIN', node)
        if value is not None and 'BEGIN' not in already_processed:
            already_processed.add('BEGIN')
            self.BEGIN = value
        value = find_attr_value_('END', node)
        if value is not None and 'END' not in already_processed:
            already_processed.add('END')
            self.END = value
        value = find_attr_value_('BETYPE', node)
        if value is not None and 'BETYPE' not in already_processed:
            already_processed.add('BETYPE')
            self.BETYPE = value
        value = find_attr_value_('EXTENT', node)
        if value is not None and 'EXTENT' not in already_processed:
            already_processed.add('EXTENT')
            self.EXTENT = value
        value = find_attr_value_('EXTTYPE', node)
        if value is not None and 'EXTTYPE' not in already_processed:
            already_processed.add('EXTTYPE')
            self.EXTTYPE = value
        value = find_attr_value_('ADMID', node)
        if value is not None and 'ADMID' not in already_processed:
            already_processed.add('ADMID')
            self.ADMID = value
        value = find_attr_value_('CONTENTIDS', node)
        if value is not None and 'CONTENTIDS' not in already_processed:
            already_processed.add('CONTENTIDS')
            self.CONTENTIDS = value
            self.validate_URIs(self.CONTENTIDS)    # validate type URIs
        value = find_attr_value_('ORDER', node)
        if value is not None and 'ORDER' not in already_processed:
            already_processed.add('ORDER')
            try:
                self.ORDER = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('ORDERLABEL', node)
        if value is not None and 'ORDERLABEL' not in already_processed:
            already_processed.add('ORDERLABEL')
            self.ORDERLABEL = value
        value = find_attr_value_('LABEL', node)
        if value is not None and 'LABEL' not in already_processed:
            already_processed.add('LABEL')
            self.LABEL = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class areaType


class structLinkType(GeneratedsSuper):
    """structLinkType: Complex Type for Structural Map Linking
    The Structural Map Linking section allows for the specification of
    hyperlinks between different components of a METS structure delineated
    in a structural map. structLink contains a single, repeatable element,
    smLink. Each smLink element indicates a hyperlink between two nodes in
    the structMap. The structMap nodes recorded in smLink are identified
    using their XML ID attribute values.
    ID (ID/O): This attribute uniquely identifies the element within the METS
    document, and would allow the element to be referenced unambiguously
    from another element or document via an IDREF or an XPTR. For more
    information on using ID attributes for internal and external linking
    see Chapter 4 of the METS Primer."""
    subclass = None
    superclass = None
    def __init__(self, ID=None, smLink=None, smLinkGrp=None, extensiontype_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ID = _cast(None, ID)
        if smLink is None:
            self.smLink = []
        else:
            self.smLink = smLink
        if smLinkGrp is None:
            self.smLinkGrp = []
        else:
            self.smLinkGrp = smLinkGrp
        self.anyAttributes_ = {}
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, structLinkType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if structLinkType.subclass:
            return structLinkType.subclass(*args_, **kwargs_)
        else:
            return structLinkType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_smLink(self):
        return self.smLink
    def set_smLink(self, smLink):
        self.smLink = smLink
    def add_smLink(self, value):
        self.smLink.append(value)
    def insert_smLink_at(self, index, value):
        self.smLink.insert(index, value)
    def replace_smLink_at(self, index, value):
        self.smLink[index] = value
    def get_smLinkGrp(self):
        return self.smLinkGrp
    def set_smLinkGrp(self, smLinkGrp):
        self.smLinkGrp = smLinkGrp
    def add_smLinkGrp(self, value):
        self.smLinkGrp.append(value)
    def insert_smLinkGrp_at(self, index, value):
        self.smLinkGrp.insert(index, value)
    def replace_smLinkGrp_at(self, index, value):
        self.smLinkGrp[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.smLink or
            self.smLinkGrp
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='structLinkType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('structLinkType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='structLinkType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, '', namespacedef_, name_='structLinkType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='structLinkType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' %d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='structLinkType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for smLink_ in self.smLink:
            smLink_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='smLink', pretty_print=pretty_print)
        for smLinkGrp_ in self.smLinkGrp:
            smLinkGrp_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='smLinkGrp', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'smLink':
            obj_ = smLinkType.factory(parent_object_=self)
            obj_.build(child_)
            self.smLink.append(obj_)
            obj_.original_tagname_ = 'smLink'
        elif nodeName_ == 'smLinkGrp':
            obj_ = smLinkGrpType.factory(parent_object_=self)
            obj_.build(child_)
            self.smLinkGrp.append(obj_)
            obj_.original_tagname_ = 'smLinkGrp'
# end class structLinkType


class behaviorSecType(GeneratedsSuper):
    """behaviorSecType: Complex Type for Behavior Sections
    Behaviors are executable code which can be associated with parts of a METS
    object. The behaviorSec element is used to group individual behaviors
    within a hierarchical structure. Such grouping can be useful to
    organize families of behaviors together or to indicate other
    relationships between particular behaviors.
    ID (ID/O): This attribute uniquely identifies the element within the METS
    document, and would allow the element to be referenced unambiguously
    from another element or document via an IDREF or an XPTR. For more
    information on using ID attributes for internal and external linking
    see Chapter 4 of the METS Primer.
    CREATED (dateTime/O): Specifies the date and time of creation for the
    <behaviorSec>
    LABEL (string/O): A text description of the behavior section."""
    subclass = None
    superclass = None
    def __init__(self, ID=None, CREATED=None, LABEL=None, behaviorSec=None, behavior=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ID = _cast(None, ID)
        if isinstance(CREATED, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(CREATED, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = CREATED
        self.CREATED = initvalue_
        self.LABEL = _cast(None, LABEL)
        if behaviorSec is None:
            self.behaviorSec = []
        else:
            self.behaviorSec = behaviorSec
        if behavior is None:
            self.behavior = []
        else:
            self.behavior = behavior
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, behaviorSecType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if behaviorSecType.subclass:
            return behaviorSecType.subclass(*args_, **kwargs_)
        else:
            return behaviorSecType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_behaviorSec(self):
        return self.behaviorSec
    def set_behaviorSec(self, behaviorSec):
        self.behaviorSec = behaviorSec
    def add_behaviorSec(self, value):
        self.behaviorSec.append(value)
    def insert_behaviorSec_at(self, index, value):
        self.behaviorSec.insert(index, value)
    def replace_behaviorSec_at(self, index, value):
        self.behaviorSec[index] = value
    def get_behavior(self):
        return self.behavior
    def set_behavior(self, behavior):
        self.behavior = behavior
    def add_behavior(self, value):
        self.behavior.append(value)
    def insert_behavior_at(self, index, value):
        self.behavior.insert(index, value)
    def replace_behavior_at(self, index, value):
        self.behavior[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_CREATED(self):
        return self.CREATED
    def set_CREATED(self, CREATED):
        self.CREATED = CREATED
    def get_LABEL(self):
        return self.LABEL
    def set_LABEL(self, LABEL):
        self.LABEL = LABEL
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.behaviorSec or
            self.behavior
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='behaviorSecType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('behaviorSecType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='behaviorSecType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, '', namespacedef_, name_='behaviorSecType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='behaviorSecType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' %d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.CREATED is not None and 'CREATED' not in already_processed:
            already_processed.add('CREATED')
            outfile.write(' CREATED="%s"' % self.gds_format_datetime(self.CREATED, input_name='CREATED'))
        if self.LABEL is not None and 'LABEL' not in already_processed:
            already_processed.add('LABEL')
            outfile.write(' LABEL=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.LABEL), input_name='LABEL')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='behaviorSecType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for behaviorSec_ in self.behaviorSec:
            behaviorSec_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='behaviorSec', pretty_print=pretty_print)
        for behavior_ in self.behavior:
            behavior_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='behavior', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('CREATED', node)
        if value is not None and 'CREATED' not in already_processed:
            already_processed.add('CREATED')
            try:
                self.CREATED = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (CREATED): %s' % exp)
        value = find_attr_value_('LABEL', node)
        if value is not None and 'LABEL' not in already_processed:
            already_processed.add('LABEL')
            self.LABEL = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'behaviorSec':
            obj_ = behaviorSecType.factory(parent_object_=self)
            obj_.build(child_)
            self.behaviorSec.append(obj_)
            obj_.original_tagname_ = 'behaviorSec'
        elif nodeName_ == 'behavior':
            obj_ = behaviorType.factory(parent_object_=self)
            obj_.build(child_)
            self.behavior.append(obj_)
            obj_.original_tagname_ = 'behavior'
# end class behaviorSecType


class behaviorType(GeneratedsSuper):
    """behaviorType: Complex Type for Behaviors
    A behavior can be used to associate executable behaviors with content in
    the METS object. A behavior element has an interface definition element
    that represents an abstract definition of the set of behaviors
    represented by a particular behavior. A behavior element also has an
    behavior mechanism which is a module of executable code that implements
    and runs the behavior defined abstractly by the interface definition.
    ID (ID/O): This attribute uniquely identifies the element within the METS
    document, and would allow the element to be referenced unambiguously
    from another element or document via an IDREF or an XPTR. In the case
    of a <behavior> element that applies to a <transformFile> element, the
    ID value must be present and would be referenced from the
    transformFile/@TRANSFORMBEHAVIOR attribute. For more information on
    using ID attributes for internal and external linking see Chapter 4 of
    the METS Primer.
    STRUCTID (IDREFS/O): An XML IDREFS attribute used to link a <behavior> to
    one or more <div> elements within a <structMap> in the METS document.
    The content to which the STRUCTID points is considered input to the
    executable behavior mechanism defined for the behavior. If the
    <behavior> applies to one or more <div> elements, then the STRUCTID
    attribute must be present.
    BTYPE (string/O): The behavior type provides a means of categorizing the
    related behavior.CREATED (dateTime/O): The dateTime of creation for the
    behavior.
    LABEL (string/O): A text description of the behavior.
    GROUPID (string/O): An identifier that establishes a correspondence between
    the given behavior and other behaviors, typically used to facilitate
    versions of behaviors.
    ADMID (IDREFS/O): An optional attribute listing the XML ID values of
    administrative metadata sections within the METS document pertaining to
    this behavior."""
    subclass = None
    superclass = None
    def __init__(self, ID=None, STRUCTID=None, BTYPE=None, CREATED=None, LABEL=None, GROUPID=None, ADMID=None, interfaceDef=None, mechanism=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ID = _cast(None, ID)
        self.STRUCTID = _cast(None, STRUCTID)
        self.BTYPE = _cast(None, BTYPE)
        if isinstance(CREATED, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(CREATED, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = CREATED
        self.CREATED = initvalue_
        self.LABEL = _cast(None, LABEL)
        self.GROUPID = _cast(None, GROUPID)
        self.ADMID = _cast(None, ADMID)
        self.interfaceDef = interfaceDef
        self.mechanism = mechanism
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, behaviorType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if behaviorType.subclass:
            return behaviorType.subclass(*args_, **kwargs_)
        else:
            return behaviorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_interfaceDef(self):
        return self.interfaceDef
    def set_interfaceDef(self, interfaceDef):
        self.interfaceDef = interfaceDef
    def get_mechanism(self):
        return self.mechanism
    def set_mechanism(self, mechanism):
        self.mechanism = mechanism
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_STRUCTID(self):
        return self.STRUCTID
    def set_STRUCTID(self, STRUCTID):
        self.STRUCTID = STRUCTID
    def get_BTYPE(self):
        return self.BTYPE
    def set_BTYPE(self, BTYPE):
        self.BTYPE = BTYPE
    def get_CREATED(self):
        return self.CREATED
    def set_CREATED(self, CREATED):
        self.CREATED = CREATED
    def get_LABEL(self):
        return self.LABEL
    def set_LABEL(self, LABEL):
        self.LABEL = LABEL
    def get_GROUPID(self):
        return self.GROUPID
    def set_GROUPID(self, GROUPID):
        self.GROUPID = GROUPID
    def get_ADMID(self):
        return self.ADMID
    def set_ADMID(self, ADMID):
        self.ADMID = ADMID
    def hasContent_(self):
        if (
            self.interfaceDef is not None or
            self.mechanism is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='behaviorType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('behaviorType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='behaviorType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, '', namespacedef_, name_='behaviorType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='behaviorType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.STRUCTID is not None and 'STRUCTID' not in already_processed:
            already_processed.add('STRUCTID')
            outfile.write(' STRUCTID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.STRUCTID), input_name='STRUCTID')), ))
        if self.BTYPE is not None and 'BTYPE' not in already_processed:
            already_processed.add('BTYPE')
            outfile.write(' BTYPE=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.BTYPE), input_name='BTYPE')), ))
        if self.CREATED is not None and 'CREATED' not in already_processed:
            already_processed.add('CREATED')
            outfile.write(' CREATED="%s"' % self.gds_format_datetime(self.CREATED, input_name='CREATED'))
        if self.LABEL is not None and 'LABEL' not in already_processed:
            already_processed.add('LABEL')
            outfile.write(' LABEL=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.LABEL), input_name='LABEL')), ))
        if self.GROUPID is not None and 'GROUPID' not in already_processed:
            already_processed.add('GROUPID')
            outfile.write(' GROUPID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.GROUPID), input_name='GROUPID')), ))
        if self.ADMID is not None and 'ADMID' not in already_processed:
            already_processed.add('ADMID')
            outfile.write(' ADMID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ADMID), input_name='ADMID')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='behaviorType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.interfaceDef is not None:
            self.interfaceDef.export(outfile, level, namespaceprefix_, namespacedef_='', name_='interfaceDef', pretty_print=pretty_print)
        if self.mechanism is not None:
            self.mechanism.export(outfile, level, namespaceprefix_, namespacedef_='', name_='mechanism', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('STRUCTID', node)
        if value is not None and 'STRUCTID' not in already_processed:
            already_processed.add('STRUCTID')
            self.STRUCTID = value
        value = find_attr_value_('BTYPE', node)
        if value is not None and 'BTYPE' not in already_processed:
            already_processed.add('BTYPE')
            self.BTYPE = value
        value = find_attr_value_('CREATED', node)
        if value is not None and 'CREATED' not in already_processed:
            already_processed.add('CREATED')
            try:
                self.CREATED = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (CREATED): %s' % exp)
        value = find_attr_value_('LABEL', node)
        if value is not None and 'LABEL' not in already_processed:
            already_processed.add('LABEL')
            self.LABEL = value
        value = find_attr_value_('GROUPID', node)
        if value is not None and 'GROUPID' not in already_processed:
            already_processed.add('GROUPID')
            self.GROUPID = value
        value = find_attr_value_('ADMID', node)
        if value is not None and 'ADMID' not in already_processed:
            already_processed.add('ADMID')
            self.ADMID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'interfaceDef':
            obj_ = objectType.factory(parent_object_=self)
            obj_.build(child_)
            self.interfaceDef = obj_
            obj_.original_tagname_ = 'interfaceDef'
        elif nodeName_ == 'mechanism':
            obj_ = objectType.factory(parent_object_=self)
            obj_.build(child_)
            self.mechanism = obj_
            obj_.original_tagname_ = 'mechanism'
# end class behaviorType


class objectType(GeneratedsSuper):
    """objectType: complexType for interfaceDef and mechanism elements
    The mechanism and behavior elements point to external objects--an interface
    definition object or an executable code object respectively--which
    together constitute a behavior that can be applied to one or more <div>
    elements in a <structMap>.
    ID (ID/O): This attribute uniquely identifies the element within the METS
    document, and would allow the element to be referenced unambiguously
    from another element or document via an IDREF or an XPTR. For more
    information on using ID attributes for internal and external linking
    see Chapter 4 of the METS Primer.
    LABEL (string/O): A text description of the entity represented."""
    subclass = None
    superclass = None
    def __init__(self, ID=None, LABEL=None, LOCTYPE=None, OTHERLOCTYPE=None, type_='simple', href=None, role=None, arcrole=None, title=None, show=None, actuate=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ID = _cast(None, ID)
        self.LABEL = _cast(None, LABEL)
        self.LOCTYPE = _cast(None, LOCTYPE)
        self.OTHERLOCTYPE = _cast(None, OTHERLOCTYPE)
        self.type_ = _cast(None, type_)
        self.href = _cast(None, href)
        self.role = _cast(None, role)
        self.arcrole = _cast(None, arcrole)
        self.title = _cast(None, title)
        self.show = _cast(None, show)
        self.actuate = _cast(None, actuate)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, objectType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if objectType.subclass:
            return objectType.subclass(*args_, **kwargs_)
        else:
            return objectType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_LABEL(self):
        return self.LABEL
    def set_LABEL(self, LABEL):
        self.LABEL = LABEL
    def get_LOCTYPE(self):
        return self.LOCTYPE
    def set_LOCTYPE(self, LOCTYPE):
        self.LOCTYPE = LOCTYPE
    def get_OTHERLOCTYPE(self):
        return self.OTHERLOCTYPE
    def set_OTHERLOCTYPE(self, OTHERLOCTYPE):
        self.OTHERLOCTYPE = OTHERLOCTYPE
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_href(self):
        return self.href
    def set_href(self, href):
        self.href = href
    def get_role(self):
        return self.role
    def set_role(self, role):
        self.role = role
    def get_arcrole(self):
        return self.arcrole
    def set_arcrole(self, arcrole):
        self.arcrole = arcrole
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def get_show(self):
        return self.show
    def set_show(self, show):
        self.show = show
    def get_actuate(self):
        return self.actuate
    def set_actuate(self, actuate):
        self.actuate = actuate
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='objectType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('objectType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='objectType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, '', namespacedef_, name_='objectType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='objectType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.LABEL is not None and 'LABEL' not in already_processed:
            already_processed.add('LABEL')
            outfile.write(' LABEL=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.LABEL), input_name='LABEL')), ))
        if 'LOCTYPE' not in already_processed:
            already_processed.add('LOCTYPE')
            outfile.write(' LOCTYPE=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.LOCTYPE), input_name='LOCTYPE')), ))
        if self.OTHERLOCTYPE is not None and 'OTHERLOCTYPE' not in already_processed:
            already_processed.add('OTHERLOCTYPE')
            outfile.write(' OTHERLOCTYPE=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.OTHERLOCTYPE), input_name='OTHERLOCTYPE')), ))
        if self.type_ != "simple" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (quote_attrib(self.href), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.add('role')
            outfile.write(' role=%s' % (quote_attrib(self.role), ))
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            outfile.write(' arcrole=%s' % (quote_attrib(self.arcrole), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.add('title')
            outfile.write(' title=%s' % (quote_attrib(self.title), ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.add('show')
            outfile.write(' show=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.show), input_name='show')), ))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            outfile.write(' actuate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.actuate), input_name='actuate')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='objectType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('LABEL', node)
        if value is not None and 'LABEL' not in already_processed:
            already_processed.add('LABEL')
            self.LABEL = value
        value = find_attr_value_('LOCTYPE', node)
        if value is not None and 'LOCTYPE' not in already_processed:
            already_processed.add('LOCTYPE')
            self.LOCTYPE = value
        value = find_attr_value_('OTHERLOCTYPE', node)
        if value is not None and 'OTHERLOCTYPE' not in already_processed:
            already_processed.add('OTHERLOCTYPE')
            self.OTHERLOCTYPE = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.add('role')
            self.role = value
        value = find_attr_value_('arcrole', node)
        if value is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            self.arcrole = value
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.add('title')
            self.title = value
        value = find_attr_value_('show', node)
        if value is not None and 'show' not in already_processed:
            already_processed.add('show')
            self.show = value
        value = find_attr_value_('actuate', node)
        if value is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            self.actuate = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class objectType


class mdSecType(GeneratedsSuper):
    """mdSecType: Complex Type for Metadata Sections
    A generic framework for pointing to/including metadata within a METS
    document, a la Warwick Framework.
    ID (ID/R): This attribute uniquely identifies the element within the METS
    document, and would allow the element to be referenced unambiguously
    from another element or document via an IDREF or an XPTR. The ID
    attribute on the <dmdSec>, <techMD>, <sourceMD>, <rightsMD> and
    <digiprovMD> elements (which are all of mdSecType) is required, and its
    value should be referenced from one or more DMDID attributes (when the
    ID identifies a <dmdSec> element) or ADMID attributes (when the ID
    identifies a <techMD>, <sourceMD>, <rightsMD> or <digiprovMD> element)
    that are associated with other elements in the METS document. The
    following elements support references to a <dmdSec> via a DMDID
    attribute: <file>, <stream>, <div>. The following elements support
    references to <techMD>, <sourceMD>, <rightsMD> and <digiprovMD>
    elements via an ADMID attribute: <metsHdr>, <dmdSec>, <techMD>,
    <sourceMD>, <rightsMD>, <digiprovMD>, <fileGrp>, <file>, <stream>,
    <div>, <area>, <behavior>. For more information on using ID attributes
    for internal and external linking see Chapter 4 of the METS Primer.
    GROUPID (string/O): This identifier is used to indicate that different
    metadata sections may be considered as part of a group. Two metadata
    sections with the same GROUPID value are to be considered part of the
    same group. For example this facility might be used to group changed
    versions of the same metadata if previous versions are maintained in a
    file for tracking purposes.
    ADMID (IDREFS/O): Contains the ID attribute values of the <digiprovMD>,
    <techMD>, <sourceMD> and/or <rightsMD> elements within the <amdSec> of
    the METS document that contain administrative metadata pertaining to
    the current mdSecType element. Typically used in this context to
    reference preservation metadata (digiprovMD) which applies to the
    current metadata. For more information on using METS IDREFS and IDREF
    type attributes for internal linking, see Chapter 4 of the METS Primer.
    CREATED (dateTime/O): Specifies the date and time of creation for the
    metadata.
    STATUS (string/O): Indicates the status of this metadata (e.g., superseded,
    current, etc.)."""
    subclass = None
    superclass = None
    def __init__(self, ID=None, GROUPID=None, ADMID=None, CREATED=None, STATUS=None, mdRef=None, mdWrap=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ID = _cast(None, ID)
        self.GROUPID = _cast(None, GROUPID)
        self.ADMID = _cast(None, ADMID)
        if isinstance(CREATED, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(CREATED, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = CREATED
        self.CREATED = initvalue_
        self.STATUS = _cast(None, STATUS)
        self.mdRef = mdRef
        self.mdWrap = mdWrap
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, mdSecType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if mdSecType.subclass:
            return mdSecType.subclass(*args_, **kwargs_)
        else:
            return mdSecType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_mdRef(self):
        return self.mdRef
    def set_mdRef(self, mdRef):
        self.mdRef = mdRef
    def get_mdWrap(self):
        return self.mdWrap
    def set_mdWrap(self, mdWrap):
        self.mdWrap = mdWrap
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_GROUPID(self):
        return self.GROUPID
    def set_GROUPID(self, GROUPID):
        self.GROUPID = GROUPID
    def get_ADMID(self):
        return self.ADMID
    def set_ADMID(self, ADMID):
        self.ADMID = ADMID
    def get_CREATED(self):
        return self.CREATED
    def set_CREATED(self, CREATED):
        self.CREATED = CREATED
    def get_STATUS(self):
        return self.STATUS
    def set_STATUS(self, STATUS):
        self.STATUS = STATUS
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.mdRef is not None or
            self.mdWrap is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='mdSecType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('mdSecType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='mdSecType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, '', namespacedef_, name_='mdSecType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='mdSecType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' %d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.GROUPID is not None and 'GROUPID' not in already_processed:
            already_processed.add('GROUPID')
            outfile.write(' GROUPID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.GROUPID), input_name='GROUPID')), ))
        if self.ADMID is not None and 'ADMID' not in already_processed:
            already_processed.add('ADMID')
            outfile.write(' ADMID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ADMID), input_name='ADMID')), ))
        if self.CREATED is not None and 'CREATED' not in already_processed:
            already_processed.add('CREATED')
            outfile.write(' CREATED="%s"' % self.gds_format_datetime(self.CREATED, input_name='CREATED'))
        if self.STATUS is not None and 'STATUS' not in already_processed:
            already_processed.add('STATUS')
            outfile.write(' STATUS=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.STATUS), input_name='STATUS')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='mdSecType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.mdRef is not None:
            self.mdRef.export(outfile, level, namespaceprefix_, namespacedef_='', name_='mdRef', pretty_print=pretty_print)
        if self.mdWrap is not None:
            self.mdWrap.export(outfile, level, namespaceprefix_, namespacedef_='', name_='mdWrap', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('GROUPID', node)
        if value is not None and 'GROUPID' not in already_processed:
            already_processed.add('GROUPID')
            self.GROUPID = value
        value = find_attr_value_('ADMID', node)
        if value is not None and 'ADMID' not in already_processed:
            already_processed.add('ADMID')
            self.ADMID = value
        value = find_attr_value_('CREATED', node)
        if value is not None and 'CREATED' not in already_processed:
            already_processed.add('CREATED')
            try:
                self.CREATED = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (CREATED): %s' % exp)
        value = find_attr_value_('STATUS', node)
        if value is not None and 'STATUS' not in already_processed:
            already_processed.add('STATUS')
            self.STATUS = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'mdRef':
            obj_ = mdRefType.factory(parent_object_=self)
            obj_.build(child_)
            self.mdRef = obj_
            obj_.original_tagname_ = 'mdRef'
        elif nodeName_ == 'mdWrap':
            obj_ = mdWrapType.factory(parent_object_=self)
            obj_.build(child_)
            self.mdWrap = obj_
            obj_.original_tagname_ = 'mdWrap'
# end class mdSecType


class fileType(GeneratedsSuper):
    """fileType: Complex Type for Files
    The file element provides access to content files for a METS object. A file
    element may contain one or more FLocat elements, which provide pointers
    to a content file, and/or an FContent element, which wraps an encoded
    version of the file. Note that ALL FLocat and FContent elements
    underneath a single file element should identify/contain identical
    copies of a single file.
    ID (ID/R): This attribute uniquely identifies the element within the METS
    document, and would allow the element to be referenced unambiguously
    from another element or document via an IDREF or an XPTR. Typically,
    the ID attribute value on a <file> element would be referenced from one
    or more FILEID attributes (which are of type IDREF) on <fptr>and/or
    <area> elements within the <structMap>. Such references establish links
    between structural divisions (<div> elements) and the specific content
    files or parts of content files that manifest them. For more
    information on using ID attributes for internal and external linking
    see Chapter 4 of the METS Primer.
    SEQ (integer/O): Indicates the sequence of this <file> relative to the
    others in its <fileGrp>.
    OWNERID (string/O): A unique identifier assigned to the file by its owner.
    This may be a URI which differs from the URI used to retrieve the file.
    ADMID (IDREFS/O): Contains the ID attribute values of the <techMD>,
    <sourceMD>, <rightsMD> and/or <digiprovMD> elements within the <amdSec>
    of the METS document that contain administrative metadata pertaining to
    the file. For more information on using METS IDREFS and IDREF type
    attributes for internal linking, see Chapter 4 of the METS Primer.
    DMDID (IDREFS/O): Contains the ID attribute values identifying the
    <dmdSec>, elements in the METS document that contain or link to
    descriptive metadata pertaining to the content file represented by the
    current <file> element. For more information on using METS IDREFS and
    IDREF type attributes for internal linking, see Chapter 4 of the METS
    Primer.
    GROUPID (string/O): An identifier that establishes a correspondence between
    this file and files in other file groups. Typically, this will be used
    to associate a master file in one file group with the derivative files
    made from it in other file groups.
    USE (string/O): A tagging attribute to indicate the intended use of all
    copies of the file aggregated by the <file> element (e.g., master,
    reference, thumbnails for image files). A USE attribute can be
    expressed at the<fileGrp> level, the <file> level, the <FLocat> level
    and/or the <FContent> level. A USE attribute value at the <fileGrp>
    level should pertain to all of the files in the <fileGrp>. A USE
    attribute at the <file> level should pertain to all copies of the file
    as represented by subsidiary <FLocat> and/or <FContent> elements. A USE
    attribute at the <FLocat> or <FContent> level pertains to the
    particular copy of the file that is either referenced (<FLocat>) or
    wrapped (<FContent>).
    BEGIN (string/O): An attribute that specifies the point in the parent
    <file> where the current <file> begins. When used in conjunction with a
    <file> element, this attribute is only meaningful when this element is
    nested, and its parent <file> element represents a container file. It
    can be used in conjunction with the END attribute as a means of
    defining the location of the current file within its parent file.
    However, the BEGIN attribute can be used with or without a companion
    END attribute. When no END attribute is specified, the end of the
    parent file is assumed also to be the end point of the current file.
    The BEGIN and END attributes can only be interpreted meaningfully in
    conjunction with a BETYPE attribute, which specifies the kind of
    beginning/ending point values that are being used.
    END (string/O): An attribute that specifies the point in the parent <file>
    where the current, nested <file> ends. It can only be interpreted
    meaningfully in conjunction with the BETYPE, which specifies the kind
    of ending point values being used. Typically the END attribute would
    only appear in conjunction with a BEGIN attribute.
    BETYPE: Begin/End Type.
    BETYPE (string/O): An attribute that specifies the kind of BEGIN and/or END
    values that are being used. Currently BYTE is the only valid value that
    can be used in conjunction with nested <file> or <stream> elements."""
    subclass = None
    superclass = None
    def __init__(self, ID=None, SEQ=None, OWNERID=None, ADMID=None, DMDID=None, GROUPID=None, USE=None, BEGIN=None, END=None, BETYPE=None, MIMETYPE=None, SIZE=None, CREATED=None, CHECKSUM=None, CHECKSUMTYPE=None, FLocat=None, FContent=None, stream=None, transformFile=None, file=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ID = _cast(None, ID)
        self.SEQ = _cast(int, SEQ)
        self.OWNERID = _cast(None, OWNERID)
        self.ADMID = _cast(None, ADMID)
        self.DMDID = _cast(None, DMDID)
        self.GROUPID = _cast(None, GROUPID)
        self.USE = _cast(None, USE)
        self.BEGIN = _cast(None, BEGIN)
        self.END = _cast(None, END)
        self.BETYPE = _cast(None, BETYPE)
        self.MIMETYPE = _cast(None, MIMETYPE)
        self.SIZE = _cast(int, SIZE)
        if isinstance(CREATED, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(CREATED, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = CREATED
        self.CREATED = initvalue_
        self.CHECKSUM = _cast(None, CHECKSUM)
        self.CHECKSUMTYPE = _cast(None, CHECKSUMTYPE)
        if FLocat is None:
            self.FLocat = []
        else:
            self.FLocat = FLocat
        self.FContent = FContent
        if stream is None:
            self.stream = []
        else:
            self.stream = stream
        if transformFile is None:
            self.transformFile = []
        else:
            self.transformFile = transformFile
        if file is None:
            self.file = []
        else:
            self.file = file
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, fileType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if fileType.subclass:
            return fileType.subclass(*args_, **kwargs_)
        else:
            return fileType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FLocat(self):
        return self.FLocat
    def set_FLocat(self, FLocat):
        self.FLocat = FLocat
    def add_FLocat(self, value):
        self.FLocat.append(value)
    def insert_FLocat_at(self, index, value):
        self.FLocat.insert(index, value)
    def replace_FLocat_at(self, index, value):
        self.FLocat[index] = value
    def get_FContent(self):
        return self.FContent
    def set_FContent(self, FContent):
        self.FContent = FContent
    def get_stream(self):
        return self.stream
    def set_stream(self, stream):
        self.stream = stream
    def add_stream(self, value):
        self.stream.append(value)
    def insert_stream_at(self, index, value):
        self.stream.insert(index, value)
    def replace_stream_at(self, index, value):
        self.stream[index] = value
    def get_transformFile(self):
        return self.transformFile
    def set_transformFile(self, transformFile):
        self.transformFile = transformFile
    def add_transformFile(self, value):
        self.transformFile.append(value)
    def insert_transformFile_at(self, index, value):
        self.transformFile.insert(index, value)
    def replace_transformFile_at(self, index, value):
        self.transformFile[index] = value
    def get_file(self):
        return self.file
    def set_file(self, file):
        self.file = file
    def add_file(self, value):
        self.file.append(value)
    def insert_file_at(self, index, value):
        self.file.insert(index, value)
    def replace_file_at(self, index, value):
        self.file[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_SEQ(self):
        return self.SEQ
    def set_SEQ(self, SEQ):
        self.SEQ = SEQ
    def get_OWNERID(self):
        return self.OWNERID
    def set_OWNERID(self, OWNERID):
        self.OWNERID = OWNERID
    def get_ADMID(self):
        return self.ADMID
    def set_ADMID(self, ADMID):
        self.ADMID = ADMID
    def get_DMDID(self):
        return self.DMDID
    def set_DMDID(self, DMDID):
        self.DMDID = DMDID
    def get_GROUPID(self):
        return self.GROUPID
    def set_GROUPID(self, GROUPID):
        self.GROUPID = GROUPID
    def get_USE(self):
        return self.USE
    def set_USE(self, USE):
        self.USE = USE
    def get_BEGIN(self):
        return self.BEGIN
    def set_BEGIN(self, BEGIN):
        self.BEGIN = BEGIN
    def get_END(self):
        return self.END
    def set_END(self, END):
        self.END = END
    def get_BETYPE(self):
        return self.BETYPE
    def set_BETYPE(self, BETYPE):
        self.BETYPE = BETYPE
    def get_MIMETYPE(self):
        return self.MIMETYPE
    def set_MIMETYPE(self, MIMETYPE):
        self.MIMETYPE = MIMETYPE
    def get_SIZE(self):
        return self.SIZE
    def set_SIZE(self, SIZE):
        self.SIZE = SIZE
    def get_CREATED(self):
        return self.CREATED
    def set_CREATED(self, CREATED):
        self.CREATED = CREATED
    def get_CHECKSUM(self):
        return self.CHECKSUM
    def set_CHECKSUM(self, CHECKSUM):
        self.CHECKSUM = CHECKSUM
    def get_CHECKSUMTYPE(self):
        return self.CHECKSUMTYPE
    def set_CHECKSUMTYPE(self, CHECKSUMTYPE):
        self.CHECKSUMTYPE = CHECKSUMTYPE
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.FLocat or
            self.FContent is not None or
            self.stream or
            self.transformFile or
            self.file
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='fileType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('fileType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='fileType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, '', namespacedef_, name_='fileType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='fileType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' %d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.SEQ is not None and 'SEQ' not in already_processed:
            already_processed.add('SEQ')
            outfile.write(' SEQ="%s"' % self.gds_format_integer(self.SEQ, input_name='SEQ'))
        if self.OWNERID is not None and 'OWNERID' not in already_processed:
            already_processed.add('OWNERID')
            outfile.write(' OWNERID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.OWNERID), input_name='OWNERID')), ))
        if self.ADMID is not None and 'ADMID' not in already_processed:
            already_processed.add('ADMID')
            outfile.write(' ADMID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ADMID), input_name='ADMID')), ))
        if self.DMDID is not None and 'DMDID' not in already_processed:
            already_processed.add('DMDID')
            outfile.write(' DMDID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.DMDID), input_name='DMDID')), ))
        if self.GROUPID is not None and 'GROUPID' not in already_processed:
            already_processed.add('GROUPID')
            outfile.write(' GROUPID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.GROUPID), input_name='GROUPID')), ))
        if self.USE is not None and 'USE' not in already_processed:
            already_processed.add('USE')
            outfile.write(' USE=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.USE), input_name='USE')), ))
        if self.BEGIN is not None and 'BEGIN' not in already_processed:
            already_processed.add('BEGIN')
            outfile.write(' BEGIN=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.BEGIN), input_name='BEGIN')), ))
        if self.END is not None and 'END' not in already_processed:
            already_processed.add('END')
            outfile.write(' END=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.END), input_name='END')), ))
        if self.BETYPE is not None and 'BETYPE' not in already_processed:
            already_processed.add('BETYPE')
            outfile.write(' BETYPE=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.BETYPE), input_name='BETYPE')), ))
        if self.MIMETYPE is not None and 'MIMETYPE' not in already_processed:
            already_processed.add('MIMETYPE')
            outfile.write(' MIMETYPE=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.MIMETYPE), input_name='MIMETYPE')), ))
        if self.SIZE is not None and 'SIZE' not in already_processed:
            already_processed.add('SIZE')
            outfile.write(' SIZE="%s"' % self.gds_format_integer(self.SIZE, input_name='SIZE'))
        if self.CREATED is not None and 'CREATED' not in already_processed:
            already_processed.add('CREATED')
            outfile.write(' CREATED="%s"' % self.gds_format_datetime(self.CREATED, input_name='CREATED'))
        if self.CHECKSUM is not None and 'CHECKSUM' not in already_processed:
            already_processed.add('CHECKSUM')
            outfile.write(' CHECKSUM=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.CHECKSUM), input_name='CHECKSUM')), ))
        if self.CHECKSUMTYPE is not None and 'CHECKSUMTYPE' not in already_processed:
            already_processed.add('CHECKSUMTYPE')
            outfile.write(' CHECKSUMTYPE=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.CHECKSUMTYPE), input_name='CHECKSUMTYPE')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='fileType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for FLocat_ in self.FLocat:
            FLocat_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='FLocat', pretty_print=pretty_print)
        if self.FContent is not None:
            self.FContent.export(outfile, level, namespaceprefix_, namespacedef_='', name_='FContent', pretty_print=pretty_print)
        for stream_ in self.stream:
            stream_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='stream', pretty_print=pretty_print)
        for transformFile_ in self.transformFile:
            transformFile_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='transformFile', pretty_print=pretty_print)
        for file_ in self.file:
            file_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='file', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('SEQ', node)
        if value is not None and 'SEQ' not in already_processed:
            already_processed.add('SEQ')
            try:
                self.SEQ = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('OWNERID', node)
        if value is not None and 'OWNERID' not in already_processed:
            already_processed.add('OWNERID')
            self.OWNERID = value
        value = find_attr_value_('ADMID', node)
        if value is not None and 'ADMID' not in already_processed:
            already_processed.add('ADMID')
            self.ADMID = value
        value = find_attr_value_('DMDID', node)
        if value is not None and 'DMDID' not in already_processed:
            already_processed.add('DMDID')
            self.DMDID = value
        value = find_attr_value_('GROUPID', node)
        if value is not None and 'GROUPID' not in already_processed:
            already_processed.add('GROUPID')
            self.GROUPID = value
        value = find_attr_value_('USE', node)
        if value is not None and 'USE' not in already_processed:
            already_processed.add('USE')
            self.USE = value
        value = find_attr_value_('BEGIN', node)
        if value is not None and 'BEGIN' not in already_processed:
            already_processed.add('BEGIN')
            self.BEGIN = value
        value = find_attr_value_('END', node)
        if value is not None and 'END' not in already_processed:
            already_processed.add('END')
            self.END = value
        value = find_attr_value_('BETYPE', node)
        if value is not None and 'BETYPE' not in already_processed:
            already_processed.add('BETYPE')
            self.BETYPE = value
        value = find_attr_value_('MIMETYPE', node)
        if value is not None and 'MIMETYPE' not in already_processed:
            already_processed.add('MIMETYPE')
            self.MIMETYPE = value
        value = find_attr_value_('SIZE', node)
        if value is not None and 'SIZE' not in already_processed:
            already_processed.add('SIZE')
            try:
                self.SIZE = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('CREATED', node)
        if value is not None and 'CREATED' not in already_processed:
            already_processed.add('CREATED')
            try:
                self.CREATED = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (CREATED): %s' % exp)
        value = find_attr_value_('CHECKSUM', node)
        if value is not None and 'CHECKSUM' not in already_processed:
            already_processed.add('CHECKSUM')
            self.CHECKSUM = value
        value = find_attr_value_('CHECKSUMTYPE', node)
        if value is not None and 'CHECKSUMTYPE' not in already_processed:
            already_processed.add('CHECKSUMTYPE')
            self.CHECKSUMTYPE = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FLocat':
            obj_ = FLocatType.factory(parent_object_=self)
            obj_.build(child_)
            self.FLocat.append(obj_)
            obj_.original_tagname_ = 'FLocat'
        elif nodeName_ == 'FContent':
            obj_ = FContentType.factory(parent_object_=self)
            obj_.build(child_)
            self.FContent = obj_
            obj_.original_tagname_ = 'FContent'
        elif nodeName_ == 'stream':
            obj_ = streamType.factory(parent_object_=self)
            obj_.build(child_)
            self.stream.append(obj_)
            obj_.original_tagname_ = 'stream'
        elif nodeName_ == 'transformFile':
            obj_ = transformFileType.factory(parent_object_=self)
            obj_.build(child_)
            self.transformFile.append(obj_)
            obj_.original_tagname_ = 'transformFile'
        elif nodeName_ == 'file':
            obj_ = fileType.factory(parent_object_=self)
            obj_.build(child_)
            self.file.append(obj_)
            obj_.original_tagname_ = 'file'
# end class fileType


class metsHdrType(GeneratedsSuper):
    """The mets header element <metsHdr> captures metadata about the METS
    document itself, not the digital object the METS document encodes.
    Although it records a more limited set of metadata, it is very similar
    in function and purpose to the headers employed in other schema such as
    the Text Encoding Initiative (TEI) or in the Encoded Archival
    Description (EAD).
    ID (ID/O): This attribute uniquely identifies the element within the METS
    document, and would allow the element to be referenced unambiguously
    from another element or document via an IDREF or an XPTR. For more
    information on using ID attributes for internal and external linking
    see Chapter 4 of the METS Primer.
    ADMID (IDREFS/O): Contains the ID attribute values of the <techMD>,
    <sourceMD>, <rightsMD> and/or <digiprovMD> elements within the <amdSec>
    of the METS document that contain administrative metadata pertaining to
    the METS document itself. For more information on using METS IDREFS and
    IDREF type attributes for internal linking, see Chapter 4 of the METS
    Primer.
    CREATEDATE (dateTime/O): Records the date/time the METS document was
    created.
    LASTMODDATE (dateTime/O): Is used to indicate the date/time the METS
    document was last modified.
    RECORDSTATUS (string/O): Specifies the status of the METS document. It is
    used for internal processing purposes."""
    subclass = None
    superclass = None
    def __init__(self, ID=None, ADMID=None, CREATEDATE=None, LASTMODDATE=None, RECORDSTATUS=None, agent=None, altRecordID=None, metsDocumentID=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ID = _cast(None, ID)
        self.ADMID = _cast(None, ADMID)
        if isinstance(CREATEDATE, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(CREATEDATE, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = CREATEDATE
        self.CREATEDATE = initvalue_
        if isinstance(LASTMODDATE, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(LASTMODDATE, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = LASTMODDATE
        self.LASTMODDATE = initvalue_
        self.RECORDSTATUS = _cast(None, RECORDSTATUS)
        if agent is None:
            self.agent = []
        else:
            self.agent = agent
        if altRecordID is None:
            self.altRecordID = []
        else:
            self.altRecordID = altRecordID
        self.metsDocumentID = metsDocumentID
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, metsHdrType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if metsHdrType.subclass:
            return metsHdrType.subclass(*args_, **kwargs_)
        else:
            return metsHdrType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_agent(self):
        return self.agent
    def set_agent(self, agent):
        self.agent = agent
    def add_agent(self, value):
        self.agent.append(value)
    def insert_agent_at(self, index, value):
        self.agent.insert(index, value)
    def replace_agent_at(self, index, value):
        self.agent[index] = value
    def get_altRecordID(self):
        return self.altRecordID
    def set_altRecordID(self, altRecordID):
        self.altRecordID = altRecordID
    def add_altRecordID(self, value):
        self.altRecordID.append(value)
    def insert_altRecordID_at(self, index, value):
        self.altRecordID.insert(index, value)
    def replace_altRecordID_at(self, index, value):
        self.altRecordID[index] = value
    def get_metsDocumentID(self):
        return self.metsDocumentID
    def set_metsDocumentID(self, metsDocumentID):
        self.metsDocumentID = metsDocumentID
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_ADMID(self):
        return self.ADMID
    def set_ADMID(self, ADMID):
        self.ADMID = ADMID
    def get_CREATEDATE(self):
        return self.CREATEDATE
    def set_CREATEDATE(self, CREATEDATE):
        self.CREATEDATE = CREATEDATE
    def get_LASTMODDATE(self):
        return self.LASTMODDATE
    def set_LASTMODDATE(self, LASTMODDATE):
        self.LASTMODDATE = LASTMODDATE
    def get_RECORDSTATUS(self):
        return self.RECORDSTATUS
    def set_RECORDSTATUS(self, RECORDSTATUS):
        self.RECORDSTATUS = RECORDSTATUS
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.agent or
            self.altRecordID or
            self.metsDocumentID is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='metsHdrType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('metsHdrType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='metsHdrType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, '', namespacedef_, name_='metsHdrType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='metsHdrType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' %d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.ADMID is not None and 'ADMID' not in already_processed:
            already_processed.add('ADMID')
            outfile.write(' ADMID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ADMID), input_name='ADMID')), ))
        if self.CREATEDATE is not None and 'CREATEDATE' not in already_processed:
            already_processed.add('CREATEDATE')
            outfile.write(' CREATEDATE="%s"' % self.gds_format_datetime(self.CREATEDATE, input_name='CREATEDATE'))
        if self.LASTMODDATE is not None and 'LASTMODDATE' not in already_processed:
            already_processed.add('LASTMODDATE')
            outfile.write(' LASTMODDATE="%s"' % self.gds_format_datetime(self.LASTMODDATE, input_name='LASTMODDATE'))
        if self.RECORDSTATUS is not None and 'RECORDSTATUS' not in already_processed:
            already_processed.add('RECORDSTATUS')
            outfile.write(' RECORDSTATUS=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.RECORDSTATUS), input_name='RECORDSTATUS')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='metsHdrType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for agent_ in self.agent:
            agent_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='agent', pretty_print=pretty_print)
        for altRecordID_ in self.altRecordID:
            altRecordID_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='altRecordID', pretty_print=pretty_print)
        if self.metsDocumentID is not None:
            self.metsDocumentID.export(outfile, level, namespaceprefix_, namespacedef_='', name_='metsDocumentID', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('ADMID', node)
        if value is not None and 'ADMID' not in already_processed:
            already_processed.add('ADMID')
            self.ADMID = value
        value = find_attr_value_('CREATEDATE', node)
        if value is not None and 'CREATEDATE' not in already_processed:
            already_processed.add('CREATEDATE')
            try:
                self.CREATEDATE = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (CREATEDATE): %s' % exp)
        value = find_attr_value_('LASTMODDATE', node)
        if value is not None and 'LASTMODDATE' not in already_processed:
            already_processed.add('LASTMODDATE')
            try:
                self.LASTMODDATE = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (LASTMODDATE): %s' % exp)
        value = find_attr_value_('RECORDSTATUS', node)
        if value is not None and 'RECORDSTATUS' not in already_processed:
            already_processed.add('RECORDSTATUS')
            self.RECORDSTATUS = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'agent':
            obj_ = agentType.factory(parent_object_=self)
            obj_.build(child_)
            self.agent.append(obj_)
            obj_.original_tagname_ = 'agent'
        elif nodeName_ == 'altRecordID':
            obj_ = altRecordIDType.factory(parent_object_=self)
            obj_.build(child_)
            self.altRecordID.append(obj_)
            obj_.original_tagname_ = 'altRecordID'
        elif nodeName_ == 'metsDocumentID':
            obj_ = metsDocumentIDType.factory(parent_object_=self)
            obj_.build(child_)
            self.metsDocumentID = obj_
            obj_.original_tagname_ = 'metsDocumentID'
# end class metsHdrType


class agentType(GeneratedsSuper):
    """agent:
    The agent element <agent> provides for various parties and their roles with
    respect to the METS record to be documented.
    ID (ID/O): This attribute uniquely identifies the element within the METS
    document, and would allow the element to be referenced unambiguously
    from another element or document via an IDREF or an XPTR. For more
    information on using ID attributes for internal and external linking
    see Chapter 4 of the METS Primer.
    ROLE (string/R): Specifies the function of the agent with respect to the
    METS record. The allowed values are:
    CREATOR: The person(s) or institution(s) responsible for the METS document.
    EDITOR: The person(s) or institution(s) that prepares the metadata for
    encoding.
    ARCHIVIST: The person(s) or institution(s) responsible for the
    document/collection.
    PRESERVATION: The person(s) or institution(s) responsible for preservation
    functions.
    DISSEMINATOR: The person(s) or institution(s) responsible for dissemination
    functions.
    CUSTODIAN: The person(s) or institution(s) charged with the oversight of a
    document/collection.
    IPOWNER: Intellectual Property Owner: The person(s) or institution holding
    copyright, trade or service marks or other intellectual property rights
    for the object.
    OTHER: Use OTHER if none of the preceding values pertains and clarify the
    type and location specifier being used in the OTHERROLE attribute (see
    below).
    OTHERROLE (string/O): Denotes a role not contained in the allowed values
    set if OTHER is indicated in the ROLE attribute.
    TYPE (string/O): is used to specify the type of AGENT. It must be one of
    the following values:
    INDIVIDUAL: Use if an individual has served as the agent.
    ORGANIZATION: Use if an institution, corporate body, association, non-
    profit enterprise, government, religious body, etc. has served as the
    agent.
    OTHER: Use OTHER if none of the preceding values pertain and clarify the
    type of agent specifier being used in the OTHERTYPE attribute
    OTHERTYPE (string/O): Specifies the type of agent when the value OTHER is
    indicated in the TYPE attribute."""
    subclass = None
    superclass = None
    def __init__(self, ID=None, ROLE=None, OTHERROLE=None, TYPE=None, OTHERTYPE=None, name=None, note=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ID = _cast(None, ID)
        self.ROLE = _cast(None, ROLE)
        self.OTHERROLE = _cast(None, OTHERROLE)
        self.TYPE = _cast(None, TYPE)
        self.OTHERTYPE = _cast(None, OTHERTYPE)
        self.name = name
        if note is None:
            self.note = []
        else:
            self.note = note
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, agentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if agentType.subclass:
            return agentType.subclass(*args_, **kwargs_)
        else:
            return agentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_note(self):
        return self.note
    def set_note(self, note):
        self.note = note
    def add_note(self, value):
        self.note.append(value)
    def insert_note_at(self, index, value):
        self.note.insert(index, value)
    def replace_note_at(self, index, value):
        self.note[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_ROLE(self):
        return self.ROLE
    def set_ROLE(self, ROLE):
        self.ROLE = ROLE
    def get_OTHERROLE(self):
        return self.OTHERROLE
    def set_OTHERROLE(self, OTHERROLE):
        self.OTHERROLE = OTHERROLE
    def get_TYPE(self):
        return self.TYPE
    def set_TYPE(self, TYPE):
        self.TYPE = TYPE
    def get_OTHERTYPE(self):
        return self.OTHERTYPE
    def set_OTHERTYPE(self, OTHERTYPE):
        self.OTHERTYPE = OTHERTYPE
    def hasContent_(self):
        if (
            self.name is not None or
            self.note
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='agentType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('agentType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='agentType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, '', namespacedef_, name_='agentType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='agentType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if 'ROLE' not in already_processed:
            already_processed.add('ROLE')
            outfile.write(' ROLE=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ROLE), input_name='ROLE')), ))
        if self.OTHERROLE is not None and 'OTHERROLE' not in already_processed:
            already_processed.add('OTHERROLE')
            outfile.write(' OTHERROLE=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.OTHERROLE), input_name='OTHERROLE')), ))
        if self.TYPE is not None and 'TYPE' not in already_processed:
            already_processed.add('TYPE')
            outfile.write(' TYPE=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.TYPE), input_name='TYPE')), ))
        if self.OTHERTYPE is not None and 'OTHERTYPE' not in already_processed:
            already_processed.add('OTHERTYPE')
            outfile.write(' OTHERTYPE=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.OTHERTYPE), input_name='OTHERTYPE')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='agentType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        for note_ in self.note:
            note_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='note', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('ROLE', node)
        if value is not None and 'ROLE' not in already_processed:
            already_processed.add('ROLE')
            self.ROLE = value
        value = find_attr_value_('OTHERROLE', node)
        if value is not None and 'OTHERROLE' not in already_processed:
            already_processed.add('OTHERROLE')
            self.OTHERROLE = value
        value = find_attr_value_('TYPE', node)
        if value is not None and 'TYPE' not in already_processed:
            already_processed.add('TYPE')
            self.TYPE = value
        value = find_attr_value_('OTHERTYPE', node)
        if value is not None and 'OTHERTYPE' not in already_processed:
            already_processed.add('OTHERTYPE')
            self.OTHERTYPE = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
        elif nodeName_ == 'note':
            obj_ = noteType.factory(parent_object_=self)
            obj_.build(child_)
            self.note.append(obj_)
            obj_.original_tagname_ = 'note'
# end class agentType


class noteType(GeneratedsSuper):
    """The <note> element can be used to record any additional information
    regarding the agent's activities with respect to the METS document."""
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, noteType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if noteType.subclass:
            return noteType.subclass(*args_, **kwargs_)
        else:
            return noteType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='noteType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('noteType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='noteType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, '', namespacedef_, name_='noteType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='noteType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' %d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='noteType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class noteType


class altRecordIDType(GeneratedsSuper):
    """The alternative record identifier element <altRecordID> allows one to
    use alternative record identifier values for the digital object
    represented by the METS document; the primary record identifier is
    stored in the OBJID attribute in the root <mets> element.
    ID (ID/O): This attribute uniquely identifies the element within the METS
    document, and would allow the element to be referenced unambiguously
    from another element or document via an IDREF or an XPTR. For more
    information on using ID attributes for internal and external linking
    see Chapter 4 of the METS Primer.
    TYPE (string/O): A description of the identifier type (e.g., OCLC record
    number, LCCN, etc.)."""
    subclass = None
    superclass = None
    def __init__(self, ID=None, TYPE=None, valueOf_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ID = _cast(None, ID)
        self.TYPE = _cast(None, TYPE)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, altRecordIDType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if altRecordIDType.subclass:
            return altRecordIDType.subclass(*args_, **kwargs_)
        else:
            return altRecordIDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_TYPE(self):
        return self.TYPE
    def set_TYPE(self, TYPE):
        self.TYPE = TYPE
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='altRecordIDType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('altRecordIDType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='altRecordIDType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, '', namespacedef_, name_='altRecordIDType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='altRecordIDType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.TYPE is not None and 'TYPE' not in already_processed:
            already_processed.add('TYPE')
            outfile.write(' TYPE=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.TYPE), input_name='TYPE')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='altRecordIDType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('TYPE', node)
        if value is not None and 'TYPE' not in already_processed:
            already_processed.add('TYPE')
            self.TYPE = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class altRecordIDType


class metsDocumentIDType(GeneratedsSuper):
    """The metsDocument identifier element <metsDocumentID> allows a unique
    identifier to be assigned to the METS document itself. This may be
    different from the OBJID attribute value in the root <mets> element,
    which uniquely identifies the entire digital object represented by the
    METS document.
    ID (ID/O): This attribute uniquely identifies the element within the METS
    document, and would allow the element to be referenced unambiguously
    from another element or document via an IDREF or an XPTR. For more
    information on using ID attributes for internal and external linking
    see Chapter 4 of the METS Primer.
    TYPE (string/O): A description of the identifier type."""
    subclass = None
    superclass = None
    def __init__(self, ID=None, TYPE=None, valueOf_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ID = _cast(None, ID)
        self.TYPE = _cast(None, TYPE)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, metsDocumentIDType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if metsDocumentIDType.subclass:
            return metsDocumentIDType.subclass(*args_, **kwargs_)
        else:
            return metsDocumentIDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_TYPE(self):
        return self.TYPE
    def set_TYPE(self, TYPE):
        self.TYPE = TYPE
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='metsDocumentIDType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('metsDocumentIDType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='metsDocumentIDType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, '', namespacedef_, name_='metsDocumentIDType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='metsDocumentIDType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.TYPE is not None and 'TYPE' not in already_processed:
            already_processed.add('TYPE')
            outfile.write(' TYPE=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.TYPE), input_name='TYPE')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='metsDocumentIDType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('TYPE', node)
        if value is not None and 'TYPE' not in already_processed:
            already_processed.add('TYPE')
            self.TYPE = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class metsDocumentIDType


class fileSecType(GeneratedsSuper):
    """The overall purpose of the content file section element <fileSec> is to
    provide an inventory of and the location for the content files that
    comprise the digital object being described in the METS document.
    ID (ID/O): This attribute uniquely identifies the element within the METS
    document, and would allow the element to be referenced unambiguously
    from another element or document via an IDREF or an XPTR. For more
    information on using ID attributes for internal and external linking
    see Chapter 4 of the METS Primer."""
    subclass = None
    superclass = None
    def __init__(self, ID=None, fileGrp=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ID = _cast(None, ID)
        if fileGrp is None:
            self.fileGrp = []
        else:
            self.fileGrp = fileGrp
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, fileSecType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if fileSecType.subclass:
            return fileSecType.subclass(*args_, **kwargs_)
        else:
            return fileSecType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_fileGrp(self):
        return self.fileGrp
    def set_fileGrp(self, fileGrp):
        self.fileGrp = fileGrp
    def add_fileGrp(self, value):
        self.fileGrp.append(value)
    def insert_fileGrp_at(self, index, value):
        self.fileGrp.insert(index, value)
    def replace_fileGrp_at(self, index, value):
        self.fileGrp[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.fileGrp
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='fileSecType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('fileSecType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='fileSecType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, '', namespacedef_, name_='fileSecType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='fileSecType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' %d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='fileSecType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for fileGrp_ in self.fileGrp:
            fileGrp_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='fileGrp', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'fileGrp':
            obj_ = fileGrpType1.factory(parent_object_=self)
            obj_.build(child_)
            self.fileGrp.append(obj_)
            obj_.original_tagname_ = 'fileGrp'
# end class fileSecType


class fileGrpType1(fileGrpType):
    """A sequence of file group elements <fileGrp> can be used group the
    digital files comprising the content of a METS object either into a
    flat arrangement or, because each file group element can itself contain
    one or more file group elements, into a nested (hierarchical)
    arrangement. In the case where the content files are images of
    different formats and resolutions, for example, one could group the
    image content files by format and create a separate <fileGrp> for each
    image format/resolution such as:
    -- one <fileGrp> for the thumbnails of the images
    -- one <fileGrp> for the higher resolution JPEGs of the image
    -- one <fileGrp> for the master archival TIFFs of the images
    For a text resource with a variety of content file types one might group
    the content files at the highest level by type, and then use the
    <fileGrp> elements nesting capabilities to subdivide a <fileGrp> by
    format within the type, such as:
    -- one <fileGrp> for all of the page images with nested <fileGrp> elements
    for each image format/resolution (tiff, jpeg, gif)
    -- one <fileGrp> for a PDF version of all the pages of the document
    -- one <fileGrp> for a TEI encoded XML version of the entire document or
    each of its pages.
    A <fileGrp> may contain zero or more <fileGrp> elements and or <file>
    elements."""
    subclass = None
    superclass = fileGrpType
    def __init__(self, ID=None, VERSDATE=None, ADMID=None, USE=None, fileGrp=None, file=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(fileGrpType1, self).__init__(ID, VERSDATE, ADMID, USE, fileGrp, file,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, fileGrpType1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if fileGrpType1.subclass:
            return fileGrpType1.subclass(*args_, **kwargs_)
        else:
            return fileGrpType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(fileGrpType1, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='fileGrpType1', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('fileGrpType1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='fileGrpType1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, '', namespacedef_, name_='fileGrpType1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='fileGrpType1'):
        super(fileGrpType1, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='fileGrpType1')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='fileGrpType1', fromsubclass_=False, pretty_print=True):
        super(fileGrpType1, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(fileGrpType1, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(fileGrpType1, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class fileGrpType1


class structLinkType2(structLinkType):
    """The structural link section element <structLink> allows for the
    specification of hyperlinks between the different components of a METS
    structure that are delineated in a structural map. This element is a
    container for a single, repeatable element, <smLink> which indicates a
    hyperlink between two nodes in the structural map. The <structLink>
    section in the METS document is identified using its XML ID
    attributes."""
    subclass = None
    superclass = structLinkType
    def __init__(self, ID=None, smLink=None, smLinkGrp=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(structLinkType2, self).__init__(ID, smLink, smLinkGrp,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, structLinkType2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if structLinkType2.subclass:
            return structLinkType2.subclass(*args_, **kwargs_)
        else:
            return structLinkType2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(structLinkType2, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='structLinkType2', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('structLinkType2')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='structLinkType2')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, '', namespacedef_, name_='structLinkType2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='structLinkType2'):
        super(structLinkType2, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='structLinkType2')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='structLinkType2', fromsubclass_=False, pretty_print=True):
        super(structLinkType2, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(structLinkType2, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(structLinkType2, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class structLinkType2


class mptrType(GeneratedsSuper):
    """Like the <fptr> element, the METS pointer element <mptr> represents
    digital content that manifests its parent <div> element. Unlike the
    <fptr>, which either directly or indirectly points to content
    represented in the <fileSec> of the parent METS document, the <mptr>
    element points to content represented by an external METS document.
    Thus, this element allows multiple discrete and separate METS documents
    to be organized at a higher level by a separate METS document. For
    example, METS documents representing the individual issues in the
    series of a journal could be grouped together and organized by a higher
    level METS document that represents the entire journal series. Each of
    the <div> elements in the <structMap> of the METS document representing
    the journal series would point to a METS document representing an
    issue. It would do so via a child <mptr> element. Thus the <mptr>
    element gives METS users considerable flexibility in managing the depth
    of the <structMap> hierarchy of individual METS documents. The <mptr>
    element points to an external METS document by means of an xlink:href
    attribute and associated XLink attributes.
    ID (ID/O): This attribute uniquely identifies the element within the METS
    document, and would allow the element to be referenced unambiguously
    from another element or document via an IDREF or an XPTR. For more
    information on using ID attributes for internal and external linking
    see Chapter 4 of the METS Primer.
    CONTENTIDS (URI/O): Content IDs for the content represented by the <mptr>
    (equivalent to DIDL DII or Digital Item Identifier, a unique external
    ID)."""
    subclass = None
    superclass = None
    def __init__(self, ID=None, CONTENTIDS=None, LOCTYPE=None, OTHERLOCTYPE=None, type_='simple', href=None, role=None, arcrole=None, title=None, show=None, actuate=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ID = _cast(None, ID)
        self.CONTENTIDS = _cast(None, CONTENTIDS)
        self.LOCTYPE = _cast(None, LOCTYPE)
        self.OTHERLOCTYPE = _cast(None, OTHERLOCTYPE)
        self.type_ = _cast(None, type_)
        self.href = _cast(None, href)
        self.role = _cast(None, role)
        self.arcrole = _cast(None, arcrole)
        self.title = _cast(None, title)
        self.show = _cast(None, show)
        self.actuate = _cast(None, actuate)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, mptrType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if mptrType.subclass:
            return mptrType.subclass(*args_, **kwargs_)
        else:
            return mptrType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_CONTENTIDS(self):
        return self.CONTENTIDS
    def set_CONTENTIDS(self, CONTENTIDS):
        self.CONTENTIDS = CONTENTIDS
    def get_LOCTYPE(self):
        return self.LOCTYPE
    def set_LOCTYPE(self, LOCTYPE):
        self.LOCTYPE = LOCTYPE
    def get_OTHERLOCTYPE(self):
        return self.OTHERLOCTYPE
    def set_OTHERLOCTYPE(self, OTHERLOCTYPE):
        self.OTHERLOCTYPE = OTHERLOCTYPE
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_href(self):
        return self.href
    def set_href(self, href):
        self.href = href
    def get_role(self):
        return self.role
    def set_role(self, role):
        self.role = role
    def get_arcrole(self):
        return self.arcrole
    def set_arcrole(self, arcrole):
        self.arcrole = arcrole
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def get_show(self):
        return self.show
    def set_show(self, show):
        self.show = show
    def get_actuate(self):
        return self.actuate
    def set_actuate(self, actuate):
        self.actuate = actuate
    def validate_URIs(self, value):
        # Validate type URIs, a restriction on xsd:anyURI.
        pass
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='mptrType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('mptrType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='mptrType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, '', namespacedef_, name_='mptrType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='mptrType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.CONTENTIDS is not None and 'CONTENTIDS' not in already_processed:
            already_processed.add('CONTENTIDS')
            outfile.write(' CONTENTIDS=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.CONTENTIDS), input_name='CONTENTIDS')), ))
        if 'LOCTYPE' not in already_processed:
            already_processed.add('LOCTYPE')
            outfile.write(' LOCTYPE=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.LOCTYPE), input_name='LOCTYPE')), ))
        if self.OTHERLOCTYPE is not None and 'OTHERLOCTYPE' not in already_processed:
            already_processed.add('OTHERLOCTYPE')
            outfile.write(' OTHERLOCTYPE=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.OTHERLOCTYPE), input_name='OTHERLOCTYPE')), ))
        if self.type_ != "simple" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (quote_attrib(self.href), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.add('role')
            outfile.write(' role=%s' % (quote_attrib(self.role), ))
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            outfile.write(' arcrole=%s' % (quote_attrib(self.arcrole), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.add('title')
            outfile.write(' title=%s' % (quote_attrib(self.title), ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.add('show')
            outfile.write(' show=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.show), input_name='show')), ))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            outfile.write(' actuate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.actuate), input_name='actuate')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='mptrType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('CONTENTIDS', node)
        if value is not None and 'CONTENTIDS' not in already_processed:
            already_processed.add('CONTENTIDS')
            self.CONTENTIDS = value
            self.validate_URIs(self.CONTENTIDS)    # validate type URIs
        value = find_attr_value_('LOCTYPE', node)
        if value is not None and 'LOCTYPE' not in already_processed:
            already_processed.add('LOCTYPE')
            self.LOCTYPE = value
        value = find_attr_value_('OTHERLOCTYPE', node)
        if value is not None and 'OTHERLOCTYPE' not in already_processed:
            already_processed.add('OTHERLOCTYPE')
            self.OTHERLOCTYPE = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.add('role')
            self.role = value
        value = find_attr_value_('arcrole', node)
        if value is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            self.arcrole = value
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.add('title')
            self.title = value
        value = find_attr_value_('show', node)
        if value is not None and 'show' not in already_processed:
            already_processed.add('show')
            self.show = value
        value = find_attr_value_('actuate', node)
        if value is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            self.actuate = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class mptrType


class fptrType(GeneratedsSuper):
    """The <fptr> or file pointer element represents digital content that
    manifests its parent <div> element. The content represented by an
    <fptr> element must consist of integral files or parts of files that
    are represented by <file> elements in the <fileSec>. Via its FILEID
    attribute, an <fptr> may point directly to a single integral <file>
    element that manifests a structural division. However, an <fptr>
    element may also govern an <area> element, a <par>, or a <seq> which in
    turn would point to the relevant file or files. A child <area> element
    can point to part of a <file> that manifests a division, while the
    <par> and <seq> elements can point to multiple files or parts of files
    that together manifest a division. More than one <fptr> element can be
    associated with a <div> element. Typically sibling <fptr> elements
    represent alternative versions, or manifestations, of the same content
    ID (ID/O): This attribute uniquely identifies the element within the METS
    document, and would allow the element to be referenced unambiguously
    from another element or document via an IDREF or an XPTR. For more
    information on using ID attributes for internal and external linking
    see Chapter 4 of the METS Primer.
    FILEID (IDREF/O): An optional attribute that provides the XML ID
    identifying the <file> element that links to and/or contains the
    digital content represented by the <fptr>. A <fptr> element should only
    have a FILEID attribute value if it does not have a child <area>, <par>
    or <seq> element. If it has a child element, then the responsibility
    for pointing to the relevant content falls to this child element or its
    descendants.
    CONTENTIDS (URI/O): Content IDs for the content represented by the <fptr>
    (equivalent to DIDL DII or Digital Item Identifier, a unique external
    ID)."""
    subclass = None
    superclass = None
    def __init__(self, ID=None, FILEID=None, CONTENTIDS=None, par=None, seq=None, area=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ID = _cast(None, ID)
        self.FILEID = _cast(None, FILEID)
        self.CONTENTIDS = _cast(None, CONTENTIDS)
        self.par = par
        self.seq = seq
        self.area = area
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, fptrType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if fptrType.subclass:
            return fptrType.subclass(*args_, **kwargs_)
        else:
            return fptrType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_par(self):
        return self.par
    def set_par(self, par):
        self.par = par
    def get_seq(self):
        return self.seq
    def set_seq(self, seq):
        self.seq = seq
    def get_area(self):
        return self.area
    def set_area(self, area):
        self.area = area
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_FILEID(self):
        return self.FILEID
    def set_FILEID(self, FILEID):
        self.FILEID = FILEID
    def get_CONTENTIDS(self):
        return self.CONTENTIDS
    def set_CONTENTIDS(self, CONTENTIDS):
        self.CONTENTIDS = CONTENTIDS
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def validate_URIs(self, value):
        # Validate type URIs, a restriction on xsd:anyURI.
        pass
    def hasContent_(self):
        if (
            self.par is not None or
            self.seq is not None or
            self.area is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='fptrType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('fptrType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='fptrType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, '', namespacedef_, name_='fptrType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='fptrType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' %d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.FILEID is not None and 'FILEID' not in already_processed:
            already_processed.add('FILEID')
            outfile.write(' FILEID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.FILEID), input_name='FILEID')), ))
        if self.CONTENTIDS is not None and 'CONTENTIDS' not in already_processed:
            already_processed.add('CONTENTIDS')
            outfile.write(' CONTENTIDS=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.CONTENTIDS), input_name='CONTENTIDS')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='fptrType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.par is not None:
            self.par.export(outfile, level, namespaceprefix_, namespacedef_='', name_='par', pretty_print=pretty_print)
        if self.seq is not None:
            self.seq.export(outfile, level, namespaceprefix_, namespacedef_='', name_='seq', pretty_print=pretty_print)
        if self.area is not None:
            self.area.export(outfile, level, namespaceprefix_, namespacedef_='', name_='area', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('FILEID', node)
        if value is not None and 'FILEID' not in already_processed:
            already_processed.add('FILEID')
            self.FILEID = value
        value = find_attr_value_('CONTENTIDS', node)
        if value is not None and 'CONTENTIDS' not in already_processed:
            already_processed.add('CONTENTIDS')
            self.CONTENTIDS = value
            self.validate_URIs(self.CONTENTIDS)    # validate type URIs
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'par':
            obj_ = parType.factory(parent_object_=self)
            obj_.build(child_)
            self.par = obj_
            obj_.original_tagname_ = 'par'
        elif nodeName_ == 'seq':
            obj_ = seqType.factory(parent_object_=self)
            obj_.build(child_)
            self.seq = obj_
            obj_.original_tagname_ = 'seq'
        elif nodeName_ == 'area':
            obj_ = areaType.factory(parent_object_=self)
            obj_.build(child_)
            self.area = obj_
            obj_.original_tagname_ = 'area'
# end class fptrType


class smLinkType(GeneratedsSuper):
    """The Structural Map Link element <smLink> identifies a hyperlink between
    two nodes in the structural map. You would use <smLink>, for instance,
    to note the existence of hypertext links between web pages, if you
    wished to record those links within METS. NOTE: <smLink> is an empty
    element. The location of the <smLink> element to which the <smLink>
    element is pointing MUST be stored in the xlink:href attribute.
    ID (ID/O): This attribute uniquely identifies the element within the METS
    document, and would allow the element to be referenced unambiguously
    from another element or document via an IDREF or an XPTR. For more
    information on using ID attributes for internal and external linking
    see Chapter 4 of the METS Primer.
    xlink:arcrole - the role of the link, as per the xlink specification. See
    http://www.w3.org/TR/xlink/
    xlink:title - a title for the link (if needed), as per the xlink
    specification. See http://www.w3.org/TR/xlink/
    xlink:show - see the xlink specification at http://www.w3.org/TR/xlink/
    xlink:actuate - see the xlink specification at http://www.w3.org/TR/xlink/
    xlink:to - the value of the label for the element in the structMap you are
    linking to.
    xlink:from - the value of the label for the element in the structMap you
    are linking from."""
    subclass = None
    superclass = None
    def __init__(self, ID=None, arcrole=None, title=None, show=None, actuate=None, to=None, from_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ID = _cast(None, ID)
        self.arcrole = _cast(None, arcrole)
        self.title = _cast(None, title)
        self.show = _cast(None, show)
        self.actuate = _cast(None, actuate)
        self.to = _cast(None, to)
        self.from_ = _cast(None, from_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, smLinkType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if smLinkType.subclass:
            return smLinkType.subclass(*args_, **kwargs_)
        else:
            return smLinkType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_arcrole(self):
        return self.arcrole
    def set_arcrole(self, arcrole):
        self.arcrole = arcrole
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def get_show(self):
        return self.show
    def set_show(self, show):
        self.show = show
    def get_actuate(self):
        return self.actuate
    def set_actuate(self, actuate):
        self.actuate = actuate
    def get_to(self):
        return self.to
    def set_to(self, to):
        self.to = to
    def get_from(self):
        return self.from_
    def set_from(self, from_):
        self.from_ = from_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='smLinkType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('smLinkType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='smLinkType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, '', namespacedef_, name_='smLinkType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='smLinkType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            outfile.write(' arcrole=%s' % (quote_attrib(self.arcrole), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.add('title')
            outfile.write(' title=%s' % (quote_attrib(self.title), ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.add('show')
            outfile.write(' show=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.show), input_name='show')), ))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            outfile.write(' actuate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.actuate), input_name='actuate')), ))
        if 'to' not in already_processed:
            already_processed.add('to')
            outfile.write(' to=%s' % (quote_attrib(self.to), ))
        if 'from_' not in already_processed:
            already_processed.add('from_')
            outfile.write(' from=%s' % (quote_attrib(self.from_), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='smLinkType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('arcrole', node)
        if value is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            self.arcrole = value
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.add('title')
            self.title = value
        value = find_attr_value_('show', node)
        if value is not None and 'show' not in already_processed:
            already_processed.add('show')
            self.show = value
        value = find_attr_value_('actuate', node)
        if value is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            self.actuate = value
        value = find_attr_value_('to', node)
        if value is not None and 'to' not in already_processed:
            already_processed.add('to')
            self.to = value
        value = find_attr_value_('from', node)
        if value is not None and 'from' not in already_processed:
            already_processed.add('from')
            self.from_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class smLinkType


class smLinkGrpType(GeneratedsSuper):
    """The structMap link group element <smLinkGrp> provides an implementation
    of xlink:extendLink, and provides xlink compliant mechanisms for
    establishing xlink:arcLink type links between 2 or more <div> elements
    in <structMap> element(s) occurring within the same METS document or
    different METS documents. The smLinkGrp could be used as an alternative
    to the <smLink> element to establish a one-to-one link between <div>
    elements in the same METS document in a fully xlink compliant manner.
    However, it can also be used to establish one-to-many or many-to-many
    links between <div> elements. For example, if a METS document contains
    two <structMap> elements, one of which represents a purely logical
    structure and one of which represents a purely physical structure, the
    <smLinkGrp> element would provide a means of mapping a <div>
    representing a logical entity (for example, a newspaper article) with
    multiple <div> elements in the physical <structMap> representing the
    physical areas that together comprise the logical entity (for example,
    the <div> elements representing the page areas that together comprise
    the newspaper article).
    ARCLINKORDER (enumerated string/O): ARCLINKORDER is used to indicate
    whether the order of the smArcLink elements aggregated by the smLinkGrp
    element is significant. If the order is significant, then a value of
    "ordered" should be supplied. Value defaults to "unordered" Note that
    the ARLINKORDER attribute has no xlink specified meaning."""
    subclass = None
    superclass = None
    def __init__(self, ID=None, ARCLINKORDER='unordered', type_='extended', role=None, title=None, smLocatorLink=None, smArcLink=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ID = _cast(None, ID)
        self.ARCLINKORDER = _cast(None, ARCLINKORDER)
        self.type_ = _cast(None, type_)
        self.role = _cast(None, role)
        self.title = _cast(None, title)
        if smLocatorLink is None:
            self.smLocatorLink = []
        else:
            self.smLocatorLink = smLocatorLink
        if smArcLink is None:
            self.smArcLink = []
        else:
            self.smArcLink = smArcLink
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, smLinkGrpType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if smLinkGrpType.subclass:
            return smLinkGrpType.subclass(*args_, **kwargs_)
        else:
            return smLinkGrpType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_smLocatorLink(self):
        return self.smLocatorLink
    def set_smLocatorLink(self, smLocatorLink):
        self.smLocatorLink = smLocatorLink
    def add_smLocatorLink(self, value):
        self.smLocatorLink.append(value)
    def insert_smLocatorLink_at(self, index, value):
        self.smLocatorLink.insert(index, value)
    def replace_smLocatorLink_at(self, index, value):
        self.smLocatorLink[index] = value
    def get_smArcLink(self):
        return self.smArcLink
    def set_smArcLink(self, smArcLink):
        self.smArcLink = smArcLink
    def add_smArcLink(self, value):
        self.smArcLink.append(value)
    def insert_smArcLink_at(self, index, value):
        self.smArcLink.insert(index, value)
    def replace_smArcLink_at(self, index, value):
        self.smArcLink[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_ARCLINKORDER(self):
        return self.ARCLINKORDER
    def set_ARCLINKORDER(self, ARCLINKORDER):
        self.ARCLINKORDER = ARCLINKORDER
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_role(self):
        return self.role
    def set_role(self, role):
        self.role = role
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def hasContent_(self):
        if (
            self.smLocatorLink or
            self.smArcLink
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='smLinkGrpType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('smLinkGrpType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='smLinkGrpType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, '', namespacedef_, name_='smLinkGrpType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='smLinkGrpType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.ARCLINKORDER != "unordered" and 'ARCLINKORDER' not in already_processed:
            already_processed.add('ARCLINKORDER')
            outfile.write(' ARCLINKORDER=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ARCLINKORDER), input_name='ARCLINKORDER')), ))
        if self.type_ != "extended" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.add('role')
            outfile.write(' role=%s' % (quote_attrib(self.role), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.add('title')
            outfile.write(' title=%s' % (quote_attrib(self.title), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='smLinkGrpType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for smLocatorLink_ in self.smLocatorLink:
            smLocatorLink_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='smLocatorLink', pretty_print=pretty_print)
        for smArcLink_ in self.smArcLink:
            smArcLink_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='smArcLink', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('ARCLINKORDER', node)
        if value is not None and 'ARCLINKORDER' not in already_processed:
            already_processed.add('ARCLINKORDER')
            self.ARCLINKORDER = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.add('role')
            self.role = value
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.add('title')
            self.title = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'smLocatorLink':
            obj_ = smLocatorLinkType.factory(parent_object_=self)
            obj_.build(child_)
            self.smLocatorLink.append(obj_)
            obj_.original_tagname_ = 'smLocatorLink'
        elif nodeName_ == 'smArcLink':
            obj_ = smArcLinkType.factory(parent_object_=self)
            obj_.build(child_)
            self.smArcLink.append(obj_)
            obj_.original_tagname_ = 'smArcLink'
# end class smLinkGrpType


class smLocatorLinkType(GeneratedsSuper):
    """The structMap locator link element <smLocatorLink> is of xlink:type
    "locator". It provides a means of identifying a <div> element that will
    participate in one or more of the links specified by means of
    <smArcLink> elements within the same <smLinkGrp>. The participating
    <div> element that is represented by the <smLocatorLink> is identified
    by means of a URI in the associate xlink:href attribute. The lowest
    level of this xlink:href URI value should be a fragment identifier that
    references the ID value that identifies the relevant <div> element. For
    example, "xlink:href='#div20'" where "div20" is the ID value that
    identifies the pertinent <div> in the current METS document. Although
    not required by the xlink specification, an <smLocatorLink> element
    will typically include an xlink:label attribute in this context, as the
    <smArcLink> elements will reference these labels to establish the from
    and to sides of each arc link.
    ID (ID/O): This attribute uniquely identifies the element within the METS
    document, and would allow the element to be referenced unambiguously
    from another element or document via an IDREF or an XPTR. For more
    information on using ID attributes for internal and external linking
    see Chapter 4 of the METS Primer."""
    subclass = None
    superclass = None
    def __init__(self, ID=None, type_='locator', href=None, role=None, title=None, label=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ID = _cast(None, ID)
        self.type_ = _cast(None, type_)
        self.href = _cast(None, href)
        self.role = _cast(None, role)
        self.title = _cast(None, title)
        self.label = _cast(None, label)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, smLocatorLinkType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if smLocatorLinkType.subclass:
            return smLocatorLinkType.subclass(*args_, **kwargs_)
        else:
            return smLocatorLinkType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_href(self):
        return self.href
    def set_href(self, href):
        self.href = href
    def get_role(self):
        return self.role
    def set_role(self, role):
        self.role = role
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def get_label(self):
        return self.label
    def set_label(self, label):
        self.label = label
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='smLocatorLinkType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('smLocatorLinkType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='smLocatorLinkType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, '', namespacedef_, name_='smLocatorLinkType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='smLocatorLinkType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.type_ != "locator" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (quote_attrib(self.href), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.add('role')
            outfile.write(' role=%s' % (quote_attrib(self.role), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.add('title')
            outfile.write(' title=%s' % (quote_attrib(self.title), ))
        if self.label is not None and 'label' not in already_processed:
            already_processed.add('label')
            outfile.write(' label=%s' % (quote_attrib(self.label), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='smLocatorLinkType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.add('role')
            self.role = value
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.add('title')
            self.title = value
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.add('label')
            self.label = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class smLocatorLinkType


class smArcLinkType(GeneratedsSuper):
    """The structMap arc link element <smArcLink> is of xlink:type "arc" It can
    be used to establish a traversal link between two <div> elements as
    identified by <smLocatorLink> elements within the same smLinkGrp
    element. The associated xlink:from and xlink:to attributes identify the
    from and to sides of the arc link by referencing the xlink:label
    attribute values on the participating smLocatorLink elements.
    ID (ID/O): This attribute uniquely identifies the element within the METS
    document, and would allow the element to be referenced unambiguously
    from another element or document via an IDREF or an XPTR. For more
    information on using ID attributes for internal and external linking
    see Chapter 4 of the METS Primer.ARCTYPE (string/O):The ARCTYPE
    attribute provides a means of specifying the relationship between the
    <div> elements participating in the arc link, and hence the purpose or
    role of the link. While it can be considered analogous to the
    xlink:arcrole attribute, its type is a simple string, rather than
    anyURI. ARCTYPE has no xlink specified meaning, and the xlink:arcrole
    attribute should be used instead of or in addition to the ARCTYPE
    attribute when full xlink compliance is desired with respect to
    specifying the role or purpose of the arc link.
    ADMID (IDREFS/O): Contains the ID attribute values identifying the
    <sourceMD>, <techMD>, <digiprovMD> and/or <rightsMD> elements within
    the <amdSec> of the METS document that contain or link to
    administrative metadata pertaining to <smArcLink>. Typically the
    <smArcLink> ADMID attribute would be used to identify one or more
    <sourceMD> and/or <techMD> elements that refine or clarify the
    relationship between the xlink:from and xlink:to sides of the arc. For
    more information on using METS IDREFS and IDREF type attributes for
    internal linking, see Chapter 4 of the METS Primer."""
    subclass = None
    superclass = None
    def __init__(self, ID=None, ARCTYPE=None, ADMID=None, type_='arc', arcrole=None, title=None, show=None, actuate=None, from_=None, to=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ID = _cast(None, ID)
        self.ARCTYPE = _cast(None, ARCTYPE)
        self.ADMID = _cast(None, ADMID)
        self.type_ = _cast(None, type_)
        self.arcrole = _cast(None, arcrole)
        self.title = _cast(None, title)
        self.show = _cast(None, show)
        self.actuate = _cast(None, actuate)
        self.from_ = _cast(None, from_)
        self.to = _cast(None, to)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, smArcLinkType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if smArcLinkType.subclass:
            return smArcLinkType.subclass(*args_, **kwargs_)
        else:
            return smArcLinkType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_ARCTYPE(self):
        return self.ARCTYPE
    def set_ARCTYPE(self, ARCTYPE):
        self.ARCTYPE = ARCTYPE
    def get_ADMID(self):
        return self.ADMID
    def set_ADMID(self, ADMID):
        self.ADMID = ADMID
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_arcrole(self):
        return self.arcrole
    def set_arcrole(self, arcrole):
        self.arcrole = arcrole
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def get_show(self):
        return self.show
    def set_show(self, show):
        self.show = show
    def get_actuate(self):
        return self.actuate
    def set_actuate(self, actuate):
        self.actuate = actuate
    def get_from(self):
        return self.from_
    def set_from(self, from_):
        self.from_ = from_
    def get_to(self):
        return self.to
    def set_to(self, to):
        self.to = to
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='smArcLinkType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('smArcLinkType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='smArcLinkType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, '', namespacedef_, name_='smArcLinkType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='smArcLinkType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.ARCTYPE is not None and 'ARCTYPE' not in already_processed:
            already_processed.add('ARCTYPE')
            outfile.write(' ARCTYPE=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ARCTYPE), input_name='ARCTYPE')), ))
        if self.ADMID is not None and 'ADMID' not in already_processed:
            already_processed.add('ADMID')
            outfile.write(' ADMID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ADMID), input_name='ADMID')), ))
        if self.type_ != "arc" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            outfile.write(' arcrole=%s' % (quote_attrib(self.arcrole), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.add('title')
            outfile.write(' title=%s' % (quote_attrib(self.title), ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.add('show')
            outfile.write(' show=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.show), input_name='show')), ))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            outfile.write(' actuate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.actuate), input_name='actuate')), ))
        if self.from_ is not None and 'from_' not in already_processed:
            already_processed.add('from_')
            outfile.write(' from=%s' % (quote_attrib(self.from_), ))
        if self.to is not None and 'to' not in already_processed:
            already_processed.add('to')
            outfile.write(' to=%s' % (quote_attrib(self.to), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='smArcLinkType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('ARCTYPE', node)
        if value is not None and 'ARCTYPE' not in already_processed:
            already_processed.add('ARCTYPE')
            self.ARCTYPE = value
        value = find_attr_value_('ADMID', node)
        if value is not None and 'ADMID' not in already_processed:
            already_processed.add('ADMID')
            self.ADMID = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('arcrole', node)
        if value is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            self.arcrole = value
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.add('title')
            self.title = value
        value = find_attr_value_('show', node)
        if value is not None and 'show' not in already_processed:
            already_processed.add('show')
            self.show = value
        value = find_attr_value_('actuate', node)
        if value is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            self.actuate = value
        value = find_attr_value_('from', node)
        if value is not None and 'from' not in already_processed:
            already_processed.add('from')
            self.from_ = value
        value = find_attr_value_('to', node)
        if value is not None and 'to' not in already_processed:
            already_processed.add('to')
            self.to = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class smArcLinkType


class mdRefType(GeneratedsSuper):
    """The metadata reference element <mdRef> element is a generic element used
    throughout the METS schema to provide a pointer to metadata which
    resides outside the METS document. NB: <mdRef> is an empty element. The
    location of the metadata must be recorded in the xlink:href attribute,
    supplemented by the XPTR attribute as needed.
    ID (ID/O): This attribute uniquely identifies the element within the METS
    document, and would allow the element to be referenced unambiguously
    from another element or document via an IDREF or an XPTR. For more
    information on using ID attributes for internal and external linking
    see Chapter 4 of the METS Primer.
    LABEL (string/O): Provides a label to display to the viewer of the METS
    document that identifies the associated metadata.
    XPTR (string/O): Locates the point within a file to which the <mdRef>
    element refers, if applicable."""
    subclass = None
    superclass = None
    def __init__(self, ID=None, LABEL=None, XPTR=None, LOCTYPE=None, OTHERLOCTYPE=None, type_='simple', href=None, role=None, arcrole=None, title=None, show=None, actuate=None, MDTYPE=None, OTHERMDTYPE=None, MDTYPEVERSION=None, MIMETYPE=None, SIZE=None, CREATED=None, CHECKSUM=None, CHECKSUMTYPE=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ID = _cast(None, ID)
        self.LABEL = _cast(None, LABEL)
        self.XPTR = _cast(None, XPTR)
        self.LOCTYPE = _cast(None, LOCTYPE)
        self.OTHERLOCTYPE = _cast(None, OTHERLOCTYPE)
        self.type_ = _cast(None, type_)
        self.href = _cast(None, href)
        self.role = _cast(None, role)
        self.arcrole = _cast(None, arcrole)
        self.title = _cast(None, title)
        self.show = _cast(None, show)
        self.actuate = _cast(None, actuate)
        self.MDTYPE = _cast(None, MDTYPE)
        self.OTHERMDTYPE = _cast(None, OTHERMDTYPE)
        self.MDTYPEVERSION = _cast(None, MDTYPEVERSION)
        self.MIMETYPE = _cast(None, MIMETYPE)
        self.SIZE = _cast(int, SIZE)
        if isinstance(CREATED, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(CREATED, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = CREATED
        self.CREATED = initvalue_
        self.CHECKSUM = _cast(None, CHECKSUM)
        self.CHECKSUMTYPE = _cast(None, CHECKSUMTYPE)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, mdRefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if mdRefType.subclass:
            return mdRefType.subclass(*args_, **kwargs_)
        else:
            return mdRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_LABEL(self):
        return self.LABEL
    def set_LABEL(self, LABEL):
        self.LABEL = LABEL
    def get_XPTR(self):
        return self.XPTR
    def set_XPTR(self, XPTR):
        self.XPTR = XPTR
    def get_LOCTYPE(self):
        return self.LOCTYPE
    def set_LOCTYPE(self, LOCTYPE):
        self.LOCTYPE = LOCTYPE
    def get_OTHERLOCTYPE(self):
        return self.OTHERLOCTYPE
    def set_OTHERLOCTYPE(self, OTHERLOCTYPE):
        self.OTHERLOCTYPE = OTHERLOCTYPE
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_href(self):
        return self.href
    def set_href(self, href):
        self.href = href
    def get_role(self):
        return self.role
    def set_role(self, role):
        self.role = role
    def get_arcrole(self):
        return self.arcrole
    def set_arcrole(self, arcrole):
        self.arcrole = arcrole
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def get_show(self):
        return self.show
    def set_show(self, show):
        self.show = show
    def get_actuate(self):
        return self.actuate
    def set_actuate(self, actuate):
        self.actuate = actuate
    def get_MDTYPE(self):
        return self.MDTYPE
    def set_MDTYPE(self, MDTYPE):
        self.MDTYPE = MDTYPE
    def get_OTHERMDTYPE(self):
        return self.OTHERMDTYPE
    def set_OTHERMDTYPE(self, OTHERMDTYPE):
        self.OTHERMDTYPE = OTHERMDTYPE
    def get_MDTYPEVERSION(self):
        return self.MDTYPEVERSION
    def set_MDTYPEVERSION(self, MDTYPEVERSION):
        self.MDTYPEVERSION = MDTYPEVERSION
    def get_MIMETYPE(self):
        return self.MIMETYPE
    def set_MIMETYPE(self, MIMETYPE):
        self.MIMETYPE = MIMETYPE
    def get_SIZE(self):
        return self.SIZE
    def set_SIZE(self, SIZE):
        self.SIZE = SIZE
    def get_CREATED(self):
        return self.CREATED
    def set_CREATED(self, CREATED):
        self.CREATED = CREATED
    def get_CHECKSUM(self):
        return self.CHECKSUM
    def set_CHECKSUM(self, CHECKSUM):
        self.CHECKSUM = CHECKSUM
    def get_CHECKSUMTYPE(self):
        return self.CHECKSUMTYPE
    def set_CHECKSUMTYPE(self, CHECKSUMTYPE):
        self.CHECKSUMTYPE = CHECKSUMTYPE
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='mdRefType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('mdRefType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='mdRefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, '', namespacedef_, name_='mdRefType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='mdRefType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.LABEL is not None and 'LABEL' not in already_processed:
            already_processed.add('LABEL')
            outfile.write(' LABEL=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.LABEL), input_name='LABEL')), ))
        if self.XPTR is not None and 'XPTR' not in already_processed:
            already_processed.add('XPTR')
            outfile.write(' XPTR=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.XPTR), input_name='XPTR')), ))
        if 'LOCTYPE' not in already_processed:
            already_processed.add('LOCTYPE')
            outfile.write(' LOCTYPE=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.LOCTYPE), input_name='LOCTYPE')), ))
        if self.OTHERLOCTYPE is not None and 'OTHERLOCTYPE' not in already_processed:
            already_processed.add('OTHERLOCTYPE')
            outfile.write(' OTHERLOCTYPE=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.OTHERLOCTYPE), input_name='OTHERLOCTYPE')), ))
        if self.type_ != "simple" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (quote_attrib(self.href), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.add('role')
            outfile.write(' role=%s' % (quote_attrib(self.role), ))
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            outfile.write(' arcrole=%s' % (quote_attrib(self.arcrole), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.add('title')
            outfile.write(' title=%s' % (quote_attrib(self.title), ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.add('show')
            outfile.write(' show=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.show), input_name='show')), ))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            outfile.write(' actuate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.actuate), input_name='actuate')), ))
        if 'MDTYPE' not in already_processed:
            already_processed.add('MDTYPE')
            outfile.write(' MDTYPE=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.MDTYPE), input_name='MDTYPE')), ))
        if self.OTHERMDTYPE is not None and 'OTHERMDTYPE' not in already_processed:
            already_processed.add('OTHERMDTYPE')
            outfile.write(' OTHERMDTYPE=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.OTHERMDTYPE), input_name='OTHERMDTYPE')), ))
        if self.MDTYPEVERSION is not None and 'MDTYPEVERSION' not in already_processed:
            already_processed.add('MDTYPEVERSION')
            outfile.write(' MDTYPEVERSION=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.MDTYPEVERSION), input_name='MDTYPEVERSION')), ))
        if self.MIMETYPE is not None and 'MIMETYPE' not in already_processed:
            already_processed.add('MIMETYPE')
            outfile.write(' MIMETYPE=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.MIMETYPE), input_name='MIMETYPE')), ))
        if self.SIZE is not None and 'SIZE' not in already_processed:
            already_processed.add('SIZE')
            outfile.write(' SIZE="%s"' % self.gds_format_integer(self.SIZE, input_name='SIZE'))
        if self.CREATED is not None and 'CREATED' not in already_processed:
            already_processed.add('CREATED')
            outfile.write(' CREATED="%s"' % self.gds_format_datetime(self.CREATED, input_name='CREATED'))
        if self.CHECKSUM is not None and 'CHECKSUM' not in already_processed:
            already_processed.add('CHECKSUM')
            outfile.write(' CHECKSUM=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.CHECKSUM), input_name='CHECKSUM')), ))
        if self.CHECKSUMTYPE is not None and 'CHECKSUMTYPE' not in already_processed:
            already_processed.add('CHECKSUMTYPE')
            outfile.write(' CHECKSUMTYPE=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.CHECKSUMTYPE), input_name='CHECKSUMTYPE')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='mdRefType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('LABEL', node)
        if value is not None and 'LABEL' not in already_processed:
            already_processed.add('LABEL')
            self.LABEL = value
        value = find_attr_value_('XPTR', node)
        if value is not None and 'XPTR' not in already_processed:
            already_processed.add('XPTR')
            self.XPTR = value
        value = find_attr_value_('LOCTYPE', node)
        if value is not None and 'LOCTYPE' not in already_processed:
            already_processed.add('LOCTYPE')
            self.LOCTYPE = value
        value = find_attr_value_('OTHERLOCTYPE', node)
        if value is not None and 'OTHERLOCTYPE' not in already_processed:
            already_processed.add('OTHERLOCTYPE')
            self.OTHERLOCTYPE = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.add('role')
            self.role = value
        value = find_attr_value_('arcrole', node)
        if value is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            self.arcrole = value
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.add('title')
            self.title = value
        value = find_attr_value_('show', node)
        if value is not None and 'show' not in already_processed:
            already_processed.add('show')
            self.show = value
        value = find_attr_value_('actuate', node)
        if value is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            self.actuate = value
        value = find_attr_value_('MDTYPE', node)
        if value is not None and 'MDTYPE' not in already_processed:
            already_processed.add('MDTYPE')
            self.MDTYPE = value
        value = find_attr_value_('OTHERMDTYPE', node)
        if value is not None and 'OTHERMDTYPE' not in already_processed:
            already_processed.add('OTHERMDTYPE')
            self.OTHERMDTYPE = value
        value = find_attr_value_('MDTYPEVERSION', node)
        if value is not None and 'MDTYPEVERSION' not in already_processed:
            already_processed.add('MDTYPEVERSION')
            self.MDTYPEVERSION = value
        value = find_attr_value_('MIMETYPE', node)
        if value is not None and 'MIMETYPE' not in already_processed:
            already_processed.add('MIMETYPE')
            self.MIMETYPE = value
        value = find_attr_value_('SIZE', node)
        if value is not None and 'SIZE' not in already_processed:
            already_processed.add('SIZE')
            try:
                self.SIZE = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('CREATED', node)
        if value is not None and 'CREATED' not in already_processed:
            already_processed.add('CREATED')
            try:
                self.CREATED = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (CREATED): %s' % exp)
        value = find_attr_value_('CHECKSUM', node)
        if value is not None and 'CHECKSUM' not in already_processed:
            already_processed.add('CHECKSUM')
            self.CHECKSUM = value
        value = find_attr_value_('CHECKSUMTYPE', node)
        if value is not None and 'CHECKSUMTYPE' not in already_processed:
            already_processed.add('CHECKSUMTYPE')
            self.CHECKSUMTYPE = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class mdRefType


class mdWrapType(GeneratedsSuper):
    """A metadata wrapper element <mdWrap> provides a wrapper around metadata
    embedded within a METS document. The element is repeatable. Such
    metadata can be in one of two forms: 1) XML-encoded metadata, with the
    XML-encoding identifying itself as belonging to a namespace other than
    the METS document namespace. 2) Any arbitrary binary or textual form,
    PROVIDED that the metadata is Base64 encoded and wrapped in a <binData>
    element within the internal descriptive metadata element.
    ID (ID/O): This attribute uniquely identifies the element within the METS
    document, and would allow the element to be referenced unambiguously
    from another element or document via an IDREF or an XPTR. For more
    information on using ID attributes for internal and external linking
    see Chapter 4 of the METS Primer.
    LABEL: an optional string attribute providing a label to display to the
    viewer of the METS document identifying the metadata."""
    subclass = None
    superclass = None
    def __init__(self, ID=None, LABEL=None, MDTYPE=None, OTHERMDTYPE=None, MDTYPEVERSION=None, MIMETYPE=None, SIZE=None, CREATED=None, CHECKSUM=None, CHECKSUMTYPE=None, binData=None, xmlData=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ID = _cast(None, ID)
        self.LABEL = _cast(None, LABEL)
        self.MDTYPE = _cast(None, MDTYPE)
        self.OTHERMDTYPE = _cast(None, OTHERMDTYPE)
        self.MDTYPEVERSION = _cast(None, MDTYPEVERSION)
        self.MIMETYPE = _cast(None, MIMETYPE)
        self.SIZE = _cast(int, SIZE)
        if isinstance(CREATED, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(CREATED, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = CREATED
        self.CREATED = initvalue_
        self.CHECKSUM = _cast(None, CHECKSUM)
        self.CHECKSUMTYPE = _cast(None, CHECKSUMTYPE)
        self.binData = binData
        self.xmlData = xmlData
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, mdWrapType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if mdWrapType.subclass:
            return mdWrapType.subclass(*args_, **kwargs_)
        else:
            return mdWrapType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_binData(self):
        return self.binData
    def set_binData(self, binData):
        self.binData = binData
    def get_xmlData(self):
        return self.xmlData
    def set_xmlData(self, xmlData):
        self.xmlData = xmlData
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_LABEL(self):
        return self.LABEL
    def set_LABEL(self, LABEL):
        self.LABEL = LABEL
    def get_MDTYPE(self):
        return self.MDTYPE
    def set_MDTYPE(self, MDTYPE):
        self.MDTYPE = MDTYPE
    def get_OTHERMDTYPE(self):
        return self.OTHERMDTYPE
    def set_OTHERMDTYPE(self, OTHERMDTYPE):
        self.OTHERMDTYPE = OTHERMDTYPE
    def get_MDTYPEVERSION(self):
        return self.MDTYPEVERSION
    def set_MDTYPEVERSION(self, MDTYPEVERSION):
        self.MDTYPEVERSION = MDTYPEVERSION
    def get_MIMETYPE(self):
        return self.MIMETYPE
    def set_MIMETYPE(self, MIMETYPE):
        self.MIMETYPE = MIMETYPE
    def get_SIZE(self):
        return self.SIZE
    def set_SIZE(self, SIZE):
        self.SIZE = SIZE
    def get_CREATED(self):
        return self.CREATED
    def set_CREATED(self, CREATED):
        self.CREATED = CREATED
    def get_CHECKSUM(self):
        return self.CHECKSUM
    def set_CHECKSUM(self, CHECKSUM):
        self.CHECKSUM = CHECKSUM
    def get_CHECKSUMTYPE(self):
        return self.CHECKSUMTYPE
    def set_CHECKSUMTYPE(self, CHECKSUMTYPE):
        self.CHECKSUMTYPE = CHECKSUMTYPE
    def hasContent_(self):
        if (
            self.binData is not None or
            self.xmlData is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='mdWrapType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('mdWrapType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='mdWrapType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, '', namespacedef_, name_='mdWrapType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='mdWrapType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.LABEL is not None and 'LABEL' not in already_processed:
            already_processed.add('LABEL')
            outfile.write(' LABEL=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.LABEL), input_name='LABEL')), ))
        if 'MDTYPE' not in already_processed:
            already_processed.add('MDTYPE')
            outfile.write(' MDTYPE=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.MDTYPE), input_name='MDTYPE')), ))
        if self.OTHERMDTYPE is not None and 'OTHERMDTYPE' not in already_processed:
            already_processed.add('OTHERMDTYPE')
            outfile.write(' OTHERMDTYPE=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.OTHERMDTYPE), input_name='OTHERMDTYPE')), ))
        if self.MDTYPEVERSION is not None and 'MDTYPEVERSION' not in already_processed:
            already_processed.add('MDTYPEVERSION')
            outfile.write(' MDTYPEVERSION=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.MDTYPEVERSION), input_name='MDTYPEVERSION')), ))
        if self.MIMETYPE is not None and 'MIMETYPE' not in already_processed:
            already_processed.add('MIMETYPE')
            outfile.write(' MIMETYPE=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.MIMETYPE), input_name='MIMETYPE')), ))
        if self.SIZE is not None and 'SIZE' not in already_processed:
            already_processed.add('SIZE')
            outfile.write(' SIZE="%s"' % self.gds_format_integer(self.SIZE, input_name='SIZE'))
        if self.CREATED is not None and 'CREATED' not in already_processed:
            already_processed.add('CREATED')
            outfile.write(' CREATED="%s"' % self.gds_format_datetime(self.CREATED, input_name='CREATED'))
        if self.CHECKSUM is not None and 'CHECKSUM' not in already_processed:
            already_processed.add('CHECKSUM')
            outfile.write(' CHECKSUM=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.CHECKSUM), input_name='CHECKSUM')), ))
        if self.CHECKSUMTYPE is not None and 'CHECKSUMTYPE' not in already_processed:
            already_processed.add('CHECKSUMTYPE')
            outfile.write(' CHECKSUMTYPE=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.CHECKSUMTYPE), input_name='CHECKSUMTYPE')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='mdWrapType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.binData is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbinData>%s</%sbinData>%s' % (namespaceprefix_ , self.gds_format_base64(self.binData, input_name='binData'), namespaceprefix_ , eol_))
        if self.xmlData is not None:
            self.xmlData.export(outfile, level, namespaceprefix_, namespacedef_='', name_='xmlData', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('LABEL', node)
        if value is not None and 'LABEL' not in already_processed:
            already_processed.add('LABEL')
            self.LABEL = value
        value = find_attr_value_('MDTYPE', node)
        if value is not None and 'MDTYPE' not in already_processed:
            already_processed.add('MDTYPE')
            self.MDTYPE = value
        value = find_attr_value_('OTHERMDTYPE', node)
        if value is not None and 'OTHERMDTYPE' not in already_processed:
            already_processed.add('OTHERMDTYPE')
            self.OTHERMDTYPE = value
        value = find_attr_value_('MDTYPEVERSION', node)
        if value is not None and 'MDTYPEVERSION' not in already_processed:
            already_processed.add('MDTYPEVERSION')
            self.MDTYPEVERSION = value
        value = find_attr_value_('MIMETYPE', node)
        if value is not None and 'MIMETYPE' not in already_processed:
            already_processed.add('MIMETYPE')
            self.MIMETYPE = value
        value = find_attr_value_('SIZE', node)
        if value is not None and 'SIZE' not in already_processed:
            already_processed.add('SIZE')
            try:
                self.SIZE = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('CREATED', node)
        if value is not None and 'CREATED' not in already_processed:
            already_processed.add('CREATED')
            try:
                self.CREATED = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (CREATED): %s' % exp)
        value = find_attr_value_('CHECKSUM', node)
        if value is not None and 'CHECKSUM' not in already_processed:
            already_processed.add('CHECKSUM')
            self.CHECKSUM = value
        value = find_attr_value_('CHECKSUMTYPE', node)
        if value is not None and 'CHECKSUMTYPE' not in already_processed:
            already_processed.add('CHECKSUMTYPE')
            self.CHECKSUMTYPE = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'binData':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'binData')
            else:
                bval_ = None
            self.binData = bval_
        elif nodeName_ == 'xmlData':
            obj_ = xmlDataType.factory(parent_object_=self)
            obj_.build(child_)
            self.xmlData = obj_
            obj_.original_tagname_ = 'xmlData'
# end class mdWrapType


class xmlDataType(GeneratedsSuper):
    """The xml data wrapper element <xmlData> is used to contain XML encoded
    metadata. The content of an <xmlData> element can be in any namespace
    or in no namespace. As permitted by the XML Schema Standard, the
    processContents attribute value for the metadata in an <xmlData> is set
    to lax. Therefore, if the source schema and its location are
    identified by means of an XML schemaLocation attribute, then an XML
    processor will validate the elements for which it can find
    declarations. If a source schema is not identified, or cannot be found
    at the specified schemaLocation, then an XML validator will check for
    well-formedness, but otherwise skip over the elements appearing in the
    <xmlData> element."""
    subclass = None
    superclass = None
    def __init__(self, anytypeobjs_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, xmlDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if xmlDataType.subclass:
            return xmlDataType.subclass(*args_, **kwargs_)
        else:
            return xmlDataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def hasContent_(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='xmlDataType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('xmlDataType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='xmlDataType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, '', namespacedef_, name_='xmlDataType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='xmlDataType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='xmlDataType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespaceprefix_, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        content_ = self.gds_build_any(child_, 'xmlDataType')
        self.add_anytypeobjs_(content_)
# end class xmlDataType


class FLocatType(GeneratedsSuper):
    """The file location element <FLocat> provides a pointer to the location of
    a content file. It uses the XLink reference syntax to provide linking
    information indicating the actual location of the content file, along
    with other attributes specifying additional linking information. NOTE:
    <FLocat> is an empty element. The location of the resource pointed to
    MUST be stored in the xlink:href attribute.
    ID (ID/O): This attribute uniquely identifies the element within the METS
    document, and would allow the element to be referenced unambiguously
    from another element or document via an IDREF or an XPTR. For more
    information on using ID attributes for internal and external linking
    see Chapter 4 of the METS Primer.
    USE (string/O): A tagging attribute to indicate the intended use of the
    specific copy of the file represented by the <FLocat> element (e.g.,
    service master, archive master). A USE attribute can be expressed at
    the<fileGrp> level, the <file> level, the <FLocat> level and/or the
    <FContent> level. A USE attribute value at the <fileGrp> level should
    pertain to all of the files in the <fileGrp>. A USE attribute at the
    <file> level should pertain to all copies of the file as represented by
    subsidiary <FLocat> and/or <FContent> elements. A USE attribute at the
    <FLocat> or <FContent> level pertains to the particular copy of the
    file that is either referenced (<FLocat>) or wrapped (<FContent>)."""
    subclass = None
    superclass = None
    def __init__(self, ID=None, USE=None, LOCTYPE=None, OTHERLOCTYPE=None, type_='simple', href=None, role=None, arcrole=None, title=None, show=None, actuate=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ID = _cast(None, ID)
        self.USE = _cast(None, USE)
        self.LOCTYPE = _cast(None, LOCTYPE)
        self.OTHERLOCTYPE = _cast(None, OTHERLOCTYPE)
        self.type_ = _cast(None, type_)
        self.href = _cast(None, href)
        self.role = _cast(None, role)
        self.arcrole = _cast(None, arcrole)
        self.title = _cast(None, title)
        self.show = _cast(None, show)
        self.actuate = _cast(None, actuate)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FLocatType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FLocatType.subclass:
            return FLocatType.subclass(*args_, **kwargs_)
        else:
            return FLocatType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_USE(self):
        return self.USE
    def set_USE(self, USE):
        self.USE = USE
    def get_LOCTYPE(self):
        return self.LOCTYPE
    def set_LOCTYPE(self, LOCTYPE):
        self.LOCTYPE = LOCTYPE
    def get_OTHERLOCTYPE(self):
        return self.OTHERLOCTYPE
    def set_OTHERLOCTYPE(self, OTHERLOCTYPE):
        self.OTHERLOCTYPE = OTHERLOCTYPE
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_href(self):
        return self.href
    def set_href(self, href):
        self.href = href
    def get_role(self):
        return self.role
    def set_role(self, role):
        self.role = role
    def get_arcrole(self):
        return self.arcrole
    def set_arcrole(self, arcrole):
        self.arcrole = arcrole
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def get_show(self):
        return self.show
    def set_show(self, show):
        self.show = show
    def get_actuate(self):
        return self.actuate
    def set_actuate(self, actuate):
        self.actuate = actuate
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FLocatType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FLocatType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FLocatType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, '', namespacedef_, name_='FLocatType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='FLocatType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.USE is not None and 'USE' not in already_processed:
            already_processed.add('USE')
            outfile.write(' USE=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.USE), input_name='USE')), ))
        if 'LOCTYPE' not in already_processed:
            already_processed.add('LOCTYPE')
            outfile.write(' LOCTYPE=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.LOCTYPE), input_name='LOCTYPE')), ))
        if self.OTHERLOCTYPE is not None and 'OTHERLOCTYPE' not in already_processed:
            already_processed.add('OTHERLOCTYPE')
            outfile.write(' OTHERLOCTYPE=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.OTHERLOCTYPE), input_name='OTHERLOCTYPE')), ))
        if self.type_ != "simple" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (quote_attrib(self.href), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.add('role')
            outfile.write(' role=%s' % (quote_attrib(self.role), ))
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            outfile.write(' arcrole=%s' % (quote_attrib(self.arcrole), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.add('title')
            outfile.write(' title=%s' % (quote_attrib(self.title), ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.add('show')
            outfile.write(' show=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.show), input_name='show')), ))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            outfile.write(' actuate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.actuate), input_name='actuate')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FLocatType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('USE', node)
        if value is not None and 'USE' not in already_processed:
            already_processed.add('USE')
            self.USE = value
        value = find_attr_value_('LOCTYPE', node)
        if value is not None and 'LOCTYPE' not in already_processed:
            already_processed.add('LOCTYPE')
            self.LOCTYPE = value
        value = find_attr_value_('OTHERLOCTYPE', node)
        if value is not None and 'OTHERLOCTYPE' not in already_processed:
            already_processed.add('OTHERLOCTYPE')
            self.OTHERLOCTYPE = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.add('role')
            self.role = value
        value = find_attr_value_('arcrole', node)
        if value is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            self.arcrole = value
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.add('title')
            self.title = value
        value = find_attr_value_('show', node)
        if value is not None and 'show' not in already_processed:
            already_processed.add('show')
            self.show = value
        value = find_attr_value_('actuate', node)
        if value is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            self.actuate = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FLocatType


class FContentType(GeneratedsSuper):
    """The file content element <FContent> is used to identify a content file
    contained internally within a METS document. The content file must be
    either Base64 encoded and contained within the subsidiary <binData>
    wrapper element, or consist of XML information and be contained within
    the subsidiary <xmlData> wrapper element.
    ID (ID/O): This attribute uniquely identifies the element within the METS
    document, and would allow the element to be referenced unambiguously
    from another element or document via an IDREF or an XPTR. For more
    information on using ID attributes for internal and external linking
    see Chapter 4 of the METS Primer.
    USE (string/O): A tagging attribute to indicate the intended use of the
    specific copy of the file represented by the <FContent> element (e.g.,
    service master, archive master). A USE attribute can be expressed at
    the<fileGrp> level, the <file> level, the <FLocat> level and/or the
    <FContent> level. A USE attribute value at the <fileGrp> level should
    pertain to all of the files in the <fileGrp>. A USE attribute at the
    <file> level should pertain to all copies of the file as represented by
    subsidiary <FLocat> and/or <FContent> elements. A USE attribute at the
    <FLocat> or <FContent> level pertains to the particular copy of the
    file that is either referenced (<FLocat>) or wrapped (<FContent>)."""
    subclass = None
    superclass = None
    def __init__(self, ID=None, USE=None, binData=None, xmlData=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ID = _cast(None, ID)
        self.USE = _cast(None, USE)
        self.binData = binData
        self.xmlData = xmlData
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FContentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FContentType.subclass:
            return FContentType.subclass(*args_, **kwargs_)
        else:
            return FContentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_binData(self):
        return self.binData
    def set_binData(self, binData):
        self.binData = binData
    def get_xmlData(self):
        return self.xmlData
    def set_xmlData(self, xmlData):
        self.xmlData = xmlData
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_USE(self):
        return self.USE
    def set_USE(self, USE):
        self.USE = USE
    def hasContent_(self):
        if (
            self.binData is not None or
            self.xmlData is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='FContentType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FContentType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FContentType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, '', namespacedef_, name_='FContentType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='FContentType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.USE is not None and 'USE' not in already_processed:
            already_processed.add('USE')
            outfile.write(' USE=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.USE), input_name='USE')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='FContentType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.binData is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbinData>%s</%sbinData>%s' % (namespaceprefix_ , self.gds_format_base64(self.binData, input_name='binData'), namespaceprefix_ , eol_))
        if self.xmlData is not None:
            self.xmlData.export(outfile, level, namespaceprefix_, namespacedef_='', name_='xmlData', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('USE', node)
        if value is not None and 'USE' not in already_processed:
            already_processed.add('USE')
            self.USE = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'binData':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'binData')
            else:
                bval_ = None
            self.binData = bval_
        elif nodeName_ == 'xmlData':
            obj_ = xmlDataType3.factory(parent_object_=self)
            obj_.build(child_)
            self.xmlData = obj_
            obj_.original_tagname_ = 'xmlData'
# end class FContentType


class xmlDataType3(GeneratedsSuper):
    """An xml data wrapper element <xmlData> is used to contain an XML encoded
    file. The content of an <xmlData> element can be in any namespace or in
    no namespace. As permitted by the XML Schema Standard, the
    processContents attribute value for the metadata in an <xmlData>
    element is set to lax. Therefore, if the source schema and its
    location are identified by means of an xsi:schemaLocation attribute,
    then an XML processor will validate the elements for which it can find
    declarations. If a source schema is not identified, or cannot be found
    at the specified schemaLocation, then an XML validator will check for
    well-formedness, but otherwise skip over the elements appearing in the
    <xmlData> element."""
    subclass = None
    superclass = None
    def __init__(self, anytypeobjs_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, xmlDataType3)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if xmlDataType3.subclass:
            return xmlDataType3.subclass(*args_, **kwargs_)
        else:
            return xmlDataType3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def hasContent_(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='xmlDataType3', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('xmlDataType3')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='xmlDataType3')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, '', namespacedef_, name_='xmlDataType3', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='xmlDataType3'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='xmlDataType3', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespaceprefix_, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        content_ = self.gds_build_any(child_, 'xmlDataType3')
        self.add_anytypeobjs_(content_)
# end class xmlDataType3


class streamType(GeneratedsSuper):
    """A component byte stream element <stream> may be composed of one or more
    subsidiary streams. An MPEG4 file, for example, might contain separate
    audio and video streams, each of which is associated with technical
    metadata. The repeatable <stream> element provides a mechanism to
    record the existence of separate data streams within a particular file,
    and the opportunity to associate <dmdSec> and <amdSec> with those
    subsidiary data streams if desired. ID (ID/O): This attribute uniquely
    identifies the element within the METS document, and would allow the
    element to be referenced unambiguously from another element or document
    via an IDREF or an XPTR. For more information on using ID attributes
    for internal and external linking see Chapter 4 of the METS Primer.
    streamType (string/O): The IANA MIME media type for the bytestream.OWNERID
    (string/O): Used to provide a unique identifier (which could include a
    URI) assigned to the file. This identifier may differ from the URI used
    to retrieve the file.
    ADMID (IDREFS/O): Contains the ID attribute values of the <techMD>,
    <sourceMD>, <rightsMD> and/or <digiprovMD> elements within the <amdSec>
    of the METS document that contain administrative metadata pertaining to
    the bytestream. For more information on using METS IDREFS and IDREF
    type attributes for internal linking, see Chapter 4 of the METS Primer.
    DMDID (IDREFS/O): Contains the ID attribute values identifying the
    <dmdSec>, elements in the METS document that contain or link to
    descriptive metadata pertaining to the content file stream represented
    by the current <stream> element. For more information on using METS
    IDREFS and IDREF type attributes for internal linking, see Chapter 4 of
    the METS Primer.
    BEGIN (string/O): An attribute that specifies the point in the parent
    <file> where the current <stream> begins. It can be used in conjunction
    with the END attribute as a means of defining the location of the
    stream within its parent file. However, the BEGIN attribute can be used
    with or without a companion END attribute. When no END attribute is
    specified, the end of the parent file is assumed also to be the end
    point of the stream. The BEGIN and END attributes can only be
    interpreted meaningfully in conjunction with a BETYPE attribute, which
    specifies the kind of beginning/ending point values that are being
    used.
    END (string/O): An attribute that specifies the point in the parent <file>
    where the <stream> ends. It can only be interpreted meaningfully in
    conjunction with the BETYPE, which specifies the kind of ending point
    values being used. Typically the END attribute would only appear in
    conjunction with a BEGIN attribute.
    BETYPE: Begin/End Type.
    BETYPE (string/O): An attribute that specifies the kind of BEGIN and/or END
    values that are being used. Currently BYTE is the only valid value that
    can be used in conjunction with nested <file> or <stream> elements."""
    subclass = None
    superclass = None
    def __init__(self, ID=None, streamType_member=None, OWNERID=None, ADMID=None, DMDID=None, BEGIN=None, END=None, BETYPE=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ID = _cast(None, ID)
        self.streamType = _cast(None, streamType_member)
        self.OWNERID = _cast(None, OWNERID)
        self.ADMID = _cast(None, ADMID)
        self.DMDID = _cast(None, DMDID)
        self.BEGIN = _cast(None, BEGIN)
        self.END = _cast(None, END)
        self.BETYPE = _cast(None, BETYPE)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, streamType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if streamType.subclass:
            return streamType.subclass(*args_, **kwargs_)
        else:
            return streamType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_streamType(self):
        return self.streamType
    def set_streamType(self, streamType):
        self.streamType = streamType
    def get_OWNERID(self):
        return self.OWNERID
    def set_OWNERID(self, OWNERID):
        self.OWNERID = OWNERID
    def get_ADMID(self):
        return self.ADMID
    def set_ADMID(self, ADMID):
        self.ADMID = ADMID
    def get_DMDID(self):
        return self.DMDID
    def set_DMDID(self, DMDID):
        self.DMDID = DMDID
    def get_BEGIN(self):
        return self.BEGIN
    def set_BEGIN(self, BEGIN):
        self.BEGIN = BEGIN
    def get_END(self):
        return self.END
    def set_END(self, END):
        self.END = END
    def get_BETYPE(self):
        return self.BETYPE
    def set_BETYPE(self, BETYPE):
        self.BETYPE = BETYPE
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='streamType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('streamType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='streamType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, '', namespacedef_, name_='streamType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='streamType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.streamType is not None and 'streamType' not in already_processed:
            already_processed.add('streamType')
            outfile.write(' streamType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.streamType), input_name='streamType')), ))
        if self.OWNERID is not None and 'OWNERID' not in already_processed:
            already_processed.add('OWNERID')
            outfile.write(' OWNERID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.OWNERID), input_name='OWNERID')), ))
        if self.ADMID is not None and 'ADMID' not in already_processed:
            already_processed.add('ADMID')
            outfile.write(' ADMID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ADMID), input_name='ADMID')), ))
        if self.DMDID is not None and 'DMDID' not in already_processed:
            already_processed.add('DMDID')
            outfile.write(' DMDID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.DMDID), input_name='DMDID')), ))
        if self.BEGIN is not None and 'BEGIN' not in already_processed:
            already_processed.add('BEGIN')
            outfile.write(' BEGIN=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.BEGIN), input_name='BEGIN')), ))
        if self.END is not None and 'END' not in already_processed:
            already_processed.add('END')
            outfile.write(' END=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.END), input_name='END')), ))
        if self.BETYPE is not None and 'BETYPE' not in already_processed:
            already_processed.add('BETYPE')
            outfile.write(' BETYPE=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.BETYPE), input_name='BETYPE')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='streamType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('streamType', node)
        if value is not None and 'streamType' not in already_processed:
            already_processed.add('streamType')
            self.streamType = value
        value = find_attr_value_('OWNERID', node)
        if value is not None and 'OWNERID' not in already_processed:
            already_processed.add('OWNERID')
            self.OWNERID = value
        value = find_attr_value_('ADMID', node)
        if value is not None and 'ADMID' not in already_processed:
            already_processed.add('ADMID')
            self.ADMID = value
        value = find_attr_value_('DMDID', node)
        if value is not None and 'DMDID' not in already_processed:
            already_processed.add('DMDID')
            self.DMDID = value
        value = find_attr_value_('BEGIN', node)
        if value is not None and 'BEGIN' not in already_processed:
            already_processed.add('BEGIN')
            self.BEGIN = value
        value = find_attr_value_('END', node)
        if value is not None and 'END' not in already_processed:
            already_processed.add('END')
            self.END = value
        value = find_attr_value_('BETYPE', node)
        if value is not None and 'BETYPE' not in already_processed:
            already_processed.add('BETYPE')
            self.BETYPE = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class streamType


class transformFileType(GeneratedsSuper):
    """The transform file element <transformFile> provides a means to access
    any subsidiary files listed below a <file> element by indicating the
    steps required to "unpack" or transform the subsidiary files. This
    element is repeatable and might provide a link to a <behavior> in the
    <behaviorSec> that performs the transformation.ID (ID/O): This
    attribute uniquely identifies the element within the METS document, and
    would allow the element to be referenced unambiguously from another
    element or document via an IDREF or an XPTR. For more information on
    using ID attributes for internal and external linking see Chapter 4 of
    the METS Primer.
    TRANSFORMTYPE (string/R): Is used to indicate the type of transformation
    needed to render content of a file accessible. This may include
    unpacking a file into subsidiary files/streams. The controlled value
    constraints for this XML string include decompression and
    decryption. Decompression is defined as the action of reversing data
    compression, i.e., the process of encoding information using fewer bits
    than an unencoded representation would use by means of specific
    encoding schemas. Decryption is defined as the process of restoring
    data that has been obscured to make it unreadable without special
    knowledge (encrypted data) to its original form. TRANSFORM-ALGORITHM
    (string/R): Specifies the decompression or decryption routine used to
    access the contents of the file. Algorithms for compression can be
    either loss-less or lossy.TRANSFORMKEY (string/O): A key to be used
    with the transform algorithm for accessing the files
    contents.TRANSFORMBEHAVIOR (string/O): An IDREF to a behavior element
    for this transformation.TRANSFORMORDER (postive-integer/R): The order
    in which the instructions must be followed in order to unpack or
    transform the container file."""
    subclass = None
    superclass = None
    def __init__(self, ID=None, TRANSFORMTYPE=None, TRANSFORMALGORITHM=None, TRANSFORMKEY=None, TRANSFORMBEHAVIOR=None, TRANSFORMORDER=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ID = _cast(None, ID)
        self.TRANSFORMTYPE = _cast(None, TRANSFORMTYPE)
        self.TRANSFORMALGORITHM = _cast(None, TRANSFORMALGORITHM)
        self.TRANSFORMKEY = _cast(None, TRANSFORMKEY)
        self.TRANSFORMBEHAVIOR = _cast(None, TRANSFORMBEHAVIOR)
        self.TRANSFORMORDER = _cast(int, TRANSFORMORDER)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, transformFileType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if transformFileType.subclass:
            return transformFileType.subclass(*args_, **kwargs_)
        else:
            return transformFileType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_TRANSFORMTYPE(self):
        return self.TRANSFORMTYPE
    def set_TRANSFORMTYPE(self, TRANSFORMTYPE):
        self.TRANSFORMTYPE = TRANSFORMTYPE
    def get_TRANSFORMALGORITHM(self):
        return self.TRANSFORMALGORITHM
    def set_TRANSFORMALGORITHM(self, TRANSFORMALGORITHM):
        self.TRANSFORMALGORITHM = TRANSFORMALGORITHM
    def get_TRANSFORMKEY(self):
        return self.TRANSFORMKEY
    def set_TRANSFORMKEY(self, TRANSFORMKEY):
        self.TRANSFORMKEY = TRANSFORMKEY
    def get_TRANSFORMBEHAVIOR(self):
        return self.TRANSFORMBEHAVIOR
    def set_TRANSFORMBEHAVIOR(self, TRANSFORMBEHAVIOR):
        self.TRANSFORMBEHAVIOR = TRANSFORMBEHAVIOR
    def get_TRANSFORMORDER(self):
        return self.TRANSFORMORDER
    def set_TRANSFORMORDER(self, TRANSFORMORDER):
        self.TRANSFORMORDER = TRANSFORMORDER
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='transformFileType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('transformFileType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='transformFileType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, '', namespacedef_, name_='transformFileType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='transformFileType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if 'TRANSFORMTYPE' not in already_processed:
            already_processed.add('TRANSFORMTYPE')
            outfile.write(' TRANSFORMTYPE=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.TRANSFORMTYPE), input_name='TRANSFORMTYPE')), ))
        if 'TRANSFORMALGORITHM' not in already_processed:
            already_processed.add('TRANSFORMALGORITHM')
            outfile.write(' TRANSFORMALGORITHM=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.TRANSFORMALGORITHM), input_name='TRANSFORMALGORITHM')), ))
        if self.TRANSFORMKEY is not None and 'TRANSFORMKEY' not in already_processed:
            already_processed.add('TRANSFORMKEY')
            outfile.write(' TRANSFORMKEY=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.TRANSFORMKEY), input_name='TRANSFORMKEY')), ))
        if self.TRANSFORMBEHAVIOR is not None and 'TRANSFORMBEHAVIOR' not in already_processed:
            already_processed.add('TRANSFORMBEHAVIOR')
            outfile.write(' TRANSFORMBEHAVIOR=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.TRANSFORMBEHAVIOR), input_name='TRANSFORMBEHAVIOR')), ))
        if 'TRANSFORMORDER' not in already_processed:
            already_processed.add('TRANSFORMORDER')
            outfile.write(' TRANSFORMORDER="%s"' % self.gds_format_integer(self.TRANSFORMORDER, input_name='TRANSFORMORDER'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='transformFileType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('TRANSFORMTYPE', node)
        if value is not None and 'TRANSFORMTYPE' not in already_processed:
            already_processed.add('TRANSFORMTYPE')
            self.TRANSFORMTYPE = value
        value = find_attr_value_('TRANSFORMALGORITHM', node)
        if value is not None and 'TRANSFORMALGORITHM' not in already_processed:
            already_processed.add('TRANSFORMALGORITHM')
            self.TRANSFORMALGORITHM = value
        value = find_attr_value_('TRANSFORMKEY', node)
        if value is not None and 'TRANSFORMKEY' not in already_processed:
            already_processed.add('TRANSFORMKEY')
            self.TRANSFORMKEY = value
        value = find_attr_value_('TRANSFORMBEHAVIOR', node)
        if value is not None and 'TRANSFORMBEHAVIOR' not in already_processed:
            already_processed.add('TRANSFORMBEHAVIOR')
            self.TRANSFORMBEHAVIOR = value
        value = find_attr_value_('TRANSFORMORDER', node)
        if value is not None and 'TRANSFORMORDER' not in already_processed:
            already_processed.add('TRANSFORMORDER')
            try:
                self.TRANSFORMORDER = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.TRANSFORMORDER <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class transformFileType


class mets(metsType):
    """METS: Metadata Encoding and Transmission Standard.
    METS is intended to provide a standardized XML format for transmission of
    complex digital library objects between systems. As such, it can be
    seen as filling a role similar to that defined for the Submission
    Information Package (SIP), Archival Information Package (AIP) and
    Dissemination Information Package (DIP) in the Reference Model for an
    Open Archival Information System. The root element <mets> establishes
    the container for the information being stored and/or transmitted by
    the standard."""
    subclass = None
    superclass = metsType
    def __init__(self, ID=None, OBJID=None, LABEL=None, TYPE=None, PROFILE=None, metsHdr=None, dmdSec=None, amdSec=None, fileSec=None, structMap=None, structLink=None, behaviorSec=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(mets, self).__init__(ID, OBJID, LABEL, TYPE, PROFILE, metsHdr, dmdSec, amdSec, fileSec, structMap, structLink, behaviorSec,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, mets)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if mets.subclass:
            return mets.subclass(*args_, **kwargs_)
        else:
            return mets(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(mets, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='mets', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('mets')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='mets')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, '', namespacedef_, name_='mets', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='mets'):
        super(mets, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='mets')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='mets', fromsubclass_=False, pretty_print=True):
        super(mets, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(mets, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(mets, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class mets


GDSClassesMapping = {
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'mets'
        rootClass = mets
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'mets'
        rootClass = mets
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'mets'
        rootClass = mets
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'mets'
        rootClass = mets
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from mets_generateds import *\n\n')
        sys.stdout.write('import mets_generateds as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()

RenameMappings_ = {
}

__all__ = [
    "FContentType",
    "FLocatType",
    "agentType",
    "altRecordIDType",
    "amdSecType",
    "areaType",
    "behaviorSecType",
    "behaviorType",
    "divType",
    "fileGrpType",
    "fileGrpType1",
    "fileSecType",
    "fileType",
    "fptrType",
    "mdRefType",
    "mdSecType",
    "mdWrapType",
    "mets",
    "metsDocumentIDType",
    "metsHdrType",
    "metsType",
    "mptrType",
    "noteType",
    "objectType",
    "parType",
    "seqType",
    "smArcLinkType",
    "smLinkGrpType",
    "smLinkType",
    "smLocatorLinkType",
    "streamType",
    "structLinkType",
    "structLinkType2",
    "structMapType",
    "transformFileType",
    "xmlDataType",
    "xmlDataType3"
]
